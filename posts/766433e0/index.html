<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>SSM框架 | Lin's Blog</title><meta name="keywords" content="Java"><meta name="author" content="rtlin"><meta name="copyright" content="rtlin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SpingBootstarterStarter是Spring Boot中的一个非常重要的概念，Starter相当于模块，它能将模块所需的依赖整合起来并对模块内的Bean根据环境（ 条件）进行自动配置。使用者只需要依赖相应功能的Starter，无需做过多的配置和依赖，Spring Boot就能自动扫描并加载相应的模块。 Spring Boot通过提供众多起步依赖（Starter）降低项目依赖的复杂度">
<meta property="og:type" content="article">
<meta property="og:title" content="SSM框架">
<meta property="og:url" content="https://mumu-lsl.github.io/posts/766433e0/index.html">
<meta property="og:site_name" content="Lin&#39;s Blog">
<meta property="og:description" content="SpingBootstarterStarter是Spring Boot中的一个非常重要的概念，Starter相当于模块，它能将模块所需的依赖整合起来并对模块内的Bean根据环境（ 条件）进行自动配置。使用者只需要依赖相应功能的Starter，无需做过多的配置和依赖，Spring Boot就能自动扫描并加载相应的模块。 Spring Boot通过提供众多起步依赖（Starter）降低项目依赖的复杂度">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/11/04/4kAthI2sEwCgPio.jpg">
<meta property="article:published_time" content="2022-11-04T07:59:06.000Z">
<meta property="article:modified_time" content="2022-11-04T09:59:24.650Z">
<meta property="article:author" content="rtlin">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/11/04/4kAthI2sEwCgPio.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mumu-lsl.github.io/posts/766433e0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SSM框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-04 17:59:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/11/04/4kAthI2sEwCgPio.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lin's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SSM框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-04T07:59:06.000Z" title="发表于 2022-11-04 15:59:06">2022-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-04T09:59:24.650Z" title="更新于 2022-11-04 17:59:24">2022-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SSM框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SpingBoot"><a href="#SpingBoot" class="headerlink" title="SpingBoot"></a>SpingBoot</h1><h2 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h2><p>Starter是Spring Boot中的一个非常重要的概念，Starter相当于模块，它能将模块所需的依赖整合起来并对模块内的Bean根据环境（ 条件）进行自动配置。使用者只需要依赖相应功能的Starter，无需做过多的配置和依赖，Spring Boot就能自动扫描并加载相应的模块。</p>
<p>Spring Boot通过提供众多起步依赖（Starter）降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型（Project Object Model, POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。</p>
<h2 id="实现一个Starter"><a href="#实现一个Starter" class="headerlink" title="实现一个Starter"></a>实现一个Starter</h2><p>编写Starter非常简单，与编写一个普通的Spring Boot应用没有太大区别，总结如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.新建Maven项目，在项目的POM文件中定义使用的依赖；</span><br><span class="line"><span class="number">2</span>.新建配置类，写好配置项和默认的配置值，指明配置项前缀；</span><br><span class="line"><span class="number">3</span>.新建自动装配类，使用 <span class="keyword">@Configuration</span> 和 @Bean 来进行自动装配；</span><br><span class="line"><span class="number">4</span>.新建spring.factories文件，指定Starter的自动装配类；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>spring.factories文件位于resources&#x2F;META-INF目录下，需要手动创建;<br> <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>后面的类名说明了自动装配类，如果有多个 ，则用逗号分开;<br> 使用者应用（SpringBoot）在启动的时候，会通过<code>org.springframework.core.io.support.SpringFactoriesLoader</code>读取classpath下每个Starter的spring.factories文件，加载自动装配类进行Bean的自动装配；</p>
</blockquote>
<h2 id="SpringBoot启动过程？"><a href="#SpringBoot启动过程？" class="headerlink" title="SpringBoot启动过程？"></a>SpringBoot启动过程？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDemoApplication</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(SpringDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;primarySource&#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用此方法启动会使用默认设置和用户提供的参数args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">// 实例化SpringApplication，然后调用run</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringBoot的启动过程主要分为了两个过程：</p>
<p><code>SpringBoot</code>应用程序的启动流程主要包括初始化<code>SpringApplication</code>和运行<code>SpringApplication</code>两个过程。其中初始化<code>SpringApplication</code>包括配置基本的环境变量、资源、构造器和监听器，为运行<code>SpringApplciation</code>实例对象作准备；而运行<code>SpringApplication</code>实例为应用程序正式启动加载过程，包括<code>SpringApplicationRunListeners </code> 引用启动监控模块、<code>ConfigrableEnvironment</code>配置环境模块和监听及<code>ConfigrableApplicationContext</code>配置应用上下文。当完成刷新应用的上下文和调用<code>SpringApplicationRunListener#contextPrepared</code>方法后表示<code>SpringBoot</code>应用程序已经启动完成。</p>
<ol>
<li>调用SpringApplication的构造函数实例化SpringApplication</li>
<li>用实例化后的对象调用run（）方法</li>
</ol>
<p><strong>调用SpringApplication的构造函数实例化SpringApplication</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>配置primarySources</li>
<li>推断配置环境是否为web环境</li>
<li>获取启动加载器</li>
<li>创建初始化构造器setInitializers</li>
<li>创建应用监听器</li>
<li>配置应用主方法所在类（就是main方法所在类）</li>
</ol>
<p><strong>用实例化后的对象调用run（）方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行spring应用程序，创建并刷新一个新的 &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">	<span class="comment">// 计时工具</span></span><br><span class="line">	<span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">	stopWatch.start();</span><br><span class="line">	<span class="comment">// 创建启动上下文对象</span></span><br><span class="line">	<span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> createBootstrapContext();</span><br><span class="line">	<span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">	<span class="comment">// 第一步：获取并启动监听器</span></span><br><span class="line">	<span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">	listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">		<span class="comment">//创建应用程序环境 配置文件在此处读取(application.properties application.yml)</span></span><br><span class="line">		<span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">		<span class="comment">// 第三步：打印banner，就是启动的时候在console的spring图案</span></span><br><span class="line">		<span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">		<span class="comment">// 第四步：创建spring容器</span></span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">		context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup);</span><br><span class="line">		<span class="comment">// 第五步：spring容器前置处理</span></span><br><span class="line">		prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">		<span class="comment">// 第六步：刷新容器</span></span><br><span class="line">		refreshContext(context);</span><br><span class="line">		<span class="comment">// 第七步：spring容器后置处理</span></span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">		stopWatch.stop(); <span class="comment">// 结束计时器并打印，这就是我们启动后console的显示的时间</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 发出启动结束事件</span></span><br><span class="line">		listeners.started(context);</span><br><span class="line">		<span class="comment">// 执行runner的run方法</span></span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// 异常处理，如果run过程发生异常</span></span><br><span class="line">		handleRunFailure(context, ex, listeners);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		listeners.running(context);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// 异常处理，如果run过程发生异常</span></span><br><span class="line">		handleRunFailure(context, ex, <span class="literal">null</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回最终构建的容器对象</span></span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>启动一个计时器，启动完成后会打印耗时</li>
<li>获取并启动监听器 SpringApplicationRunListeners。springboot在启动过程中会调用监听器模块，将开始事件、环境准备事件、启动完成&#x2F;失败、准备完成等事件发布出去</li>
<li>配置环境 ConfigurableEnvironment，</li>
<li>Banner配置，就是控制台的那个spirng</li>
<li>创建spring容器</li>
<li>前置处理、刷新、后置处理ConfigurableApplicationContext</li>
<li>发出启动结束事件并结束计时</li>
</ol>
<p>SpringBoot启动过程中最核心的部分就是<strong>刷新容器</strong>。这里做了很多：工厂配置，bean处理器配置，类的扫描，解析，bean定义，bean类信息缓存，服务器创建，bean实例化，动态代理对象的创建等，</p>
<h2 id="SpringBoot的自动配置原理"><a href="#SpringBoot的自动配置原理" class="headerlink" title="SpringBoot的自动配置原理"></a>SpringBoot的自动配置原理</h2><p><img src="/posts/766433e0/Users/zumum/AppData/Roaming/Typora/typora-user-images/image-20220910115723050.png" alt="image-20220910115723050"></p>
<p><img src="/posts/766433e0/Users/zumum/AppData/Roaming/Typora/typora-user-images/image-20220910115739175.png" alt="image-20220910115739175"></p>
<p>使用Spring Boot时，我们只需引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694273137/4C6D51AEA1E10E3717A8BE4AE88B6F79" alt="img"></p>
<p>整个自动装配的过程是：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</p>
<h2 id="SpringBoot相关注解"><a href="#SpringBoot相关注解" class="headerlink" title="SpringBoot相关注解"></a>SpringBoot相关注解</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tqlin/p/11687811.html">Spring Boot 常用注解汇总 - 云天 - 博客园 (cnblogs.com)</a></p>
<p>@SpringBootApplication：@SpringBootApplication是一个复合注解，包含了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan这三个注解</p>
<p>@RequestBody 注解则是将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。<br>作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。</p>
<p>@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML</a>数据。</p>
<p>@Controller：控制器，处理http请求。</p>
<p>@RestController 复合注解。@RestController注解相当于@ResponseBody+@Controller合在一起的作用,RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式.</p>
<p>@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上</p>
<p>@PathVariable:获取url中的数据</p>
<p>@RequestParam:获取请求参数的值</p>
<p>@RequestHeader 把Request请求header部分的值绑定到方法的参数上</p>
<p>@CookieValue 把Request header中关于cookie的值绑定到方法的参数上</p>
<p>@Repository：DAO层注解，DAO层中接口继承JpaRepository&lt;T,ID extends Serializable&gt;,需要在build.gradle中引入相关jpa的一个jar自动加载。</p>
<p>@Service是@Component注解的一个特例，作用在类上。使用注解配置和类路径扫描时，被@Service注解标注的类会被Spring扫描并注册为Bean</p>
<p>@Scope作用在类上和方法上，用来配置 spring bean 的作用域，它标识 bean 的作用域</p>
<p>@PropertySource注解引入单个properties文件：</p>
<p>@ImportResource导入xml配置文件</p>
<p>@Import 导入额外的配置信息</p>
<p>@Transactional：在Spring中，事务有两种实现方式，分别是编程式事务管理和声明式事务管理两种方式</p>
<ul>
<li>编程式事务管理： 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</li>
<li>声明式事务管理： 建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务，通过@Transactional就可以进行事务操作，更快捷而且简单。推荐使用</li>
</ul>
<p>@ControllerAdvice 统一处理异常</p>
<p>@ExceptionHandler 注解声明异常处理方法</p>
<h1 id="Spring-使用"><a href="#Spring-使用" class="headerlink" title="Spring 使用"></a>Spring 使用</h1><h2 id="Spring的核心"><a href="#Spring的核心" class="headerlink" title="Spring的核心"></a>Spring的核心</h2><p>Spring框架包含众多模块，如<strong>Core、Test、Data Access、Web Servlet</strong>等，其中Core是整个Spring框架的核心模块。Core模块提供了<strong>IoC容器、AOP功能、数据绑定、类型转换</strong>等一系列的基础功能，而这些功能以及其他模块的功能都是建立在IoC和AOP之上的，所以IoC和AOP是Spring框架的核心。</p>
<p>IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。</p>
<p>说到IoC就不得不说DI（Dependency Injection），DI是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。而实现 DI 的关键是IoC容器，它的本质就是一个工厂。</p>
<p> <img src="https://s2.loli.net/2022/07/19/tjDZH2il4NgmPEp.png" alt="Spring主要模块"></p>
<p>Spring Data Access&#x2F;Integration 由 5 个模块组成：</p>
<ul>
<li>spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li>
<li>spring-tx : 提供对事务的支持。</li>
<li>spring-orm : 提供对 Hibernate 等 ORM 框架的支持。</li>
<li>spring-oxm ： 提供对 Castor 等 OXM 框架的支持。</li>
<li>spring-jms : Java 消息服务。</li>
</ul>
<p>Spring Web 由 4 个模块组成：</p>
<ul>
<li>spring-web ：对 Web 功能的实现提供一些最基础的支持。</li>
<li>spring-webmvc ： 提供对 Spring MVC 的实现。</li>
<li>spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li>
<li>spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.</li>
</ul>
<p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img src="https://s2.loli.net/2022/07/19/h5mdGokECrv6tZV.png" alt="img"></p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p><strong>参考答案</strong></p>
<p>默认情况下，Bean在Spring容器中是单例的，我们可以通过@Scope注解修改Bean的作用域。该注解有如下5个取值，它们代表了Bean的5种不同类型的作用域：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">prototype</td>
<td align="left">每次调用getBean()时，都会执行new操作，返回一个新的实例。</td>
</tr>
<tr>
<td align="left">singleton</td>
<td align="left">在Spring容器中仅存在一个实例，即Bean以单例的形式存在。</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left">每次HTTP请求都会创建一个新的Bean。</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。</td>
</tr>
<tr>
<td align="left">globalSession</td>
<td align="left">同一个全局的Session共享一个Bean，一般用于Portlet环境。</td>
</tr>
</tbody></table>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>主要是四个阶段：</p>
<ul>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ul>
<p>1.如果创建了一个类继承了InstantiationAwareBeanPostProcessorAdapter接口，并在配置文件中配置了该类的注入，即<code>InstantiationAwareBeanPostProcessorAdapter</code>和bean关联，则Spring将调用该接口的postProcessBeforeInstantiation（）方法。<br>2.<strong>根据配置情况调用 Bean 构造方法或工厂方法实例化 Bean。</strong><br>3.如果<code>InstantiationAwareBeanPostProcessorAdapter</code>和bean关联，则Spring将调用该接口<code>postProcessAfterInstantiation</code>方法。<br><strong>4.利用依赖注入完成 Bean 中所有属性值的配置注入。</strong></p>
<p>5.如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。<br>6.如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。<br>7.如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。</p>
<p>8.如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 <code>postProcessBeforeInitialzation() </code>对 Bean 进行加工操作，<strong>此处非常重要，Spring 的 AOP 就是利用它实现的</strong>。<br>9.如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 <code>afterPropertiesSet() </code>方法。</p>
<p>10.如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。</p>
<p>11.如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。</p>
<p>注意：以上工作完后才能以后就可以应用这个bean了，那这个bean是一个singleton的，所以一般这种情况下我们调用同一个id的bean会是在内容地址相同的实例，当然在spring配置文件中也可以配置非Singleton。</p>
<p>12.如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9654439-e00bbd5200e2cf48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720/format/webp" alt="img"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694380479/7EF8F66C3DFA7434E4CA11B47CF8F1F7" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210710134349143.png" alt="    "></p>
<p>对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。</p>
<p>而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够</li>
</ul>
<p>生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</p>
<h2 id="Spring三级缓存"><a href="#Spring三级缓存" class="headerlink" title="Spring三级缓存"></a>Spring三级缓存</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1796740">Spring系列第56篇：一文搞懂spring到底为什么要用三级缓存？？ - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><code>Spring三级缓存</code>是为了解决<strong>对象间的循环依赖</strong>问题。</p>
<p> 构造器注入构成的循环依赖，此种循环依赖方式<strong>是无法解决的</strong>，创建 A 的时候需要先有 B，而创建 B 的时候需要先有 A，导致无法创建成功。只能抛出<code>BeanCurrentlyInCreationException</code>异常表示循环依赖。这也是构造器注入的最大劣势</p>
<p> <code>根本原因</code>：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是<code>已经实例化</code>，但还没初始化的状态。而构造器是完成实例化的，所以构造器的循环依赖无法解决</p>
<h3 id="Spring是如何发现循环依赖的？"><a href="#Spring是如何发现循环依赖的？" class="headerlink" title="Spring是如何发现循环依赖的？"></a>Spring是如何发现循环依赖的？</h3><blockquote>
<p>1、从singletonObjects查看是否有a，此时没有 </p>
<p>2、准备创建a </p>
<p>3、判断a是否在singletonsCurrentlyInCreation列表，此时明显不在，则将a加入singletonsCurrentlyInCreation列表</p>
<p>4、调用a的构造器A(B b)创建A</p>
<p>5、spring发现A的构造器需要用到b </p>
<p>6、则向spring容器查找b，从singletonObjects查看是否有b，此时没有 </p>
<p>7、spring准备创建b </p>
<p>8、判断b是否在singletonsCurrentlyInCreation列表，此时明显不在，则将b加入singletonsCurrentlyInCreation列表</p>
<p>9、调用b的构造器B(A a)创建b </p>
<p>10、spring发现B的构造器需要用到a，则向spring容器查找a </p>
<p>11、则向spring容器查找a，从singletonObjects查看是否有a，此时没有 </p>
<p>12、准备创建a </p>
<p>13、判断a是否在singletonsCurrentlyInCreation列表，上面第3步中a被放到了这个列表，此时a在这个列表中，走到这里了，说明a已经存在创建列表中了，此时程序又来创建a，说明这么一直走下去会死循环，此时spring会弹出异常，终止bean的创建操作。</p>
</blockquote>
<h3 id="三级缓存概述"><a href="#三级缓存概述" class="headerlink" title="三级缓存概述"></a>三级缓存概述</h3><p>spring 中使用了 3 个 map 来作为三级缓存，每一级对应一个 map</p>
<table>
<thead>
<tr>
<th align="left">第几级缓存</th>
<th align="left">对应的 map</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第 1 级</td>
<td align="left">Map&lt;String, Object&gt; singletonObjects</td>
<td align="left">用来存放已经完全创建好的单例 beanName-&gt;bean 实例</td>
</tr>
<tr>
<td align="left">第 2 级</td>
<td align="left">Map&lt;String, Object&gt; earlySingletonObjects</td>
<td align="left">用来存放早期的 beanName-&gt;bean 实例</td>
</tr>
<tr>
<td align="left">第 3 级</td>
<td align="left">Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</td>
<td align="left">用来存放单例 bean 的 ObjectFactorybeanName-&gt;ObjectFactory 实例</td>
</tr>
</tbody></table>
<ul>
<li>singletonObject：一级缓存，存放完全实例化且属性赋值完成的 Bean ，可以直接使用</li>
<li>earlySingletonObjects：二级缓存，存放早期 Bean 的引用，尚未装配属性的 Bean</li>
<li>singletonFactories：三级缓存，存放实例化完成的 Bean 工厂</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-6569578/42c63cd9a94d0d2d4000473cabc221b7.png?imageView2/2/w/1620" alt="img"></p>
<h3 id="单例-bean-创建过程源码解析："><a href="#单例-bean-创建过程源码解析：" class="headerlink" title="单例 bean 创建过程源码解析："></a><strong>单例 bean 创建过程源码解析</strong>：</h3><h4 id="step1："><a href="#step1：" class="headerlink" title="step1："></a><strong>step1：</strong></h4><p><strong><code>doGetBean</code></strong></p>
<p>这个方法内部会调用<code>getSingleton(beanName)</code>，而这个方法内部会调用<code>getSingleton(beanName, true)</code>获取 bean，注意第二个参数是<code>true</code>，这个表示是否可以获取早期的 bean，这个参数为 true，会尝试从三级缓存<code>singletonFactories</code>中获取 bean，然后将三级缓存中获取到的 bean 丢到二级缓存中。</p>
<h4 id="step2："><a href="#step2：" class="headerlink" title="step2："></a><strong>step2：</strong></h4><p><strong><code>getSingleton(beanName, true)</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">//从第1级缓存中获取bean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">//第1级中没有,且当前beanName在创建列表中</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//从第2级缓存汇总获取bean</span></span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//第2级缓存中没有 &amp;&amp; allowEarlyReference为true，也就是说2级缓存中没有找到bean且beanName在当前创建列表中的时候，才会继续想下走。</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">//从第3级缓存中获取bean</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="comment">//第3级中有获取到了</span></span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//3级缓存汇总放的是ObjectFactory，所以会调用其getObject方法获取bean</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">//将3级缓存中的bean丢到第2级中</span></span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">//将bean从三级缓存中干掉</span></span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="step3："><a href="#step3：" class="headerlink" title="step3："></a><strong>step3：</strong></h4><p><strong><code>getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</code></strong></p>
<p>上面调用<code>getSingleton(beanName, true)</code>没有获取到 bean，所以会继续走 bean 的创建逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    <span class="comment">//从第1级缓存中获取bean，如果可以获取到，则自己返回</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将beanName加入当前创建列表中</span></span><br><span class="line">        beforeSingletonCreation(beanName);</span><br><span class="line">        <span class="comment">//①：创建单例bean</span></span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        <span class="comment">//将beanName从当前创建列表中移除</span></span><br><span class="line">        afterSingletonCreation(beanName);</span><br><span class="line">        <span class="comment">//将创建好的单例bean放到1级缓存中,并将其从2、3级缓存中移除</span></span><br><span class="line">        addSingleton(beanName, singletonObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="step4："><a href="#step4：" class="headerlink" title="step4："></a><strong>step4：</strong></h4><p><strong><code>doCreateBean</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ①：创建bean实例，通过反射实例化bean，相当于new X()创建bean的实例</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> createBeanInstance(beanName, mbd, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean = 获取刚刚new出来的bean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ②：是否需要将早期的bean暴露出去，所谓早期的bean相当于这个bean就是通过new的方式创建了这个对象，但是这个对象还没有填充属性，所以是个半成品</span></span><br><span class="line">    <span class="comment">// 是否需要将早期的bean暴露出去，判断规则（bean是单例 &amp;&amp; 是否允许循环依赖 &amp;&amp; bean是否在正在创建的列表中）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">//③：调用addSingletonFactory方法，这个方法内部会将其丢到第3级缓存中，getEarlyBeanReference的源码大家可以看一下，内部会调用一些方法获取早期的bean对象，比如可以在这个里面通过aop生成代理对象</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个变量用来存储最终返回的bean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="comment">//填充属性，这里面会调用setter方法或者通过反射将依赖的bean注入进去</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">//④：初始化bean，内部会调用BeanPostProcessor的一些方法，对bean进行处理，这里可以对bean进行包装，比如生成代理</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//早期的bean是否被暴露出去了</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *⑤：getSingleton(beanName, false)，注意第二个参数是false，这个为false的时候，</span></span><br><span class="line"><span class="comment">         * 只会从第1和第2级中获取bean，此时第1级中肯定是没有的（只有bean创建完毕之后才会放入1级缓存）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ⑥：如果earlySingletonReference不为空，说明第2级缓存有这个bean，二级缓存中有这个bean，说明了什么？</span></span><br><span class="line"><span class="comment">         * 大家回头再去看看上面的分析，看一下什么时候bean会被放入2级缓存?</span></span><br><span class="line"><span class="comment">         * （若 bean存在三级缓存中 &amp;&amp; beanName在当前创建列表的时候，此时其他地方调用了getSingleton(beanName, false)方法，那么bean会从三级缓存移到二级缓存）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//⑥：exposedObject==bean，说明bean创建好了之后，后期没有被修改</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">//earlySingletonReference是从二级缓存中获取的，二级缓存中的bean来源于三级缓存，三级缓存中可能对bean进行了包装，比如生成了代理对象</span></span><br><span class="line">                <span class="comment">//那么这个地方就需要将 earlySingletonReference 作为最终的bean</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">//回头看看上面的代码，刚开始exposedObject=bean，</span></span><br><span class="line">                <span class="comment">// 此时能走到这里，说明exposedObject和bean不一样了，他们不一样了说明了什么？</span></span><br><span class="line">                <span class="comment">// 说明initializeBean内部对bean进行了修改</span></span><br><span class="line">                <span class="comment">// allowRawInjectionDespiteWrapping（默认是false）：是否允许早期暴露出去的bean(earlySingletonReference)和最终的bean不一致</span></span><br><span class="line">                <span class="comment">// hasDependentBean(beanName)：表示有其他bean以利于beanName</span></span><br><span class="line">                <span class="comment">// getDependentBeans(beanName)：获取有哪些bean依赖beanName</span></span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="comment">//判断dependentBean是否已经被标记为创建了，就是判断dependentBean是否已经被创建了</span></span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 能走到这里，说明早期的bean被别人使用了，而后面程序又将exposedObject做了修改</span></span><br><span class="line"><span class="comment">                 * 也就是说早期创建的bean是A，这个A已经被有些地方使用了，但是A通过initializeBean之后可能变成了B，比如B是A的一个代理对象</span></span><br><span class="line"><span class="comment">                 * 这个时候就坑了，别人已经用到的A和最终容器中创建完成的A不是同一个A对象了，那么使用过程中就可能存在问题了</span></span><br><span class="line"><span class="comment">                 * 比如后期对A做了增强（Aop），而早期别人用到的A并没有被增强</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//弹出异常（早期给别人的bean和最终容器创建的bean不一致了，弹出异常）</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,<span class="string">&quot;异常内容见源码。。。。。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="下面来看-A、B-类-setter-循环依赖的创建过程"><a href="#下面来看-A、B-类-setter-循环依赖的创建过程" class="headerlink" title="下面来看 A、B 类 setter 循环依赖的创建过程"></a><strong>下面来看 A、B 类 setter 循环依赖的创建过程</strong></h3><blockquote>
<p>1、getSingleton(“a”, true) 获取 a：会依次从 3 个级别的缓存中找 a，此时 3 个级别的缓存中都没有 a</p>
<p>2、将 a 丢到正在创建的 beanName 列表中（Set<String> singletonsCurrentlyInCreation）</String></p>
<p>3、实例化 a：A a &#x3D; new A();这个时候 a 对象是早期的 a，属于半成品</p>
<p>4、将早期的 a 丢到三级缓存中（Map&lt;String, ObjectFactory&lt;?&gt; &gt; singletonFactories）</p>
<p>5、调用 populateBean 方法，注入依赖的对象，发现 setB 需要注入 b</p>
<p>6、调用 getSingleton(“b”, true) 获取 b：会依次从 3 个级别的缓存中找 a，此时 3 个级别的缓存中都没有 b</p>
<p>7、将 b 丢到正在创建的 beanName 列表中</p>
<p>8、实例化 b：B b &#x3D; new B();这个时候 b 对象是早期的 b，属于半成品</p>
<p>9、将早期的 b 丢到三级缓存中（Map&lt;String, ObjectFactory&lt;?&gt; &gt; singletonFactories）</p>
<p>10、调用 populateBean 方法，注入依赖的对象，发现 setA 需要注入 a</p>
<p>11、调用 getSingleton(“a”, true) 获取 a：此时 a 会从第 3 级缓存中被移到第 2 级缓存，然后将其返回给 b 使用，此时 a 是个半成品（属性还未填充完毕）</p>
<p>12、b 通过 setA 将 11 中获取的 a 注入到 b 中</p>
<p>13、b 被创建完毕，此时 b 会从第 3 级缓存中被移除，然后被丢到 1 级缓存</p>
<p>14、b 返回给 a，然后 b 被通过 A 类中的 setB 注入给 a</p>
<p>15、a 的 populateBean 执行完毕，即：完成属性填充，到此时 a 已经注入到 b 中了</p>
<p>16、调用<code>a= initializeBean(&quot;a&quot;, a, mbd)</code>对 a 进行处理，这个内部可能对 a 进行改变，有可能导致 a 和原始的 a 不是同一个对象了</p>
<p>17、调用<code>getSingleton(&quot;a&quot;, false)</code>获取 a，注意这个时候第二个参数是 false，这个参数为 false 的时候，只会从前 2 级缓存中尝试获取 a，而 a 在步骤 11 中已经被丢到了第 2 级缓存中，所以此时这个可以获取到 a，这个 a 已经被注入给 b 了</p>
<p>18、此时判断注入给 b 的 a 和通过<code>initializeBean</code>方法产生的 a 是否是同一个 a，不是同一个，则弹出异常</p>
</blockquote>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-6158873/qv40e3auxf.png" alt="preload"></p>
<p><strong>从上面的过程中我们可以得到一个非常非常重要的结论</strong></p>
<p><strong>当某个 bean 进入到 2 级缓存的时候，说明这个 bean 的早期对象被其他 bean 注入了，也就是说，这个 bean 还是半成品，还未完全创建好的时候，已经被别人拿去使用了，所以必须要有 3 级缓存，2 级缓存中存放的是早期的被别人使用的对象，如果没有 2 级缓存，是无法判断这个对象在创建的过程中，是否被别人拿去使用了。</strong></p>
<p>三级缓存是为了判断循环依赖的时候，早期暴露出去已经被别人使用的 bean 和最终的 bean 是否是同一个 bean，如果不是同一个则弹出异常，如果早期的对象没有被其他 bean 使用，而后期被修改了，不会产生异常，如果没有三级缓存，是无法判断是否有循环依赖，且早期的 bean 被循环依赖中的 bean 使用了。</p>
<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><p><strong>原理</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p><strong>什么是 IOC</strong> </p>
<ul>
<li>控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理 </li>
<li>使用 IOC 目的：为了耦合度降低 </li>
<li>IOC 底层原理 ：xml 解析、工厂模式、反射</li>
</ul>
<p>IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂 </p>
<p><strong>Spring 提供 IOC 容器实现两种方式：（两个接口）</strong></p>
<ul>
<li>BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 * 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 </li>
<li>ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用 * 加载配置文件时候就会把在配置文件对象进行创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>); <span class="comment">//xml文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);  <span class="comment">//完全注解开发</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>什么是 Bean 管理 ？</strong></p>
<p>Bean 管理指的是两个操作 ：（1）Spring 创建对象 （2）Spirng 注入属性</p>
<p>DI 存在两个主要变体：<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-constructor-injection">基于构造函数的依赖注入</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-setter-injection">基于 Setter 的依赖注入</a>。</p>
<p>在 setter 方法上使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-required-annotation">@Required</a>注解可用于使属性成为必需的依赖项。</p>
<p>Spring 针对 Bean 管理中创建对象提供注解，下面四个注解功能是一样的，都可以用来创建 bean 实例</p>
<ul>
<li>@Component </li>
<li>@Service </li>
<li>@Controller </li>
<li>@Repository</li>
</ul>
<p><strong>什么是自动装配 ？</strong></p>
<p>（1）根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入</p>
<ul>
<li>@Autowired：根据属性类型进行自动装配</li>
<li>@Qualifier：根据名称进行注入 这个@Qualifier 注解的使用，和上面@Autowired 一起使用</li>
<li>@Resource：可以根据类型注入，可以根据名称注入</li>
<li>@Value：注入普通类型属性</li>
</ul>
<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p>注解@Autowired与@Resource的区别：</p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>
<li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>
<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显示指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显示指定名称</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect Oriented Programing）是面向切面编程思想，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。这种思想是对OOP的补充，它可以在OOP的基础上进一步提高编程的效率。简单来说，它可以统一解决一批组件的共性需求（如权限检查、记录日志、事务管理等）。在AOP思想下，我们可以将解决共性需求的代码独立出来，然后通过配置的方式，声明这些代码在什么地方、什么时机调用。当满足调用条件时，AOP会将该业务代码织入到我们指定的位置，从而统一解决了问题，又不需要修改这一批组件的代码。</p>
<p>第一种 有接口情况，使用 JDK 动态代理，创建接口实现类代理对象，增强类的方法</p>
<p>第二种 没有接口情况，使用 CGLIB 动态代理 ， 通过创建子类对象作为代理对象，增强类的方法</p>
<h3 id="动态代理示例："><a href="#动态代理示例：" class="headerlink" title="动态代理示例："></a>动态代理示例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要实现代理类需要解决的问题：</span></span><br><span class="line"><span class="comment">1：如何通过被加载到内存中的被代理类，动态的创建代理类及其对象</span></span><br><span class="line"><span class="comment">2：当通过代理类的对象调用某些方法时，如何动态的调用被代理类的相应的同名方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">LikedFood</span><span class="params">(String Food)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">superMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">LikedFood</span><span class="params">(String Food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span>+Food);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保护地球&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvoketionHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvoketionHandler</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">        obj=o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Object returnValue= method.invoke(obj,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;sssss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object object)</span>&#123;<span class="comment">//obj:被代理类的实例</span></span><br><span class="line">        MyInvoketionHandler handler=<span class="keyword">new</span> <span class="title class_">MyInvoketionHandler</span>(object);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),handler);<span class="comment">//创建代理类的对象。解决问题一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Human superman=<span class="keyword">new</span> <span class="title class_">superMan</span>();</span><br><span class="line">        Human ProxyInstance=(Human) ProxyTest.getProxyInstance(superman);<span class="comment">//动态的创建代理类的对象</span></span><br><span class="line">        <span class="comment">//由代理对象去执行这个方法</span></span><br><span class="line">        ProxyInstance.LikedFood(<span class="string">&quot;四川麻辣烫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3><p>AOP （Aspect Orient Programming）,直译过来就是 面向切面编程。AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。</p>
<p>AOP 领域中的特性术语：</p>
<ul>
<li>通知（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。</li>
<li>连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。</li>
<li>切点（PointCut）: 可以插入增强处理的连接点。</li>
<li>切面（Aspect）: 切面是通知和切点的结合。</li>
<li>引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。</li>
<li>织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。</li>
</ul>
<p>AOP带来的好处：</p>
<ul>
<li>低耦合性</li>
<li>可扩展性</li>
<li>简化代码</li>
</ul>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
<h3 id="请你说说AOP的应用场景"><a href="#请你说说AOP的应用场景" class="headerlink" title="请你说说AOP的应用场景"></a>请你说说AOP的应用场景</h3><p>Spring AOP为IoC的使用提供了更多的便利，一方面，应用可以直接使用AOP的功能，设计应用的横切关注点，把跨越应用程序多个模块的功能抽象出来，并通过简单的AOP的使用，灵活地编制到模块中，比如可以通过AOP实现应用程序中的日志功能。另一方面，在Spring内部，一些支持模块也是通过Spring AOP来实现的，比如事务处理。从这两个角度就已经可以看到Spring AOP的核心地位了。</p>
<h3 id="Spring-AOP不能对哪些类进行增强？"><a href="#Spring-AOP不能对哪些类进行增强？" class="headerlink" title="Spring AOP不能对哪些类进行增强？"></a>Spring AOP不能对哪些类进行增强？</h3><ol>
<li>Spring AOP只能对IoC容器中的Bean进行增强，对于不受容器管理的对象不能增强。</li>
<li>由于CGLib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。</li>
</ol>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>代理模式是一种设计模式，能够使得在不修改源目标的前提下，额外扩展源目标的功能。即通过访问源目标的代理类，再由代理类去访问源目标。这样一来，要扩展功能，就无需修改源目标的代码了。只需要在代理类上增加就可以了。</p>
<p>其实代理模式的核心思想就是这么简单，在java中，代理又分静态代理和动态代理2种，其中动态代理根据不同实现又区分基于接口的的动态代理和基于子类的动态代理。</p>
<p>静态代理这种模式虽然好理解，但是缺点也很明显：</p>
<ul>
<li>会存在大量的冗余的代理类，这里演示了2个接口，如果有10个接口，就必须定义10个代理类。</li>
<li>不易维护，一旦接口更改，代理类和目标类都需要更改。</li>
</ul>
<p><strong>Jdk中的动态代理</strong></p>
<p>JDK中的动态代理是通过反射类Proxy以及InvocationHandler回调接口实现的，但是JDK中所有要进行动态代理的类必须要实现一个接口，也就是说只能对该类所实现接口中定义的方法进行代理，这在实际编程中有一定的局限性，而且使用反射的效率也不高</p>
<p><strong>Cglib实现</strong></p>
<p>使用cglib是实现动态代理，不受代理类必须实现接口的限制，因为cglib底层是用ASM框架，利用ASM框架，对代理对象类生成的class文件加载进来，通过修改其字节码生成子类来处理。比使用Java反射的效率要高，cglib不能对声明final的方法进行代理，因为cglib原理是动态生成被代理类的子类</p>
<p><strong>什么时候用cglib什么时候用jdk动态代理？</strong></p>
<p>1、目标对象生成了接口 默认用JDK动态代理</p>
<p>2、如果目标对象使用了接口，可以强制使用cglib</p>
<p>3、如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代理和cglib之间转换</p>
<p><strong>JDK动态代理和cglib字节码生成的区别？</strong></p>
<ul>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>Cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法的增强，但是因为采用的是继承，所以该类或方法最好不要生成final，对于final类或方法，是无法继承的</li>
</ul>
<p> <strong>Cglib比JDK快？</strong></p>
<ul>
<li>cglib底层是ASM字节码生成框架，但是字节码技术生成代理类，在JDL1.6之前比使用java反射的效率要高</li>
<li>在jdk6之后逐步对JDK动态代理进行了优化，在调用次数比较少时效率高于cglib代理效率</li>
<li>只有在大量调用的时候cglib的效率高，但是在1.8的时候JDK的效率已高于cglib</li>
<li>Cglib不能对声明final的方法进行代理，因为cglib是动态生成代理对象，final关键字修饰的类不可变只能被引用不能被修改</li>
</ul>
<p><strong>Spring如何选择是用JDK还是cglib？</strong></p>
<ul>
<li>当bean实现接口时，会用JDK代理模式</li>
<li>当bean没有实现接口，用cglib实现</li>
<li>可以强制使用cglib（在spring配置中加入&lt;aop:aspectj-autoproxy proxyt-target-class&#x3D;”true”&#x2F;&gt;）</li>
</ul>
<p>还有： 在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理。</p>
<p>动态代理，通俗点说就是：无需声明式的创建java代理类，而是在运行过程中生成”虚拟”的代理类，被ClassLoader加载。从而避免了静态代理那样需要声明大量的代理类。JDK从1.3版本就开始支持动态代理类的创建。主要核心类只有2个：<code>java.lang.reflect.Proxy</code>和<code>java.lang.reflect.InvocationHandler</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*处理代理实例上的方法并返回实例并返回结果,我们一般在此方法中添加一些额外的逻辑</span></span><br><span class="line"><span class="comment">* @param   proxy:   the proxy instance that the method was invoked on</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @param   method the &#123;@code Method&#125; instance corresponding to</span></span><br><span class="line"><span class="comment">* the interface method invoked on the proxy instance.  The declaring</span></span><br><span class="line"><span class="comment">* class of the &#123;@code Method&#125; object will be the interface that</span></span><br><span class="line"><span class="comment">* the method was declared in, which may be a superinterface of the</span></span><br><span class="line"><span class="comment">* proxy interface that the proxy class inherits the method through.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @param   args an array of objects containing the values of the</span></span><br><span class="line"><span class="comment">* arguments passed in the method invocation on the proxy instance,</span></span><br><span class="line"><span class="comment">* or &#123;@code null&#125; if interface method takes no arguments.</span></span><br><span class="line"><span class="comment">* Arguments of primitive types are wrapped in instances of the</span></span><br><span class="line"><span class="comment">* appropriate primitive wrapper class, such as</span></span><br><span class="line"><span class="comment">* &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*   @param  loader:   the class loader to define the proxy class</span></span><br><span class="line"><span class="comment">*    @param  interfaces:  the list of interfaces for the proxy class  to implement</span></span><br><span class="line"><span class="comment">*    @param  h :  the invocation handler to dispatch method invocations to</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span> </span><br><span class="line">    </span><br><span class="line"><span class="comment">//一般步骤为先new一个被代理对象，再生成调用处理器，最后得到代理对象的实例</span></span><br><span class="line"><span class="comment">//invoke()这个方法的第一个参数proxy可以用于返回，实现连续调用的效果	</span></span><br></pre></td></tr></table></figure>

<p>JDK的动态代理使用的最多的一种代理方式。也叫做接口代理。</p>
<p>JDK动态代理说白了只是根据接口”凭空“来生成类，至于具体的执行，都被代理到了<code>InvocationHandler</code> 的实现类里。上述例子我是需要继续执行原有bean的逻辑，才将原有的bean构造进来。只要你需要，你可以构造进任何对象到这个代理实现类。也就是说，你可以传入多个对象，或者说你什么类都不代理。只是为某一个接口”凭空“的生成多个代理实例，这多个代理实例最终都会进入<code>InvocationHandler</code>的实现类来执行某一个段共同的代码。</p>
<p>基于接口的代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JDKProxy</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">//处理代理实例上的方法并返回实例并返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke执行&quot;</span>);</span><br><span class="line">        String s=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JDKProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDKProxy</span>();</span><br><span class="line">        Person personProxy=(Person)Proxy.newProxyInstance(Person.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Person.class&#125;, proxy);</span><br><span class="line">        personProxy.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="CGLIB与JDK动态代理特点"><a href="#CGLIB与JDK动态代理特点" class="headerlink" title="CGLIB与JDK动态代理特点"></a>CGLIB与JDK动态代理特点</h3><p>在性能方面，CGLib创建的代理对象比JDK动态代理创建的代理对象高很多。但是，CGLib在创建代理对象时所花费的时间比JDK动态代理多很多。所以，对于单例的对象因为无需频繁创建代理对象，采用CGLib动态代理比较合适。反之，对于多例的对象因为需要频繁的创建代理对象，则JDK动态代理更合适。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败</p>
<h3 id="事务四个特性（ACID）"><a href="#事务四个特性（ACID）" class="headerlink" title="事务四个特性（ACID）"></a>事务四个特性（ACID）</h3><ul>
<li>（1）原子性 </li>
<li>（2）一致性 </li>
<li>（3）隔离性 </li>
<li>（4）持久性</li>
</ul>
<h3 id="在spring中进行事务管理操作"><a href="#在spring中进行事务管理操作" class="headerlink" title="在spring中进行事务管理操作"></a>在spring中进行事务管理操作</h3><p>有两种方式：编程式事务管理 和 声明式事务管理（使用）</p>
<p>其中的声明式事务管理 ：</p>
<ul>
<li>基于注解方式（使用） </li>
<li>基于 xml 配置文件方式</li>
</ul>
<h3 id="事务操作（声明式事务管理参数配置）"><a href="#事务操作（声明式事务管理参数配置）" class="headerlink" title="事务操作（声明式事务管理参数配置）"></a>事务操作（声明式事务管理参数配置）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 在 spring 配置文件，开启事务注解</span></span><br><span class="line"><span class="comment"> 在 spring 配置文件引入名称空间 tx </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transactionmanager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>1、在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数</p>
<p>2、propagation：事务传播行为</p>
<img src="https://s2.loli.net/2022/04/15/Aiy4VDax3ctBKej.png" alt="image-20220415170446377" style="zoom: 80%;">

<p>3、ioslation：事务隔离级别</p>
<p>4、timeout：超时时间</p>
<p>5、readOnly：是否只读</p>
<p>6、rollbackFor：回滚</p>
<p>7、noRollbackFor：不回滚</p>
<h3 id="脏读，不可重复读，幻读"><a href="#脏读，不可重复读，幻读" class="headerlink" title="脏读，不可重复读，幻读"></a>脏读，不可重复读，幻读</h3><ul>
<li>脏读：一个未提交事务读取到另一个未提交事务的数据</li>
<li>不可重复读：一个未提交事务读取到另一提交事务修改数据</li>
<li>虚读：一个未提交事务读取到另一提交事务添加数据</li>
</ul>
<h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><p> 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p>正确的事务传播行为可能的值如下:</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 </p>
<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p>
<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<h3 id="Spring-事务管理接口介绍"><a href="#Spring-事务管理接口介绍" class="headerlink" title="Spring 事务管理接口介绍"></a>Spring 事务管理接口介绍</h3><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p>
<ul>
<li>**<code>PlatformTransactionManager</code>**： （平台）事务管理器，Spring 事务策略的核心。</li>
<li>**<code>TransactionDefinition</code>**： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li>
<li>**<code>TransactionStatus</code>**： 事务运行状态。</li>
</ul>
<p>我们可以把 <strong><code>PlatformTransactionManager</code></strong> 接口可以被看作是事务上层的管理者，而 <strong><code>TransactionDefinition</code></strong> 和 <strong><code>TransactionStatus</code></strong> 这两个接口可以看作是事务的描述。</p>
<p><strong><code>PlatformTransactionManager</code></strong> 会根据 <strong><code>TransactionDefinition</code></strong> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <strong><code>TransactionStatus</code></strong> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p>
<h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><p><strong>Spring 并不直接管理事务，而是提供了多种事务管理器</strong> 。Spring 事务管理器的接口是： <strong><code>PlatformTransactionManager</code></strong> 。</p>
<p>通过这个接口，Spring 为各个平台如 JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>)、JPA(<code>JpaTransactionManager</code>)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<p><code>PlatformTransactionManager</code>接口中定义了三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h4><p>接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRED</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_SUPPORTS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_MANDATORY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRES_NEW</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NEVER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NESTED</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_UNCOMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_COMMITTED</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_REPEATABLE_READ</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_SERIALIZABLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TIMEOUT_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//返回事务的隔离级别，默认值是 DEFAULT</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TransactionStatus-事务状态"><a href="#TransactionStatus-事务状态" class="headerlink" title="TransactionStatus:事务状态"></a>TransactionStatus:事务状态</h4><p><code>TransactionStatus</code>接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</p>
<p><code>PlatformTransactionManager.getTransaction(…)</code>方法返回一个 <code>TransactionStatus</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><code>@Transactional</code> 的常用配置参数总结（只列出了 5 个我平时比较常用的）：</strong></p>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">propagation</td>
<td align="left">事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过</td>
</tr>
<tr>
<td align="left">isolation</td>
<td align="left">事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>
</tr>
<tr>
<td align="left">readOnly</td>
<td align="left">指定事务是否为只读事务，默认值为 false。</td>
</tr>
<tr>
<td align="left">rollbackFor</td>
<td align="left">用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型</td>
</tr>
</tbody></table>
<h3 id="spring项目中使用-Transactional注解，事务不生效"><a href="#spring项目中使用-Transactional注解，事务不生效" class="headerlink" title="spring项目中使用@Transactional注解，事务不生效"></a>spring项目中使用@Transactional注解，事务不生效</h3><ol>
<li>数据库引擎不支持事务</li>
<li>没有被 Spring 管理</li>
<li>方法不是 public 的</li>
<li>在没有事务的方法中去调用拥有事务的方法</li>
<li>数据源没有配置事务管理器</li>
<li>默认回滚的是：RuntimeException，如果你想触发其他异常的回滚，需要在注解上配置</li>
</ol>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h3 id="DispatcherServlet处理流程？"><a href="#DispatcherServlet处理流程？" class="headerlink" title="DispatcherServlet处理流程？"></a><em>DispatcherServlet处理流程？</em></h3><p><img src="https://s2.loli.net/2022/07/19/A8qcZ2b3T6VrDet.png" alt="img"></p>
<p>在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它。DispatcherServlet 是前端控制器，配置在web.xml文件中，Servlet依自已定义的具体规则拦截匹配的请求，分发到目标Controller来处理。 初始化 <code>DispatcherServlet</code>时，该框架在web应用程序WEB-INF目录中寻找一个名为[servlet-名称]-servlet.xml的文件，并在那里定义相关的Beans，重写在全局中定义的任何Beans。</p>
<p><strong>在看DispatcherServlet 类之前，我们先来看一下请求处理的大致流程：</strong></p>
<ol>
<li>Tomcat 启动，对 DispatcherServlet 进行实例化，然后调用它的 init() 方法进行初始化，在这个初始化过程中完成了：对 web.xml 中初始化参数的加载；建立 WebApplicationContext(SpringMVC的IOC容器)；进行组件的初始化；</li>
<li>客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理；</li>
<li>DispatcherServlet 从容器中取出所有 HandlerMapping 实例（每个实例对应一个 HandlerMapping接口的实现类）并遍历，每个 HandlerMapping 会根据请求信息，通过自己实现类中的方式去找到处理该请求的 Handler(执行程序，如Controller中的方法)，并且将这个 Handler 与一堆 HandlerInterceptor (拦截器)封装成一个 HandlerExecutionChain 对象，一旦有一个 HandlerMapping 可以找到 Handler则退出循环；</li>
<li>DispatcherServlet 取出 HandlerAdapter 组件。根据已经找到的 Handler，再从所有HandlerAdapter 中找到可以处理该 Handler 的 HandlerAdapter 对象；</li>
<li>执行 HandlerExecutionChain 中所有拦截器的 preHandler() 方法，然后再利用HandlerAdapter 执行 Handler ，执行完成得到 ModelAndView，再依次调用拦截器的postHandler() 方法；</li>
<li>利用 ViewResolver 将 ModelAndView 或是 Exception（可解析成 ModelAndView）解析成View，然后 View 会调用 render() 方法再根据 ModelAndView 中的数据渲染出页面；</li>
<li>最后再依次调用拦截器的 afterCompletion() 方法，这一次请求就结束了。</li>
</ol>
<h3 id="什么是token"><a href="#什么是token" class="headerlink" title="什么是token"></a>什么是token</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> JWT token的组成</span><br><span class="line">Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（[(RFC 7519](https://link.jianshu.com?t=https://tools.ietf.org/html/rfc7519)).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</span><br><span class="line"> </span><br><span class="line">头部（Header），格式如下： </span><br><span class="line">&#123; </span><br><span class="line">“typ”: “JWT”, </span><br><span class="line">“alg”: “HS256” </span><br><span class="line">&#125; </span><br><span class="line">由上可知，该token使用HS256加密算法，将头部使用Base64编码可得到如下个格式的字符串：eyJhbGciOiJIUzI1NiJ91</span><br><span class="line"> </span><br><span class="line">有效载荷（Playload）： </span><br><span class="line">&#123;  </span><br><span class="line">  “iss”: “Online JWT Builder”,  </span><br><span class="line">  “iat”: 1416797419,  </span><br><span class="line">  “exp”: 1448333419,  </span><br><span class="line">      ……. </span><br><span class="line">  “userid”:10001 </span><br><span class="line">&#125; </span><br><span class="line">有效载荷中存放了token的签发者（iss）、签发时间（iat）、过期时间（exp）等以及一些我们需要写进token中的信息。有效载荷也使用Base64编码得到如下格式的字符串：eyJ1c2VyaWQiOjB91</span><br><span class="line"> </span><br><span class="line">签名（Signature）： </span><br><span class="line">将Header和Playload拼接生成一个字符串str=“eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyaWQiOjB9”，使用HS256算法和我们提供的密钥（secret,服务器自己提供的一个字符串）对str进行加密生成最终的JWT，即我们需要的令牌（token），形如：str.”签名字符串”。</span><br><span class="line"> </span><br><span class="line">token在服务与客户端的交互流程</span><br><span class="line"> </span><br><span class="line">1：客户端通过用户名和密码登录 </span><br><span class="line">2：服务器验证用户名和密码，若通过，生成token返回给客户端。 </span><br><span class="line">3：客户端收到token后以后每次请求的时候都带上这个token，相当于一个令牌，表示我有权限访问了 </span><br><span class="line">4：服务器接收（通常在拦截器中实现）到该token，然后验证该token的合法性（为什么能验证下面说）。若该token合法，则通过请求，若token不合法或者过期，返回请求失败。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">服务如何判断这个token是否合法？ </span><br><span class="line">由上面token的生成可知，token中的签名是由Header和有效载荷通过Base64编码生成再通过加密算法HS256和密钥最终生成签名，这个签名位于JWT的尾部，在服务器端同样对返回过来的JWT的前部分再进行一次签名生成，然后比较这次生成的签名与请求的JWT中的签名是否一致，若一致说明token合法。由于生成签名的密钥是服务器才知道的，所以别人难以伪造。</span><br><span class="line"> </span><br><span class="line">token中能放敏感信息吗？ </span><br><span class="line">不能，因为有效载荷是经过Base64编码生成的，并不是加密。所以不能存放敏感信息。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Token的优点</span><br><span class="line"> </span><br><span class="line">（1）相比于session，它无需保存在服务器，不占用服务器内存开销。 </span><br><span class="line">（2）无状态、可拓展性强：比如有3台机器（A、B、C）组成服务器集群，若session存在机器A上，session只能保存在其中一台服务器，此时你便不能访问机器B、C，因为B、C上没有存放该Session，而使用token就能够验证用户请求合法性，并且我再加几台机器也没事，所以可拓展性好就是这个意思。 </span><br><span class="line">（3）这样做可就支持了跨域访问。</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>token生成于服务端，存储在客户端，服务端不用存储，用户后面每次登录都携带首次都登录生成的token字符串用于验证，能做到这点，关键就是token使用的某种算法根据用户签名和其它一些信息生成的令牌信息是一致的，可以验证通过，对于用户量庞大的系统，或者分布式，避免了大量session对象的存储带来的内存消耗，和各服务器之间session的复制或者专门用于存储session的服务器宕机带来的问题</p>
<p>所谓的Token，其实就是服务端生成的一串加密字符串、以作客户端进行请求的一个“令牌”。当用户第一次使用账号密码成功进行登录后，服务器便生成一个Token及Token失效时间并将此返回给客户端，若成功登陆，以后客户端只需在有效时间内带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>
<p>为什么要使用Token？这个问题其实很好回答——因为它能解决问题！当下用户对产品的使用体验要求在逐渐提高，从产品体验方面来讲，Token带来的体验更容易能让用户接受。</p>
<p>那么Token都可以解决哪些问题呢？</p>
<ul>
<li>Token具有随机性、不可预测性、时效性、无状态、跨域等特点</li>
<li>Token完全由应用管理，所以它可以避开同源策略</li>
<li>Token可以避免CSRF攻击</li>
<li>Token可以是无状态的，可以在多个服务间共享</li>
<li>Token是在服务端产生的。如果前端使用用户名&#x2F;密码向服务端请求认证，服务端认证成功，那么在服务端会返回Token给前端。前端可以在每次请求的时候带上Token证明自己的合法地位。如果这个Token在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌</li>
</ul>
<p><strong>什么是同源策略？</strong></p>
<p>所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。同源策略&#x2F;SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略。如果缺少了同源策略，浏览器很容易受到 XSS、 CSFR 等攻击。同源策略是为了安全，确保一个应用中的资源只能被本应用的资源访问。否则，岂不是谁都能访问。</p>
<p><strong>Token的生命周期</strong></p>
<p><strong>1）用户未登录</strong></p>
<p>用户执行注册&#x2F;登录→</p>
<p>一旦基础数据校验成功，后端生成Token，并且Token包含此次注册&#x2F;登录用户的用户名并通过JsonResponse返回给前端→</p>
<p>前端拿到返回的Token后，存入浏览器本地存储</p>
<p><strong>2）用户每次访问博客页面</strong></p>
<p>从本地存储中拿出Token→</p>
<p>JS将Token　放入request的Authorization头，发送http请求向后端索要数据→</p>
<p>服务器接到前端请求（当前URL加了loging_check,并且请求方法在methods参数中）,进行校验→从requestAuthorization头拿出Token→校验→校验不通过，返回前端异常代码&#x2F;校验通过，正常执行对应的视图函数→前端一旦接到关于Token的异常码，则删除本地存储中的Token,且将用户转至登录界面。</p>
<p><strong>如何设置Token的有效期？</strong></p>
<p>其实Token作为一个概念模型，开发者完全可以针对自己开发的应用自定义Token，只要能做到不让不法分子钻系统漏洞即可。</p>
<p>那么为Token设置有效期还有必要吗？</p>
<p>对于这个问题，大家不妨先看两个例子：</p>
<p>Token的有效期多长合适呢？</p>
<p>一般来说，基于系统安全的需要当然需要尽可能的短，但也不能短得离谱：如果在用户正常操作的过程中，Token过期失效要求重新登录，用户体验岂不是很糟糕？</p>
<p>为了解决在操作过程不让用户感到Token失效的问题，有一种方案是在服务器端保存Token状态，用户每次操作都会自动刷新（推迟）Token的过期时间。</p>
<p>如此操作会存在一个问题，即在前后端分离、单页App等情况下，每秒可能发起多次请求，如果每次都去刷新过期时间会产生非常大的代价，同样地，如果Token的过期时间被持久化到数据库或文件，代价就更大了。所以通常为了提升效率、减少消耗，会把Token的过期时保存在缓存或者内存中。</p>
<p>另一种方案是使用RefreshToken，它可以避免频繁的读写操作。这种方案中，服务端无需刷新Token的过期时间，一旦Token过期，就反馈给前端，前端使用RefreshToken申请一个全新Token继续使用。</p>
<p>这种方案中，服务端只需要在客户端请求更新Token的时候对RefreshToken的有效性进行一次检查，大大减少了更新有效期的操作，也就避免了频繁读写。当然RefreshToken也是有有效期的，但是这个有效期就可以长一点了。</p>
<h3 id="防范Cookie劫持"><a href="#防范Cookie劫持" class="headerlink" title="防范Cookie劫持"></a>防范Cookie劫持</h3><p>Cookie防劫持预防<br>基于XSS攻击, 窃取Cookie信息, 并冒充他人身份。</p>
<p>1） 方法一：给Cookie添加HttpOnly属性, 这种属性设置后, 只能在http请求中传递, 在脚本中, document.cookie无法获取到该Cookie值. 对XSS的攻击, 有一定的防御值. 但是对网络拦截, 还是泄露了.</p>
<p>2）方法二：在cookie中添加校验信息, 这个校验信息和当前用户外置环境有些关系,比如ip,user agent等有关. 这样当cookie被人劫持了, 并冒用, 但是在服务器端校验的时候, 发现校验值发生了变化, 因此要求重新登录, 这样也是种很好的思路, 去规避cookie劫持.</p>
<p>3）方法三：cookie中session id的定时更换, 让session id按一定频率变换, 同时对用户而言, 该操作是透明的, 这样保证了服务体验的一致性.</p>
<p>4）方法四：使用HTTPS来进行传输</p>
<h3 id="cookie和session的区别是什么？"><a href="#cookie和session的区别是什么？" class="headerlink" title="cookie和session的区别是什么？"></a>cookie和session的区别是什么？</h3><p><strong>参考答案</strong></p>
<ol>
<li>存储位置不同：cookie存放于客户端；session存放于服务端。</li>
<li>存储容量不同：单个cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个cookie；而session并没有上限。</li>
<li>存储方式不同：cookie只能保存ASCII字符串，并需要通过编码当时存储为Unicode字符或者二进制数据；session中能够存储任何类型的数据，例如字符串、整数、集合等。</li>
<li>隐私策略不同：cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的；session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</li>
<li>生命周期不同：可以通过设置cookie的属性，达到cookie长期有效的效果；session依赖于名为JSESSIONID的cookie，而该cookie的默认过期时间为-1，只需关闭窗口该session就会失效，因此session不能长期有效。</li>
<li>服务器压力不同：cookie保存在客户端，不占用服务器资源；session保管在服务器上，每个用户都会产生一个session，如果并发量大的话，则会消耗大量的服务器内存。</li>
<li>浏览器支持不同：cookie是需要浏览器支持的，如果客户端禁用了cookie，则会话跟踪就会失效；运用session就需要使用URL重写的方式，所有用到session的URL都要进行重写，否则session会话跟踪也会失效。</li>
<li>跨域支持不同：cookie支持跨域访问，session不支持跨域访问。</li>
</ol>
<h3 id="cookie和session各自适合的场景是什么？"><a href="#cookie和session各自适合的场景是什么？" class="headerlink" title="cookie和session各自适合的场景是什么？"></a>cookie和session各自适合的场景是什么？</h3><p>对于敏感数据，应存放在session里，因为cookie不安全。</p>
<p>对于普通数据，优先考虑存放在cookie里，这样会减少对服务器资源的占用。</p>
<h3 id="请介绍session的工作原理"><a href="#请介绍session的工作原理" class="headerlink" title="请介绍session的工作原理"></a>请介绍session的工作原理</h3><p>session依赖于cookie。</p>
<p>当客户端首次访问服务器时，服务器会为其创建一个session对象，该对象具有一个唯一标识SESSIONID。并且在响应阶段，服务器会创建一个cookie，并将SESSIONID存入其中。</p>
<p>客户端通过响应的cookie而持有SESSIONID，所以当它再次访问服务器时，会通过cookie携带这个SESSIONID。服务器获取到SESSIONID后，就可以找到与之对应的session对象，进而从这个session中获取该客户端的状态。</p>
<h3 id="get请求与post请求有什么区别？"><a href="#get请求与post请求有什么区别？" class="headerlink" title="get请求与post请求有什么区别？"></a>get请求与post请求有什么区别？</h3><ul>
<li>GET参数通过URL传递，POST放在Request body中。</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
</ul>
<ul>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
</ul>
<h3 id="get请求的参数能放到body里面吗？"><a href="#get请求的参数能放到body里面吗？" class="headerlink" title="get请求的参数能放到body里面吗？"></a>get请求的参数能放到body里面吗？</h3><p>GET请求是可以将参数放到BODY里面的，官方并没有明确禁止，但给出的建议是这样不符合规范，无法保证所有的实现都支持。这就意味着，如果你试图这样做，可能出现各种未知的问题，所以应该当避免。</p>
<h3 id="如何自定义拦截器"><a href="#如何自定义拦截器" class="headerlink" title="如何自定义拦截器"></a>如何自定义拦截器</h3><p>一个拦截器，只有<code>preHandle</code>方法返回<code>true</code>，<code>postHandle</code>、<code>afterCompletion</code>才有可能被执行；如果<code>preHandle</code>方法返回<code>false</code>，则该拦截器的<code>postHandle</code>、<code>afterCompletion</code>必然不会被执行。拦截器不是Filter，却实现了Filter的功能，其原理在于：</p>
<ul>
<li>所有的拦截器<code>(Interceptor)</code>和处理器<code>(Handler)</code>都注册在<code>HandlerMapping</code>中。</li>
<li><code>Spring MVC</code>中所有的请求都是由<code>DispatcherServlet</code>分发的。</li>
<li>当请求进入<code>DispatcherServlet.doDispatch()</code>时候，首先会得到处理该请求的<code>Handler</code>（即<code>Controller</code>中对应的方法）以及所有拦截该请求的拦截器。拦截器就是在这里被调用开始工作的。</li>
</ul>
<p>自定义一个拦截器非常简单，只需要实现<code>HandlerInterceptor</code>这个接口即可，该接口有三个可以实现的方法，如下：</p>
<ul>
<li><code>preHandle()</code>方法：改方法会在控制方法前执行，器返回值表示是否知道如何写一个接口。中断后续操作。当其返回值为true时，表示继续向下执行；当其返回值为<code>false</code>时，会中断后续的所有操作(包括调用下一个拦截器和控制器类中的方法执行等 )</li>
<li>postHandle()方法： 该方法会在控制器方法调用之后，且解析视图之前执行。可以通过此方法对请求域中的模型和视图作出进一步的修改。</li>
<li>afterCompletion()方法：该方法会在整个请求完成，即视图渲染结束之后执行。可以通过此方法实现一些资源清理、记录日志信息等工作。</li>
</ul>
<h1 id="MyBaits"><a href="#MyBaits" class="headerlink" title="MyBaits"></a>MyBaits</h1><h3 id="MyBatis是什么？"><a href="#MyBatis是什么？" class="headerlink" title="MyBatis是什么？"></a>MyBatis是什么？</h3><p><img src="https://ask.qcloudimg.com/http-save/7948575/jl6ey2sfaq.png?imageView2/2/w/1620" alt="img"></p>
<h3 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM?"></a>什么是ORM?</h3><p>对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。ORM框架是连接数据库的桥梁，只要提供了持久化类与表的映射关系，ORM框架在运行时就能参照映射文件的信息，把对象持久化到数据库中。</p>
<p>ORM框架：为了解决面型对象与关系数据库存在的互不匹配的现象的框架。</p>
<p>当前ORM框架主要有五种：<br>（1）Hibernate 全自动 需要写hql语句<br>（2）iBATIS 半自动 自己写sql语句,可操作性强,小巧<br>（3）mybatis<br>（4）eclipseLink<br>（5）JFinal</p>
<h3 id="ORM的优缺点："><a href="#ORM的优缺点：" class="headerlink" title="ORM的优缺点："></a>ORM的优缺点：</h3><p>优点：<br>1）提高开发效率，降低开发成本<br>2）使开发更加对象化<br>3）可移植<br>4）可以很方便地引入数据缓存之类的附加功能<br>缺点：<br>1）自动化进行关系数据库的映射需要消耗系统性能。其实这里的性能消耗还好啦，一般来说都可以忽略之。<br>2）在处理多表联查、where条件复杂之类的查询时，ORM的语法会变得复杂。</p>
<h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>JPA （Java Persistence API）Java<strong>持久化</strong>API。是一套Sun公司Java官方制定的<strong>ORM</strong> 方案,是规范，是标准 ，sun公司自己并没有实现</p>
<p>市场上的主流的JPA框架（实现者）有： </p>
<p>Hibernate （JBoos）、EclipseTop（Eclipse社区）、OpenJPA （Apache基金会）。 </p>
<p>JPA是ORM的一套标准，既然JPA为ORM而生，那么JPA的作用就是实现使用对象操作数据库，不用写SQL!!!. </p>
<h3 id="MyBatis和JPA的区别"><a href="#MyBatis和JPA的区别" class="headerlink" title="MyBatis和JPA的区别"></a>MyBatis和JPA的区别</h3><p><strong>ORM映射不同：</strong></p>
<p>MyBatis是半自动的ORM框架，提供数据库与结果集的映射；</p>
<p>JPA（默认采用Hibernate实现）是全自动的ORM框架，提供对象与数据库的映射。</p>
<p><strong>可移植性不同：</strong></p>
<p>JPA通过它强大的映射结构和HQL语言，大大降低了对象与数据库的耦合性；</p>
<p>MyBatis由于需要写SQL，因此与数据库的耦合性直接取决于SQL的写法，如果SQL不具备通用性而用了很多数据库的特性SQL的话，移植性就会降低很多，移植时成本很高。</p>
<p><strong>日志系统的完整性不同：</strong></p>
<p>JPA日志系统非常健全、涉及广泛，包括：SQL记录、关系异常、优化警告、缓存提示、脏数据警告等；</p>
<p>MyBatis除了基本的记录功能外，日志功能薄弱很多。</p>
<p><strong>SQL优化上的区别：</strong></p>
<p>由于Mybatis的SQL都是写在XML里，因此优化SQL比Hibernate方便很多。</p>
<p>而Hibernate的SQL很多都是自动生成的，无法直接维护SQL。虽有HQL，但功能还是不及SQL强大，见到报表等复杂需求时HQL就无能为力，也就是说HQL是有局限的Hhibernate虽然也支持原生SQL，但开发模式上却与ORM不同，需要转换思维，因此使用上不是非常方便。总之写SQL的灵活度上Hibernate不及Mybatis。</p>
<h3 id="sqlsession了解吗？"><a href="#sqlsession了解吗？" class="headerlink" title="sqlsession了解吗？"></a>sqlsession了解吗？</h3><p>[Mybatis的SqlSession运行原理 - JJian - 博客园 (cnblogs.com)](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jian0110/p/9452592.html#:~:text=SqlSession%E6%98%AFMybatis%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B9%8B%E4%B8%80%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A4%E4%B8%BAMybatis%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E9%85%8D%E7%BD%AE%E7%9B%AE%E7%9A%84%E6%98%AF%E7%94%9F%E6%88%90%E7%B1%BB%E4%BC%BC">https://www.cnblogs.com/jian0110/p/9452592.html#:~:text=SqlSession是Mybatis最重要的构建之一，可以简单的认为Mybatis一系列的配置目的是生成类似</a> JDBC生成的Connection对象的SqlSession对象，这样才能与数据库开启“沟通”，通过SqlSession可以实现增删改查（当然现在更加推荐是使用Mapper接口形式），那么它是如何执行实现的，这就是本篇博文所介绍的东西，其中会涉及到简单的源码讲解。.,了解SqlSession的运作原理是学习Mybatis插件的必经之路，因为Mybatis的插件会在SqlSession运行过程中“插入”运行，如果没有很好理解的话，Mybatis插件可能会覆盖相应的源码造成严重的问题。. 鉴于此，本篇博文尽量详细介绍SqlSession运作原理！.)</p>
<p>　SqlSession是Mybatis最重要的构建之一，可以简单的认为Mybatis一系列的配置目的是生成类似 JDBC生成的Connection对象的SqlSession对象，这样才能与数据库开启“沟通”，通过SqlSession可以实现增删改查</p>
<h3 id="mybatis-一级缓存和二级缓存？"><a href="#mybatis-一级缓存和二级缓存？" class="headerlink" title="mybatis 一级缓存和二级缓存？"></a>mybatis 一级缓存和二级缓存？</h3><p><img src="https://img-blog.csdnimg.cn/20210415230328382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NkZmdlZ2VmZGc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>一级缓存：Mybatis对缓存提供支持，但是在没有配置的<strong>默认</strong>情况下，它<strong>只开启一级缓存</strong>，一级缓存只是相对于同一个SqlSession而言。所以<strong>在参数和SQL完全一样的情况下</strong>，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且<strong>缓存没有超时的情况下</strong>，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。<br><strong>每一次会话都对应自己的一级缓存</strong>，作用范围比较小，<strong>一旦会话关闭就查询不到了</strong>。</p>
<p>二级缓存：二级缓存存在于SqlSessionFactory 的生命周期中，即它是SqlSessionFactory级别的缓存。它可以提高对数据库查询的效率，以提高应用的性能。他是<strong>基于namespace名称空间级别的缓存：一个namespace对应一个二级缓存</strong>。<strong>即一个mapper.xml对应一个缓存：</strong></p>
<p><strong>二级缓存具有如下效果：</strong></p>
<ul>
<li>映射语句文件中的所有SELECT 语句将会被缓存。</li>
<li>映射语句文件中的所有时INSERT 、UPDATE 、DELETE 语句会刷新缓存。</li>
<li>缓存会使用Least Recently Used ( LRU ，最近最少使用的）算法来收回。</li>
<li>根据时间表（如no Flush Interval ，没有刷新间隔），缓存不会以任何时间顺序来刷新。</li>
<li>缓存会存储集合或对象（无论查询方法返回什么类型的值）的1024 个引用。</li>
<li>缓存会被视为read&#x2F;write（可读／可写）的，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
<p><strong>Mybatis的一级缓存和二级缓存执行顺序</strong></p>
<p>1、<strong>先判断二级缓存</strong>是否开启，如果没开启，<strong>再判断一级缓存</strong>是否开启，如果没开启，直接查数据库</p>
<p>2、如果<strong>一级缓存关闭</strong>，即使<strong>二级缓存开启也没有数据</strong>，因为二级缓存的数据从一级缓存获取</p>
<p>3、一般不会关闭一级缓存</p>
<p>4、二级缓存默认不开启</p>
<p>5、如果<strong>二级缓存关闭，直接判断一级缓存是否有数据，如果没有就查数据库</strong></p>
<p>6、<strong>如果二级缓存开启，先判断二级缓存有没有数据</strong>，如果有就<strong>直接返回</strong>；如果没有，就<strong>查询一级缓存</strong>，如果有就<strong>返回</strong>，没有就<strong>查询数据库</strong>；</p>
<p>综上：先查二级缓存，再查一级缓存，再查数据库；即使在一个sqlSession中，也会先查二级缓存；一个namespace中的查询更是如此；缓存执行顺序是：<strong>二级缓存–&gt;一级缓存–&gt;数据库</strong></p>
<h3 id="Mybatis的工作原理"><a href="#Mybatis的工作原理" class="headerlink" title="Mybatis的工作原理"></a>Mybatis的工作原理</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97879019">Mybatis运行原理（我保证全宇宙最详细） - 知乎 (zhihu.com)</a></p>
<p>（1）读取MyBatis的配置文件。mybatis-config.xml为MyBatis的全局配置文件，用于配置数据库连接信息。</p>
<p>（2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p>
<p>（3）构造会话工厂。通过MyBatis的环境配置信息构建会话工厂SqlSessionFactory。</p>
<p>（4）创建会话对象。由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。</p>
<p>（5）Executor执行器。MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。</p>
<p>（6）MappedStatement对象。在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。</p>
<p>（7）输入参数映射。输入参数类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。</p>
<p>（8）输出结果映射。输出结果类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190704/5-1ZF4130T31N.png" alt="MyBatis框架的执行流程图"></p>
<p><strong>我们把Mybatis的功能架构分为三层：</strong> </p>
<ul>
<li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。 </li>
<li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。 </li>
<li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/7948575/ncsz0g9kcy.png" alt="preload"></p>
<h3 id="Mybatis中-与-的区别"><a href="#Mybatis中-与-的区别" class="headerlink" title="Mybatis中#{}与${}的区别"></a>Mybatis中#{}与${}的区别</h3><p>#{} 是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#&#123;&#125;</code>替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号</p>
<p>${} 是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，在SQL替换中将传入的数据直接显示生成在sql中</p>
<p>#方式能够很大程度防止sql注入,$方式无法防止Sql注入。</p>
<p><strong>只能使用${}的场景</strong></p>
<p>由于#{}会给参数内容自动加上引号，会在有些需要表示字段名、表名的场景下，SQL将无法正常执行。现举一例说明：</p>
<p>期望查询结果按sex字段升序排列，参数String orderCol &#x3D; “sex”,mapper映射文件使用  #{}：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAddByName3&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM USER WHERE username LIKE &#x27;%Am%&#x27; ORDER BY #&#123;value&#125; ASC</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>则SQL解析及执行结果如下所示，很明显 ORDER 子句的字段名错误的被加上了引号，致使查询结果没有按期排序输出</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;%Am%&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">&#x27;sex&#x27;</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="在mapper中如何传递多个参数"><a href="#在mapper中如何传递多个参数" class="headerlink" title="在mapper中如何传递多个参数"></a>在mapper中如何传递多个参数</h3><p><img src="https://ask.qcloudimg.com/http-save/7948575/sjawkm0zv5.png" alt="preload"></p>
<p>​            <strong>方法3：Map传参法</strong> </p>
<p><img src="https://ask.qcloudimg.com/http-save/7948575/84rjgm4ekt.png" alt="preload"></p>
<h3 id="不同的Xml映射文件，id是否可以重复？"><a href="#不同的Xml映射文件，id是否可以重复？" class="headerlink" title="不同的Xml映射文件，id是否可以重复？"></a>不同的Xml映射文件，id是否可以重复？</h3><ul>
<li>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。 </li>
<li>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</li>
</ul>
<h3 id="MyBatis编程步骤"><a href="#MyBatis编程步骤" class="headerlink" title="MyBatis编程步骤"></a>MyBatis编程步骤</h3><ul>
<li>1、 创建SqlSessionFactory </li>
<li>2、 通过SqlSessionFactory创建SqlSession </li>
<li>3、 通过sqlsession执行数据库操作 </li>
<li>4、 调用session.commit()提交事务 </li>
<li>5、 调用session.close()关闭会话</li>
</ul>
<h3 id="为什么需要预编译"><a href="#为什么需要预编译" class="headerlink" title="为什么需要预编译"></a>为什么需要预编译</h3><p><img src="https://ask.qcloudimg.com/http-save/7948575/tfkcxrwxlu.png" alt="preload"></p>
<h3 id="延迟加载？"><a href="#延迟加载？" class="headerlink" title="延迟加载？"></a>延迟加载？</h3><p>在真正的使用数据时才发起查询，不用的时候不查。按需加载（懒加载）。</p>
<h3 id="Mybatis延迟加载的实现原理是什么"><a href="#Mybatis延迟加载的实现原理是什么" class="headerlink" title="Mybatis延迟加载的实现原理是什么"></a>Mybatis延迟加载的实现原理是什么</h3><p>在真正的使用数据时才发起查询，不用的时候不查。按需加载（懒加载）</p>
<p>MyBatis中的ResultMap关系映射中有两个标签：<code>association</code>和<code>collection</code>，前者适合一对一查询的关系映射，后者适合一对多查询的关系映射。</p>
<ul>
<li>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。 </li>
<li>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。 </li>
<li>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</li>
</ul>
<h3 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><ul>
<li>第一种是使用 <resultMap> 标签，逐一定义列名和对象属性名之间的映射关系。 </resultMap></li>
<li>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</li>
</ul>
<h3 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？"></a>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？</h3><ul>
<li>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签 </li>
<li>trim|where|set|foreach|if|choose|when|otherwise|bind。</li>
<li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</li>
</ul>
<h3 id="Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h3><p>还有很多其他的标签， <code>&lt;resultMap&gt;</code> 、 <code>&lt;parameterMap&gt;</code> 、 <code>&lt;sql&gt;</code> 、 <code>&lt;include&gt;</code> 、 <code>&lt;selectKey&gt;</code> ，加上动态 sql 的 9 个标签， <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段， <code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签</p>
<h3 id="Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h3><p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 sql，然后将 sql 执行结果返回</p>
<p>Dao 接口里的方法可以重载，但是 Mybatis 的 XML 里面的 ID 不允许重复。</p>
<ol>
<li>仅有一个无参方法和一个有参方法</li>
<li>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code></li>
</ol>
<h3 id="MyBatis-是如何进行分页的？分页插件的原理是什么？"><a href="#MyBatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="MyBatis 是如何进行分页的？分页插件的原理是什么？"></a>MyBatis 是如何进行分页的？分页插件的原理是什么？</h3><p>首先是将所有结果查询出来，然后通过计算offset和limit，只返回部分结果，操作在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中进行，所以也叫内存分页。</p>
<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h3 id="简述-MyBatis-的插件运行原理，以及如何编写一个插件。"><a href="#简述-MyBatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述 MyBatis 的插件运行原理，以及如何编写一个插件。"></a>简述 MyBatis 的插件运行原理，以及如何编写一个插件。</h3><p>MyBatis 仅可以编写针对 <code>ParameterHandler</code> 、 <code>ResultSetHandler</code> 、 <code>StatementHandler</code> 、 <code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现 MyBatis 的 Interceptor 接口并复写 <code>intercept()</code> 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件</p>
<h3 id="MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><p>答：MyBatis 有三种基本的 Executor 执行器，<code>SimpleExecutor</code> 、 <code>ReuseExecutor</code> 、 <code>BatchExecutor</code> 。</p>
<ul>
<li><p><code>SimpleExecutor</code> ：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p>
</li>
<li><p><code>ReuseExecutor</code> ：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p>
</li>
</ul>
<ul>
<li><code>BatchExecutor</code> ：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同</li>
</ul>
<h3 id="MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h3><p>答：MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 。</p>
<p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h3 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h3><ul>
<li>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。 </li>
<li>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。 </li>
<li>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</li>
</ul>
<h1 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rtlin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mumu-lsl.github.io/posts/766433e0/">https://mumu-lsl.github.io/posts/766433e0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mumu-lsl.github.io" target="_blank">Lin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/04/4kAthI2sEwCgPio.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/5cf1c465/"><img class="prev-cover" src="https://s2.loli.net/2022/11/04/IY3VqXhfAMZxUjy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">分布式系统概述</div></div></a></div><div class="next-post pull-right"><a href="/posts/96a41905/"><img class="next-cover" src="https://s2.loli.net/2022/11/04/bIEAeJmcV6W7kir.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringCloud</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/96a41905/" title="SpringCloud"><img class="cover" src="https://s2.loli.net/2022/11/04/bIEAeJmcV6W7kir.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-04</div><div class="title">SpringCloud</div></div></a></div><div><a href="/posts/b543ced0/" title="RabbitMQ"><img class="cover" src="https://s2.loli.net/2022/11/04/LJg62o37TxV1MPI.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-04</div><div class="title">RabbitMQ</div></div></a></div><div><a href="/posts/f8540c8f/" title="高性能"><img class="cover" src="https://s2.loli.net/2022/11/04/yzHUZnq5PAOJkEQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-04</div><div class="title">高性能</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">rtlin</div><div class="author-info__description">Lin在此创作, 欢迎各位</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mumu-LSL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/zumumu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SpingBoot"><span class="toc-number">1.</span> <span class="toc-text">SpingBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#starter"><span class="toc-number">1.1.</span> <span class="toc-text">starter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAStarter"><span class="toc-number">1.2.</span> <span class="toc-text">实现一个Starter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">SpringBoot启动过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">SpringBoot的自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">SpringBoot相关注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Spring 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-number">2.1.</span> <span class="toc-text">Spring的核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.2.</span> <span class="toc-text">Bean的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.</span> <span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">2.5.</span> <span class="toc-text">Spring三级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%EF%BC%9F"><span class="toc-number">2.5.1.</span> <span class="toc-text">Spring是如何发现循环依赖的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.2.</span> <span class="toc-text">三级缓存概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B-bean-%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">2.5.3.</span> <span class="toc-text">单例 bean 创建过程源码解析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step1%EF%BC%9A"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">step1：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step2%EF%BC%9A"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">step2：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step3%EF%BC%9A"><span class="toc-number">2.5.3.3.</span> <span class="toc-text">step3：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step4%EF%BC%9A"><span class="toc-number">2.5.3.4.</span> <span class="toc-text">step4：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E6%9D%A5%E7%9C%8B-A%E3%80%81B-%E7%B1%BB-setter-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.4.</span> <span class="toc-text">下面来看 A、B 类 setter 循环依赖的创建过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E5%AE%B9%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text">IOC容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP"><span class="toc-number">2.7.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.7.1.</span> <span class="toc-text">动态代理示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP-%E5%92%8C-AspectJ-AOP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.7.2.</span> <span class="toc-text">Spring AOP 和 AspectJ AOP 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4AOP%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.7.3.</span> <span class="toc-text">请你说说AOP的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP%E4%B8%8D%E8%83%BD%E5%AF%B9%E5%93%AA%E4%BA%9B%E7%B1%BB%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%BC%BA%EF%BC%9F"><span class="toc-number">2.7.4.</span> <span class="toc-text">Spring AOP不能对哪些类进行增强？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.7.5.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGLIB%E4%B8%8EJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%89%B9%E7%82%B9"><span class="toc-number">2.7.6.</span> <span class="toc-text">CGLIB与JDK动态代理特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.8.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89"><span class="toc-number">2.8.1.</span> <span class="toc-text">事务四个特性（ACID）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8spring%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C"><span class="toc-number">2.8.2.</span> <span class="toc-text">在spring中进行事务管理操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%EF%BC%88%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">2.8.3.</span> <span class="toc-text">事务操作（声明式事务管理参数配置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%8C%E5%B9%BB%E8%AF%BB"><span class="toc-number">2.8.4.</span> <span class="toc-text">脏读，不可重复读，幻读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.8.5.</span> <span class="toc-text">事务的传播行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.8.6.</span> <span class="toc-text">Spring 事务管理接口介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PlatformTransactionManager"><span class="toc-number">2.8.6.1.</span> <span class="toc-text">PlatformTransactionManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionDefinition"><span class="toc-number">2.8.6.2.</span> <span class="toc-text">TransactionDefinition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionStatus-%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">2.8.6.3.</span> <span class="toc-text">TransactionStatus:事务状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Transactional%E6%B3%A8%E8%A7%A3%EF%BC%8C%E4%BA%8B%E5%8A%A1%E4%B8%8D%E7%94%9F%E6%95%88"><span class="toc-number">2.8.7.</span> <span class="toc-text">spring项目中使用@Transactional注解，事务不生效</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC"><span class="toc-number">3.</span> <span class="toc-text">SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DispatcherServlet%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.0.1.</span> <span class="toc-text">DispatcherServlet处理流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFtoken"><span class="toc-number">3.0.2.</span> <span class="toc-text">什么是token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E8%8C%83Cookie%E5%8A%AB%E6%8C%81"><span class="toc-number">3.0.3.</span> <span class="toc-text">防范Cookie劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.0.4.</span> <span class="toc-text">cookie和session的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E5%92%8Csession%E5%90%84%E8%87%AA%E9%80%82%E5%90%88%E7%9A%84%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.0.5.</span> <span class="toc-text">cookie和session各自适合的场景是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BB%8B%E7%BB%8Dsession%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.0.6.</span> <span class="toc-text">请介绍session的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E8%AF%B7%E6%B1%82%E4%B8%8Epost%E8%AF%B7%E6%B1%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.0.7.</span> <span class="toc-text">get请求与post请求有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8F%82%E6%95%B0%E8%83%BD%E6%94%BE%E5%88%B0body%E9%87%8C%E9%9D%A2%E5%90%97%EF%BC%9F"><span class="toc-number">3.0.8.</span> <span class="toc-text">get请求的参数能放到body里面吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">3.0.9.</span> <span class="toc-text">如何自定义拦截器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyBaits"><span class="toc-number">4.</span> <span class="toc-text">MyBaits</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.0.1.</span> <span class="toc-text">MyBatis是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFORM"><span class="toc-number">4.0.2.</span> <span class="toc-text">什么是ORM?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ORM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">4.0.3.</span> <span class="toc-text">ORM的优缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JPA"><span class="toc-number">4.0.4.</span> <span class="toc-text">JPA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis%E5%92%8CJPA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.5.</span> <span class="toc-text">MyBatis和JPA的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sqlsession%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">4.0.6.</span> <span class="toc-text">sqlsession了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mybatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">4.0.7.</span> <span class="toc-text">mybatis 一级缓存和二级缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.0.8.</span> <span class="toc-text">Mybatis的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E4%B8%AD-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.9.</span> <span class="toc-text">Mybatis中#{}与${}的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8mapper%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">4.0.10.</span> <span class="toc-text">在mapper中如何传递多个参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84Xml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%8Cid%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%EF%BC%9F"><span class="toc-number">4.0.11.</span> <span class="toc-text">不同的Xml映射文件，id是否可以重复？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.0.12.</span> <span class="toc-text">MyBatis编程步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">4.0.13.</span> <span class="toc-text">为什么需要预编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">4.0.14.</span> <span class="toc-text">延迟加载？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.0.15.</span> <span class="toc-text">Mybatis延迟加载的实现原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86sql%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%98%A0%E5%B0%84%E5%BD%A2%E5%BC%8F%EF%BC%9F"><span class="toc-number">4.0.16.</span> <span class="toc-text">Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E5%8A%A8%E6%80%81sql%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81sql%EF%BC%9F%E8%83%BD%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8A%A8%E6%80%81sql%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-number">4.0.17.</span> <span class="toc-text">Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E9%99%A4%E4%BA%86%E5%B8%B8%E8%A7%81%E7%9A%84-select-insert-update-delete-%E6%A0%87%E7%AD%BE%E4%B9%8B%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE%EF%BC%9F"><span class="toc-number">4.0.18.</span> <span class="toc-text">Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dao-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FDao-%E6%8E%A5%E5%8F%A3%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C%E6%97%B6%EF%BC%8C%E6%96%B9%E6%B3%95%E8%83%BD%E9%87%8D%E8%BD%BD%E5%90%97%EF%BC%9F"><span class="toc-number">4.0.19.</span> <span class="toc-text">Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.0.20.</span> <span class="toc-text">MyBatis 是如何进行分页的？分页插件的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-MyBatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%E3%80%82"><span class="toc-number">4.0.21.</span> <span class="toc-text">简述 MyBatis 的插件运行原理，以及如何编写一个插件。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B-Executor-%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.0.22.</span> <span class="toc-text">MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E5%8A%A8%E6%80%81-sql-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81-sql%EF%BC%9F%E8%83%BD%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8A%A8%E6%80%81-sql-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8D%EF%BC%9F"><span class="toc-number">4.0.23.</span> <span class="toc-text">MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.0.24.</span> <span class="toc-text">Mybatis是如何进行分页的？分页插件的原理是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Restful-API"><span class="toc-number">5.</span> <span class="toc-text">Restful API</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/47b6ee30/" title="Cypher"><img src="https://s2.loli.net/2023/04/25/Ml2GwJrQNCthEmn.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cypher"/></a><div class="content"><a class="title" href="/posts/47b6ee30/" title="Cypher">Cypher</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f5f9fa9b/" title="Docker"><img src="https://s2.loli.net/2022/11/04/yzHUZnq5PAOJkEQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/posts/f5f9fa9b/" title="Docker">Docker</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c5146ddf/" title="Hanlp Tutorial"><img src="https://s2.loli.net/2022/11/04/yzHUZnq5PAOJkEQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hanlp Tutorial"/></a><div class="content"><a class="title" href="/posts/c5146ddf/" title="Hanlp Tutorial">Hanlp Tutorial</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2d771287/" title="Kubernetes学习"><img src="https://s2.loli.net/2023/04/25/Y6vlUwK2oVJcTX5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kubernetes学习"/></a><div class="content"><a class="title" href="/posts/2d771287/" title="Kubernetes学习">Kubernetes学习</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/da599ed4/" title="NLP概述"><img src="https://s2.loli.net/2023/04/25/Y6vlUwK2oVJcTX5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NLP概述"/></a><div class="content"><a class="title" href="/posts/da599ed4/" title="NLP概述">NLP概述</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div></div></div></div></div></main><footer id="footer" style="background: -rgb(0,0,255)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By rtlin</div><div class="footer_custom_text">所有你乐于挥霍的时间，都不能算作浪费</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="null" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>