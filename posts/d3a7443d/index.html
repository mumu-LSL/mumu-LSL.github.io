<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JavaScript学习 | Lin's Blog</title><meta name="keywords" content="-前端"><meta name="author" content="rtlin"><meta name="copyright" content="rtlin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript学习JavaScript（JS）是一种具有函数优先特性的轻量级、解释型或者说即时编译型的编程语言。虽然作为 Web 页面中的脚本语言被人所熟知，但是它也被用到了很多非浏览器环境中，例如 Node.js、Apache CouchDB、Adobe Acrobat 等。进一步说，JavaScript 是一种基于原型、多范式、单线程的动态语言，并且支持面向对象、命令式和声明式（如函数式">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript学习">
<meta property="og:url" content="https://mumu-lsl.github.io/posts/d3a7443d/index.html">
<meta property="og:site_name" content="Lin&#39;s Blog">
<meta property="og:description" content="JavaScript学习JavaScript（JS）是一种具有函数优先特性的轻量级、解释型或者说即时编译型的编程语言。虽然作为 Web 页面中的脚本语言被人所熟知，但是它也被用到了很多非浏览器环境中，例如 Node.js、Apache CouchDB、Adobe Acrobat 等。进一步说，JavaScript 是一种基于原型、多范式、单线程的动态语言，并且支持面向对象、命令式和声明式（如函数式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/11/04/iFEwRpHTe73zSUY.jpg">
<meta property="article:published_time" content="2023-07-07T05:26:42.000Z">
<meta property="article:modified_time" content="2023-12-26T10:14:37.334Z">
<meta property="article:author" content="rtlin">
<meta property="article:tag" content="-前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/11/04/iFEwRpHTe73zSUY.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mumu-lsl.github.io/posts/d3a7443d/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-26 18:14:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/11/04/iFEwRpHTe73zSUY.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lin's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-07T05:26:42.000Z" title="发表于 2023-07-07 13:26:42">2023-07-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-26T10:14:37.334Z" title="更新于 2023-12-26 18:14:37">2023-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JavaScript学习"><a href="#JavaScript学习" class="headerlink" title="JavaScript学习"></a>JavaScript学习</h1><p><strong>JavaScript</strong>（<strong>JS</strong>）是一种具有<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function">函数优先</a>特性的轻量级、解释型或者说<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF">即时编译型</a>的编程语言。虽然作为 Web 页面中的脚本语言被人所熟知，但是它也被用到了很多<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JavaScript#%E5%85%B6%E4%BB%96">非浏览器环境</a>中，例如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Node.js">Node.js</a>、<a target="_blank" rel="noopener" href="https://couchdb.apache.org/">Apache CouchDB</a>、<a target="_blank" rel="noopener" href="https://opensource.adobe.com/dc-acrobat-sdk-docs/acrobatsdk/">Adobe Acrobat</a> 等。进一步说，JavaScript 是一种<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Prototype-based_programming">基于原型</a>、多范式、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Thread">单线程</a>的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Dynamic_typing">动态</a>语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。</p>
<p>函数优先：指的是当一门编程语言的函数可以被当作变量一样用时，则称这门语言拥有<strong>头等函数</strong>。</p>
<p>即时编译：在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">计算机技术</a>中，<strong>即时编译</strong>（英语：Just-in-time compilation，缩写为<strong>JIT</strong>；又译<strong>及时编译</strong>、<strong>实时编译</strong>），也称为<strong>动态翻译</strong>或<strong>运行时编译</strong>，是一种执行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%A3%E7%A0%81">计算机代码</a>的方法，这种方法设计在程序执行过程中（在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%B7%E8%A1%8C%E6%9C%9F">执行期</a>）而不是在执行之前进行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译</a>。通常，这包括<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>或更常见的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81">字节码</a>到<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80">机器码</a>的转换，然后直接执行。实现JIT编译器的系统通常会不断地分析正在执行的代码，并确定代码的某些部分，在这些部分中，编译或重新编译所获得的加速将超过编译该代码的开销。</p>
<p>JIT编译是两种传统的机器代码翻译方法——<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91&action=edit&redlink=1">提前编译</a>（AOT）和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器</a>——的结合，它结合了两者的优点和缺点。大致来说，JIT编译，以解释器的开销以及编译和链接（解释之外）的开销，结合了编译代码的速度与解释的灵活性。JIT编译是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8B%95%E6%85%8B%E7%B7%A8%E8%AD%AF">动态编译</a>的一种形式，允许<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%87%AA%E9%80%82%E5%BA%94%E4%BC%98%E5%8C%96&action=edit&redlink=1">自适应优化</a>，比如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%87%8D%E7%BC%96%E8%AF%91">动态重编译</a>和特定于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9E%B6%E6%A7%8B">微架构</a>的加速——因此，在理论上，JIT编译比静态编译能够产生更快的执行速度。解释和JIT编译特别适合于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80">动态编程语言</a>，因为运行时系统可以处理<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%90%8E%E6%9C%9F%E7%BB%91%E5%AE%9A&action=edit&redlink=1">后期绑定</a>的数据类型并实施安全保证。</p>
<h2 id="JavaScript-调用策略"><a href="#JavaScript-调用策略" class="headerlink" title="JavaScript 调用策略"></a>JavaScript 调用策略</h2><p>要让脚本调用的时机符合预期，需要解决一系列的问题。这里看似简单，实际大有文章。最常见的问题就是：HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">文档对象模型</a> DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。</p>
<p>浏览器遇到 <code>async</code> 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其他任何脚本时，<code>async</code> 是最理想的选择。</p>
<ul>
<li>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li>
<li>如果脚本需要等待页面解析，且依赖于其他脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>最新的 ECMAScript 标准定义了 8 种数据类型：</p>
<ul>
<li>七种基本数据类型：<ul>
<li>布尔值（Boolean），有 2 个值分别是：<code>true</code> 和 <code>false</code>.</li>
<li>null，一个表明 null 值的特殊关键字。JavaScript 是大小写敏感的，因此 <code>null</code> 与 <code>Null</code>、<code>NULL</code>或变体完全不同。</li>
<li>undefined，和 null 一样是一个特殊的关键字，undefined 表示变量未赋值时的属性。</li>
<li>数字（Number），整数或浮点数，例如： <code>42</code> 或者 <code>3.14159</code>。</li>
<li>任意精度的整数 (BigInt) ，可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。</li>
<li>字符串（String），字符串是一串表示文本值的字符序列，例如：”Howdy” 。</li>
<li>代表（Symbol）( 在 ECMAScript 6 中新添加的类型).。一种实例是唯一且不可改变的数据类型。</li>
</ul>
</li>
<li>以及对象（Object）。</li>
</ul>
<h2 id="语法和数据结构"><a href="#语法和数据结构" class="headerlink" title="语法和数据结构"></a>语法和数据结构</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>JavaScript 是<strong>区分大小写</strong>的，并使用 <strong>Unicode</strong> 字符集</p>
<p>JavaScript 有三种声明方式。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var"><code>var</code></a></p>
<p>声明一个变量，可选初始化一个值。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a></p>
<p>声明一个块作用域的局部变量，可选初始化一个值。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const"><code>const</code></a></p>
<p>声明一个块作用域的只读常量。</p>
</li>
</ul>
<p>区别：</p>
<p><strong>var:</strong></p>
<ul>
<li>用 var 声明的变量的作用域是它当前的执行上下文，即如果是在任何函数外面，则是全局执行上下文，如果在函数里面，则是当前函数执行上下文。换句话说，var 声明的变量的作用域只能是全局或者整个函数块的。</li>
<li>存在变量提升：你可以先使用变量稍后再声明变量而不会引发异常。这一概念称为变量提升；JavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。但是，提升后的变量将返回 undefined 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。</li>
<li>一个变量可多次声明，后面的声明会覆盖前面的声明</li>
<li>var 在全局环境声明变量，会在全局对象里新建一个属性</li>
</ul>
<p><strong>let:</strong></p>
<ul>
<li>let 声明的变量的作用域则是它当前所处代码块，即它的作用域既可以是全局或者整个函数块，也可以是 if、while、switch等用<code>&#123;&#125;</code>限定的代码块。</li>
<li>不存在变量提升，let声明变量前，该变量不能使用（暂时性死区）</li>
<li>不允许在同一作用域中重复声明，否则将抛出异常。let 声明的重复性检查是发生在词法分析阶段，也就是在代码正式开始执行之前就会进行检查。</li>
<li>let 在全局环境声明变量，则不会在全局对象里新建一个属性。</li>
</ul>
<p><strong>const:</strong></p>
<p>常量不可以通过重新赋值改变其值，也不可以在代码运行时重新声明。它必须被初始化为某个值。常量的作用域规则与 <code>let</code> 块级作用域变量相同。</p>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>用 <code>var</code> 或 <code>let</code> 语句声明的变量，如果没有赋初始值，则其值为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>。</p>
<p>可以使用 <code>undefined</code> 来判断一个变量是否已赋值。在以下的代码中，变量<code>input</code>未被赋值，因此 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else"><code>if</code> (en-US)</a> 条件语句的求值结果是 <code>true</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input;</span><br><span class="line"><span class="keyword">if</span>(input === <span class="literal">undefined</span>)&#123;</span><br><span class="line">  <span class="title function_">doThis</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">doThat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>undefined </code>值在布尔类型环境中会被当作 false,  数值类型环境中 <code>undefined</code> 值会被转换为 <code>NaN</code></li>
<li><code>null</code> 在数值类型环境中会被当作 0 来对待，而布尔类型环境中会被当作 <code>false</code>。</li>
</ul>
<h3 id="Javascript声明提升"><a href="#Javascript声明提升" class="headerlink" title="Javascript声明提升"></a>Javascript声明提升</h3><p>Js中，函数及其变量的声明都将被提升到函数的最顶部。也就是可以先使用后声明。</p>
<p>只有声明会被提升，但是初始化不会</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x; <span class="comment">//声明，会被提升</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">//初始化，不会提升</span></span><br></pre></td></tr></table></figure>



<h2 id="现代模式"><a href="#现代模式" class="headerlink" title="现代模式"></a>现代模式</h2><p>长久以来，JavaScript 不断向前发展且并未带来任何兼容性问题。新的特性被加入，旧的功能也没有改变。</p>
<p>这么做有利于兼容旧代码，但缺点是 JavaScript 创造者的任何错误或不完善的决定也将永远被保留在 JavaScript 语言中。</p>
<p>这种情况一直持续到 2009 年 ECMAScript 5 (ES5) 的出现。ES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— <code>&quot;use strict&quot;</code> 来明确地激活这些特性。</p>
<p>请确保 <code>&quot;use strict&quot;</code> 出现在脚本的最顶部，否则严格模式可能无法启用。</p>
<p>现代 JavaScript 支持 “class” 和 “module” —— 高级语言结构（本教程后续章节会讲到），它们会自动启用 <code>use strict</code>。因此，如果我们使用它们，则无需添加 <code>&quot;use strict&quot;</code> 指令。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>JavaScript 可以抛出任意对象。然而，不是所有对象能产生相同的结果。尽管抛出数值或者字母串作为错误信息十分常见，但是通常用下列其中一种异常类型来创建目标更为高效：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error#error_types">ECMAScript exceptions</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMException"><code>DOMException</code></a> and <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMError"><code>DOMError</code></a></li>
</ul>
<p><code>try...catch</code> 语句标记一块待尝试的语句，并规定一个以上的响应应该有一个异常被抛出。如果我们抛出一个异常，<code>try...catch</code>语句就捕获它。</p>
<p><code>try...catch</code> 语句有一个包含一条或者多条语句的 try 代码块，0 个或 1 个的<code>catch</code>代码块，catch 代码块中的语句会在 try 代码块中抛出异常时执行。换句话说，如果你在 try 代码块中的代码如果没有执行成功，那么你希望将执行流程转入 catch 代码块。如果 try 代码块中的语句（或者<code>try</code> 代码块中调用的方法）一旦抛出了异常，那么执行流程会立即进入<code>catch</code> 代码块。如果 try 代码块没有抛出异常，catch 代码块就会被跳过。<code>finally</code> 代码块总会紧跟在 try 和 catch 代码块之后执行，但会在 try 和 catch 代码块之后的其他代码之前执行。</p>
<p>下面的例子使用了<code>try...catch</code>语句。示例调用了一个函数用于从一个数组中根据传递值来获取一个月份名称。如果该值与月份数值不相符，会抛出一个带有<code>&quot;InvalidMonthNo&quot;</code>值的异常，然后在捕捉块语句中设<code>monthName</code>变量为<code>unknown</code>。</p>
<p>try..catch…finally示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;bogus&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;  <span class="comment">//无条件的catch块</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// this return statement is suspended</span></span><br><span class="line">                   <span class="comment">// until finally block has completed</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); <span class="comment">// not reachable</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// overwrites the previous &quot;return&quot;</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); <span class="comment">// not reachable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &quot;return false&quot; is executed now</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>); <span class="comment">// not reachable</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">f</span>(); <span class="comment">// console 0, 1, 3; returns false</span></span><br></pre></td></tr></table></figure>

<p>抛出对象可以是任何一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span>  &#123;<span class="attr">toString</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;I&#x27;m an object!&quot;</span>; &#125; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(ex.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;outer&quot;</span>, ex.<span class="property">message</span>);   <span class="comment">//得不到执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是一个值。重申一次：无论函数是如何创建的，函数都是一个值。</p>
<ul>
<li><p><strong>函数声明</strong>：在主代码流中声明为单独的语句的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数表达式</strong>：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 <code>=</code> 右侧创建的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。</strong>函数声明则不同。<strong>在函数声明被定义之前，它就可以被调用。</strong>函数声明的另外一个特殊的功能是它们的块级作用域。<strong>严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。</strong></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包（Closure）是指在 JavaScript 中能够访问独立的函数作用域的函数，即使在该函数外部调用。闭包可以访问其自身作用域以及包含它的函数作用域。这是由于 JavaScript 的词法作用域规则，函数在定义时就“记住”了它被创建的作用域。</p>
<p>闭包通常在以下情况下发挥作用：</p>
<ol>
<li><strong>封装变量：</strong> 通过闭包，可以创建私有变量，这些变量对外部是不可见的，从而实现一定程度的封装。</li>
<li><strong>保存状态：</strong> 闭包可以用于保存函数执行时的状态，使得函数在后续调用时可以继续操作之前的状态。</li>
</ol>
<p>你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。它自身也形成了一个闭包。一个闭包是一个可以自己拥有独立的环境与变量的表达式（通常是函数）。</p>
<p>既然嵌套函数是一个闭包，就意味着一个嵌套函数可以”继承“容器函数的参数和变量。换句话说，内部函数包含外部函数的作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">reset</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Counter reset&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterObj = <span class="title function_">createCounter</span>();</span><br><span class="line">counterObj.<span class="title function_">increment</span>(); <span class="comment">// 输出 1</span></span><br><span class="line">counterObj.<span class="title function_">increment</span>(); <span class="comment">// 输出 2</span></span><br><span class="line">counterObj.<span class="title function_">reset</span>();     <span class="comment">// 输出 &quot;Counter reset&quot;</span></span><br></pre></td></tr></table></figure>



<p>闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。</p>
<p>但是，外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。</p>
<p>此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数的生存周期将比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">func</span> = (<span class="params">arg1, arg2, ..., argN</span>) =&gt; expression;</span><br></pre></td></tr></table></figure>

<p>到目前为止，我们看到的箭头函数非常简单。它们从 <code>=&gt;</code> 的左侧获取参数，计算并返回右侧表达式的计算结果。</p>
<p>有时我们需要更复杂一点的函数，比如带有多行的表达式或语句。在这种情况下，我们可以使用花括号将它们括起来。主要区别在于，用花括号括起来之后，需要包含 <code>return</code> 才能返回值（就像常规函数一样）。</p>
<p>就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; &#123;  <span class="comment">// 花括号表示开始一个多行函数</span></span><br><span class="line">  <span class="keyword">let</span> result = a + b;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 如果我们使用了花括号，那么我们需要一个显式的 “return”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>CMAScript 2015，也称 ES6，引入了 JavaScript 类。JavaScript 类是 JavaScript 对象的模板。请使用关键字 <code>class</code> 创建类。请始终添加名为 <code>constructor()</code> 的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method_1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method_2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method_3</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">              </span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">age</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x - <span class="variable language_">this</span>.<span class="property">year</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。对象的所有键名都是字符串，（ES6又引入Symbol值也可以作为键名），所以加不加引号都可以。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>我们可以用下面两种语法中的任一种来创建一个空的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// “构造函数” 的语法</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;  <span class="comment">// “字面量” 的语法</span></span><br></pre></td></tr></table></figure>

<p>字面量方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    id : <span class="number">5566</span>,</span><br><span class="line">    fullName : <span class="keyword">function</span>(<span class="params"></span>) </span><br><span class="line">	&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用构造函数创建对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 this 关键字初始化对象的属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以在构造函数中定义方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, my name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; and I am &quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造函数创建对象</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jane&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对象的方法</span></span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is John and I am 25 years old.</span></span><br><span class="line">person2.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is Jane and I am 30 years old.</span></span><br></pre></td></tr></table></figure>





<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.<span class="property">age</span>;</span><br><span class="line">person[<span class="string">&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们经常使用<strong>点表示法</strong>（dot notation）来访问对象的属性和方法</p>
</li>
<li><p>另一种访问对象属性的方式是使用<strong>括号表示法</strong>（bracket notation）</p>
</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>通常，对象方法需要访问对象中存储的信息才能完成其工作。例如，<code>user.sayHi()</code> 中的代码可能需要用到 <code>user</code> 的 name 属性。<strong>为了访问该对象，方法中可以使用 <code>this</code> 关键字。</strong><code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// &quot;this&quot; 指的是“当前的对象”</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>



<h3 id="this不受限制"><a href="#this不受限制" class="headerlink" title="this不受限制"></a>this不受限制</h3><p>在 JavaScript 中，<code>this</code> 关键字与其他大多数编程语言中的不同。JavaScript 中的 <code>this</code> 可以用于任何函数，即使它不是对象的方法。</p>
<p>下面这样的代码没有语法错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="variable language_">this</span>.<span class="property">name</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p>
<p>例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 “this” 值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">&quot;Admin&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="variable language_">this</span>.<span class="property">name</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在两个对象中使用相同的函数</span></span><br><span class="line">user.<span class="property">f</span> = sayHi;</span><br><span class="line">admin.<span class="property">f</span> = sayHi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个调用有不同的 this 值</span></span><br><span class="line"><span class="comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span></span><br><span class="line">user.<span class="title function_">f</span>(); <span class="comment">// John（this == user）</span></span><br><span class="line">admin.<span class="title function_">f</span>(); <span class="comment">// Admin（this == admin）</span></span><br><span class="line"></span><br><span class="line">admin[<span class="string">&#x27;f&#x27;</span>](); <span class="comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p> <strong>解除</strong> <code>this</code> <strong>绑定的后果</strong></p>
<p> 如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 <code>this</code>”的概念，即在对象中定义的方法总是有指向该对象的 <code>this</code>。在 JavaScript 中，<code>this</code> 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。在运行时对 <code>this</code> 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。</p>
</blockquote>
<p>箭头函数没有自己的 this。箭头函数有些特别：它们没有自己的 <code>this</code>。如果我们在这样的函数中引用 <code>this</code>，<code>this</code> 值取决于外部“正常的”函数。</p>
<h3 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h3><p>原型是 JavaScript 对象相互继承特性的机制。在这篇文章中，我们将解释什么是原型，原型链如何工作，以及如何为一个对象设置原型。JavaScript 中所有的对象都有一个内置属性，称为它的 <strong>prototype</strong>（原型）。它本身是一个对象，故原型对象也会有它自己的原型，逐渐构成了<strong>原型链</strong>。原型链终止于拥有 <code>null</code> 作为其原型的对象上。</p>
<p>在 JavaScript 中，有多种设置对象原型的方法，这里我们将介绍两种：<code>Object.create()</code> 和构造函数。</p>
<p><strong>Object.create()</strong></p>
<h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><p>在 JavaScript 的早期版本中，确实没有类的概念，只有构造器函数和原型继承。然而，自 ECMAScript 2015（通常称为 ES6）引入之后，JavaScript 提供了对类和面向对象编程的支持。</p>
<p>在 ES6 中，你可以使用 <code>class</code> 关键字来定义类，以更直观的方式创建对象。类提供了一种更结构化和面向对象的编程方式，其中可以定义构造函数、实例方法、静态方法等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name; <span class="comment">// 定义 name 属性</span></span><br><span class="line">  age; <span class="comment">// 定义 age 属性</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 初始化 name 属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age; <span class="comment">// 初始化 age 属性</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类创建对象实例</span></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// 输出: &quot;Alice&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">age</span>); <span class="comment">// 输出: 25</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// 输出: &quot;Bob&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">age</span>); <span class="comment">// 输出: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用实例方法</span></span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure>





<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>symbol 有两个主要的使用场景：</p>
<ol>
<li><p>创建唯一的对象属性名：由于 Symbol 的值是唯一的，可以用作对象属性的键，确保属性名的唯一性，避免命名冲突的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">KEY</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="variable constant_">KEY</span>] = <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="variable constant_">KEY</span>]); <span class="comment">// 输出: &#x27;value&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用作常量定义：通过使用 Symbol 创建常量，可以避免使用字符串或其他类型的值，从而确保常量的唯一性。</p>
</li>
<li><p>定义类的私有属性或方法：通过使用 Symbol，可以创建类的私有属性或方法，这些属性或方法不容易被外部访问或覆盖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _privateField = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[_privateField] = <span class="string">&#x27;private value&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getPrivateValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[_privateField];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getPrivateValue</span>()); <span class="comment">// 输出: &#x27;private value&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance[_privateField]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> 允许我们获取所有的 symbol。还有一个名为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> 的方法可以返回一个对象的 <strong>所有</strong> 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。</p>
<h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><h4 id="JavaScript-迭代器"><a href="#JavaScript-迭代器" class="headerlink" title="JavaScript 迭代器"></a>JavaScript 迭代器</h4><p>迭代器协议定义了如何从对象生成值序列。对象实现 next ()方法时成为迭代器。Next ()方法必须返回具有两个属性的对象:</p>
<ul>
<li>value (the next value)</li>
<li>done (true or false)</li>
</ul>
<table>
<thead>
<tr>
<th align="left">value</th>
<th>The value returned by the iterator (Can be omitted if done is true)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">done</td>
<td><em>true</em> if the iterator has completed <em>false</em> if the iterator has produced a new value</td>
</tr>
</tbody></table>
<p>A JavaScript iterable is an object that has a <strong>Symbol.iterator</strong>.</p>
<p>The <code>Symbol.iterator</code> is a function that returns a <code>next()</code> function.</p>
<p>An iterable can be iterated over with the code: <code>for (const x of iterable) &#123; &#125;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an Object</span></span><br><span class="line">myNumbers = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make it Iterable</span></span><br><span class="line">myNumbers[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">  done = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      n += <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">100</span>) &#123;done = <span class="literal">true</span>&#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>:n, <span class="attr">done</span>:done&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>以下语句创建了等效的数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(element0, element1, <span class="comment">/* … ,*/</span> elementN);</span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="title class_">Array</span>(element0, element1, <span class="comment">/* … ,*/</span> elementN);</span><br><span class="line"><span class="keyword">const</span> arr3 = [element0, element1, <span class="comment">/* … ,*/</span> elementN];</span><br></pre></td></tr></table></figure>

<h3 id="Length"><a href="#Length" class="headerlink" title="Length"></a>Length</h3><p><code>length</code> 属性是特殊的，你也可以给 <code>length</code> 属性赋值。写一个小于数组元素数量的值将截断数组，写 <code>0</code> 会彻底清空数组</p>
<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>数组可以包含“空槽”，这与用值 <code>undefined</code> 填充的槽不一样。空槽可以通过以下方式之一创建：</p>
<p>JSCopy to Clipboard</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array 构造函数：</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title class_">Array</span>(<span class="number">5</span>); <span class="comment">// [ &lt;5 empty items&gt; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组字面量中的连续逗号：</span></span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">1</span>, <span class="number">2</span>, , , <span class="number">5</span>]; <span class="comment">// [ 1, 2, &lt;2 empty items&gt;, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接给大于 array.length 的索引设置值以形成空槽：</span></span><br><span class="line"><span class="keyword">const</span> c = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">c[<span class="number">4</span>] = <span class="number">5</span>; <span class="comment">// [ 1, 2, &lt;2 empty items&gt;, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过直接设置 .length 拉长一个数组：</span></span><br><span class="line"><span class="keyword">const</span> d = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">d.<span class="property">length</span> = <span class="number">5</span>; <span class="comment">// [ 1, 2, &lt;3 empty items&gt; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个元素：</span></span><br><span class="line"><span class="keyword">const</span> e = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">delete</span> e[<span class="number">2</span>]; <span class="comment">// [ 1, 2, &lt;1 empty item&gt;, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="创建多维数组"><a href="#创建多维数组" class="headerlink" title="创建多维数组"></a>创建多维数组</h3><p>数组是可以嵌套的，这就意味着一个数组可以作为一个元素被包含在另外一个数组里面。利用 JavaScript 数组的这个特性，可以创建多维数组。</p>
<p>以下代码创建了一个二维数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">    a[i][j] = <span class="string">&quot;[&quot;</span> + i + <span class="string">&quot;,&quot;</span> + j + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是发生在你正在编程的系统中的事情——当事件发生时，系统产生（或“触发”）某种信号，并提供一种机制，当事件发生时，可以自动采取某种行动（即运行一些代码）。事件是在浏览器窗口内触发的，并倾向于附加到驻留在其中的特定项目。这可能是一个单一的元素，一组元素，当前标签中加载的 HTML 文档，或整个浏览器窗口。有许多不同类型的事件可以发生。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">random</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (number + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rndCol = <span class="string">`rgb(<span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>)`</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = rndCol;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正如我们在上一个示例中所看到的，能够触发事件的对象有一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a> 方法，这就是推荐的添加事件处理器的机制。</p>
<p>通过对 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a> 的多次调用，每次提供不同的处理器，你可以为一个事件设置多个处理器：</p>
<p>JSCopy to Clipboard</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myElement.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, functionA);</span><br><span class="line">myElement.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, functionB);</span><br></pre></td></tr></table></figure>

<h3 id="事件处理器属性"><a href="#事件处理器属性" class="headerlink" title="事件处理器属性"></a>事件处理器属性</h3><p>可以触发事件的对象（如按钮）通常也有属性，其名称是 <code>on</code>，后面是事件的名称。例如，元素有一个属性 <code>onclick</code>。这被称为<em>事件处理器属性</em>。为了监听事件，你可以将处理函数分配给该属性。</p>
<p>例如，我们可以像这样重写随机颜色示例：</p>
<p>JSCopy to Clipboard</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">random</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (number + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bgChange</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rndCol = <span class="string">`rgb(<span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>)`</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = rndCol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.<span class="property">onclick</span> = bgChange;</span><br></pre></td></tr></table></figure>



<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>有时候在事件处理函数内部，你可能会看到一个固定指定名称的参数，例如 <code>event</code>、<code>evt</code> 或 <code>e</code>。这被称为<strong>事件对象</strong>，它被自动传递给事件处理函数，以提供额外的功能和信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">random</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (number + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bgChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rndCol = <span class="string">`rgb(<span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>)`</span>;</span><br><span class="line">  e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = rndCol;  <span class="comment">//使用事件对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, bgChange);</span><br></pre></td></tr></table></figure>



<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡描述了浏览器如何处理针对嵌套元素的事件。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>点我！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#output&quot;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  output.<span class="property">textContent</span> += <span class="string">`你在 <span class="subst">$&#123;e.currentTarget.tagName&#125;</span> 元素上进行了点击\n`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#container&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handleClick);</span><br><span class="line">container.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handleClick);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handleClick);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你会发现在用户单击按钮时，所有三个元素都触发了单击事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你在 BUTTON 元素上进行了点击</span><br><span class="line">你在 DIV 元素上进行了点击</span><br><span class="line">你在 BODY 元素上进行了点击</span><br></pre></td></tr></table></figure>

<p>在这种情况下：</p>
<ul>
<li>最先触发按钮上的单击事件</li>
<li>然后是按钮的父元素（<code>&lt;div&gt;</code> 元素）</li>
<li>然后是 <code>&lt;div&gt;</code> 的父元素（<code>&lt;body&gt;</code> 元素）</li>
</ul>
<p><strong>使用 stopPropagation() 阻止冒泡行为</strong></p>
<p>正如我们在上一节所看到的，事件冒泡有时会产生问题，但有一种方法可以防止这些问题。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a> 对象有一个可用的函数，叫做 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation"><code>stopPropagation()</code></a>，当在一个事件处理器中调用时，可以防止事件向任何其他元素传递。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;video&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> box.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;hidden&quot;</span>));</span><br><span class="line"></span><br><span class="line">video.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  video.<span class="title function_">play</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hidden&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>我们看了一个由事件冒泡引起的问题以及如何解决它。不过，事件冒泡并不只是令人讨厌：它可以非常有用。特别是，它可以实现<strong>事件委托</strong>。在这种做法中，当我们想在用户与大量的子元素中的任何一个互动时运行一些代码时，我们在它们的父元素上设置事件监听器，让发生在它们身上的事件冒泡到它们的父元素上，而不必在每个子元素上单独设置事件监听器。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/play">Playground | MDN (mozilla.org)</a></p>
<p>在这个例子中，我们使用 <code>event.target</code> 来获取事件的目标元素（也就是最里面的元素）。如果我们想访问处理这个事件的元素（在这个例子中是容器），我们可以使用 <code>event.currentTarget</code>。</p>
<h2 id="Javascript中的相等判断"><a href="#Javascript中的相等判断" class="headerlink" title="Javascript中的相等判断"></a>Javascript中的相等判断</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Strict_equality"><code>===</code></a>——严格相等（三个等号）</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality"><code>==</code></a>——宽松相等（两个等号）</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is()</code></a></li>
</ul>
<p>选择哪个运算取决于你需要什么样的比较。简单来说：</p>
<ul>
<li>在比较两个操作数时，双等号（<code>==</code>）将执行类型转换，并且会按照 IEEE 754 标准对 <code>NaN</code>、<code>-0</code> 和 <code>+0</code> 进行特殊处理（故 <code>NaN != NaN</code>，且 <code>-0 == +0</code>）；</li>
<li>三等号（<code>===</code>）做的比较与双等号相同（包括对 <code>NaN</code>、<code>-0</code> 和 <code>+0</code> 的特殊处理）但不进行类型转换；如果类型不同，则返回 <code>false</code>；</li>
<li><code>Object.is()</code> 既不进行类型转换，也不对 <code>NaN</code>、<code>-0</code> 和 <code>+0</code> 进行特殊处理（这使它和 <code>===</code> 在除了那些特殊数字值之外的情况具有相同的表现）。</li>
</ul>
<h2 id="JavaScript-Best-Practices"><a href="#JavaScript-Best-Practices" class="headerlink" title="JavaScript Best Practices"></a>JavaScript Best Practices</h2><h3 id="Avoid-Global-Variables"><a href="#Avoid-Global-Variables" class="headerlink" title="Avoid Global Variables"></a>Avoid Global Variables</h3><p>Minimize the use of global variables.</p>
<p>This includes all data types, objects, and functions.</p>
<p>Global variables and functions can be overwritten by other scripts.</p>
<p>Use local variables instead, and learn how to use <a target="_blank" rel="noopener" href="https://www.w3schools.com/js/js_function_closures.asp">closures</a>.</p>
<h3 id="Always-Declare-Local-Variables"><a href="#Always-Declare-Local-Variables" class="headerlink" title="Always Declare Local Variables"></a>Always Declare Local Variables</h3><p>All variables used in a function should be declared as <strong>local</strong> variables.</p>
<p>Local variables <strong>must</strong> be declared with the <code>var</code>, the <code>let</code>, or the <code>const</code> keyword, otherwise they will become global variables.</p>
<h3 id="Declarations-on-Top"><a href="#Declarations-on-Top" class="headerlink" title="Declarations on Top"></a>Declarations on Top</h3><p>It is a good coding practice to put all declarations at the top of each script or function.</p>
<p>This will:</p>
<ul>
<li>Give cleaner code</li>
<li>Provide a single place to look for local variables</li>
<li>Make it easier to avoid unwanted (implied) global variables</li>
<li>Reduce the possibility of unwanted re-declarations</li>
</ul>
<h3 id="Initialize-Variables"><a href="#Initialize-Variables" class="headerlink" title="Initialize Variables"></a>Initialize Variables</h3><p>It is a good coding practice to initialize variables when you declare them.</p>
<p>This will:</p>
<ul>
<li>Give cleaner code</li>
<li>Provide a single place to initialize variables</li>
<li>Avoid undefined values</li>
</ul>
<h3 id="Declare-Objects-with-const"><a href="#Declare-Objects-with-const" class="headerlink" title="Declare Objects with const"></a>Declare Objects with <strong>const</strong></h3><p>Declaring objects with const will prevent any accidental change of type:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">&quot;Fiat&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;500&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;white&quot;</span>&#125;;</span><br><span class="line">car = <span class="string">&quot;Fiat&quot;</span>;      <span class="comment">// Not possible</span></span><br></pre></td></tr></table></figure>

<h3 id="Declare-Arrays-with-const"><a href="#Declare-Arrays-with-const" class="headerlink" title="Declare Arrays with const"></a>Declare Arrays with <strong>const</strong></h3><p>Declaring arrays with const will prevent any accidential change of type:</p>
<h3 id="Don’t-Use-new-Object"><a href="#Don’t-Use-new-Object" class="headerlink" title="Don’t Use new Object()"></a>Don’t Use new Object()</h3><ul>
<li>Use <code>&quot;&quot;</code> instead of <code>new String()</code></li>
<li>Use <code>0</code> instead of <code>new Number()</code></li>
<li>Use <code>false</code> instead of <code>new Boolean()</code></li>
<li>Use <code>&#123;&#125;</code> instead of <code>new Object()</code></li>
<li>Use <code>[]</code> instead of <code>new Array()</code></li>
<li>Use <code>/()/</code> instead of <code>new RegExp()</code></li>
<li>Use <code>function ()&#123;&#125;</code> instead of <code>new Function()</code></li>
</ul>
<h3 id="Beware-of-Automatic-Type-Conversions"><a href="#Beware-of-Automatic-Type-Conversions" class="headerlink" title="Beware of Automatic Type Conversions"></a>Beware of Automatic Type Conversions</h3><p>JavaScript is loosely typed.</p>
<p>A variable can contain all data types.</p>
<p>A variable can change its data type:</p>
<h3 id="Use-x3D-x3D-x3D-Comparison"><a href="#Use-x3D-x3D-x3D-Comparison" class="headerlink" title="Use &#x3D;&#x3D;&#x3D; Comparison"></a>Use &#x3D;&#x3D;&#x3D; Comparison</h3><p>The <code>==</code> comparison operator always converts (to matching types) before comparison.</p>
<p>The <code>===</code> operator forces comparison of values and type:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="string">&quot;&quot;</span>;        <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="string">&quot;1&quot;</span>;       <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>;      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> === <span class="string">&quot;&quot;</span>;       <span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> === <span class="string">&quot;1&quot;</span>;      <span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> === <span class="literal">true</span>;     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="End-Your-Switches-with-Defaults"><a href="#End-Your-Switches-with-Defaults" class="headerlink" title="End Your Switches with Defaults"></a>End Your Switches with Defaults</h3><p>Always end your <code>switch</code> statements with a <code>default</code>. Even if you think there is no need for it.</p>
<h3 id="Avoid-Number-String-and-Boolean-as-Objects"><a href="#Avoid-Number-String-and-Boolean-as-Objects" class="headerlink" title="Avoid Number, String, and Boolean as Objects"></a>Avoid Number, String, and Boolean as Objects</h3><p>Always treat numbers, strings, or booleans as primitive values. Not as objects.</p>
<p>Declaring these types as objects, slows down execution speed, and produces nasty side effects:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">&quot;John&quot;</span>;             </span><br><span class="line"><span class="keyword">let</span> y = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">(x === y) <span class="comment">// is false because x is a string and y is an object.</span></span><br></pre></td></tr></table></figure>

<h3 id="Avoid-Using-eval"><a href="#Avoid-Using-eval" class="headerlink" title="Avoid Using eval()"></a>Avoid Using eval()</h3><p>The <code>eval()</code> function is used to run text as code. In almost all cases, it should not be necessary to use it.</p>
<p>Because it allows arbitrary code to be run, it also represents a security problem.</p>
<h2 id="JavaScript-Performance"><a href="#JavaScript-Performance" class="headerlink" title="JavaScript Performance"></a>JavaScript Performance</h2><h3 id="Reduce-Activity-in-Loops"><a href="#Reduce-Activity-in-Loops" class="headerlink" title="Reduce Activity in Loops"></a>Reduce Activity in Loops</h3><p>Loops are often used in programming.</p>
<p>Each statement in a loop, including the for statement, is executed for each iteration of the loop.</p>
<p>Statements or assignments that can be placed outside the loop will make the loop run faster.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Better Code:</span></span><br><span class="line"><span class="keyword">let</span> l = arr.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Reduce-DOM-Access"><a href="#Reduce-DOM-Access" class="headerlink" title="Reduce DOM Access"></a>Reduce DOM Access</h3><p>Accessing the HTML DOM is very slow, compared to other JavaScript statements.</p>
<p>If you expect to access a DOM element several times, access it once, and use it as a local variable:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">obj.<span class="property">innerHTML</span> = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Reduce-DOM-Size"><a href="#Reduce-DOM-Size" class="headerlink" title="Reduce DOM Size"></a>Reduce DOM Size</h3><p>Keep the number of elements in the HTML DOM small.</p>
<p>This will always improve page loading, and speed up rendering (page display), especially on smaller devices.</p>
<p>Every attempt to search the DOM (like getElementsByTagName) will benefit from a smaller DOM.</p>
<h3 id="Delay-JavaScript-Loading"><a href="#Delay-JavaScript-Loading" class="headerlink" title="Delay JavaScript Loading"></a>Delay JavaScript Loading</h3><p>Putting your scripts at the bottom of the page body lets the browser load the page first.</p>
<p>While a script is downloading, the browser will not start any other downloads. In addition all parsing and rendering activity might be blocked.</p>
<p>The HTTP specification defines that browsers should not download more than two components in parallel.</p>
<p>An alternative is to use <code>defer=&quot;true&quot;</code> in the script tag. The defer attribute specifies that the script should be executed after the page has finished parsing, but it only works for external scripts.</p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><h3 id="构造-Promise"><a href="#构造-Promise" class="headerlink" title="构造 Promise"></a>构造 Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">myResolve, myReject</span>) &#123;</span><br><span class="line"><span class="comment">// &quot;Producing Code&quot; (May take some time)</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">myResolve</span>(); <span class="comment">// when successful</span></span><br><span class="line">  <span class="title function_">myReject</span>();  <span class="comment">// when error</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Consuming Code&quot; (Must wait for a fulfilled Promise)</span></span><br><span class="line">myPromise.<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="comment">/* code if successful */</span> &#125;,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="comment">/* code if some error */</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>A JavaScript Promise object can be:</p>
<ul>
<li>Pending</li>
<li>Fulfilled</li>
<li>Rejected</li>
</ul>
<p>The Promise object supports two properties: <strong>state</strong> and <strong>result</strong>.</p>
<ul>
<li><p>While a Promise object is “pending” (working), the result is undefined.</p>
</li>
<li><p>When a Promise object is “fulfilled”, the result is a value.</p>
</li>
<li><p>When a Promise object is “rejected”, the result is an error object.</p>
</li>
</ul>
<h3 id="Promise-的构造函数"><a href="#Promise-的构造函数" class="headerlink" title="Promise 的构造函数"></a>Promise 的构造函数</h3><p>Promise 构造函数是 JavaScript 中用于创建 Promise 对象的内置构造函数。</p>
<p>Promise 构造函数接受一个函数作为参数，该函数是同步的并且会被立即执行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject，分别表示 Promise 成功和失败的状态。起始函数执行成功时，它应该调用 resolve 函数并传递成功的结果。当起始函数执行失败时，它应该调用 reject 函数并传递失败的原因。</p>
<p>Promise 构造函数返回一个 Promise 对象，该对象具有以下几个方法：</p>
<ul>
<li>then：用于处理 Promise 成功状态的回调函数。Then ()接受两个参数，一个是成功的回调，另一个是失败的回调。两者都是可选的，因此只能为成功或失败添加回调。</li>
<li>catch：用于处理 Promise 失败状态的回调函数。</li>
<li>finally：无论 Promise 是成功还是失败，都会执行的回调函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2222</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3333</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;An error&quot;</span>;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line"><span class="number">1111</span></span><br><span class="line"><span class="number">2222</span></span><br><span class="line"><span class="number">3333</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操。reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p>
<p>但是请注意以下两点：</p>
<ul>
<li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li>
<li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li>
</ul>
<h2 id="Async-x2F-Await"><a href="#Async-x2F-Await" class="headerlink" title="Async&#x2F;Await"></a>Async&#x2F;Await</h2><p>异步函数（async function）是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。</p>
<p>在 Promise 中我们编写过一个 Promise 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">delay, message</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将这段代码变得更好看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">print</span>(<span class="number">1000</span>, <span class="string">&quot;First&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">print</span>(<span class="number">4000</span>, <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">print</span>(<span class="number">3000</span>, <span class="string">&quot;Third&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">asyncFunc</span>();</span><br></pre></td></tr></table></figure>

<p><strong>异步函数实际上原理与 Promise 原生 API 的机制是一模一样的，只不过更便于程序员阅读。</strong></p>
<p>异步函数 async function 中可以使用 await 指令，await 关键字只能在异步函数 async function 中使用。await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> req = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    req.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&quot;mycar.html&quot;</span>);</span><br><span class="line">    req.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (req.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(req.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;File not Found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.<span class="title function_">send</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="keyword">await</span> myPromise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getFile</span>();</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rtlin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mumu-lsl.github.io/posts/d3a7443d/">https://mumu-lsl.github.io/posts/d3a7443d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mumu-lsl.github.io" target="_blank">Lin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">-前端</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/04/iFEwRpHTe73zSUY.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/f7e593b0/"><img class="prev-cover" src="https://s2.loli.net/2023/04/25/Qb7XE4ekWJm8tou.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Distributed Systems Engineering</div></div></a></div><div class="next-post pull-right"><a href="/posts/f5f9fa9b/"><img class="next-cover" src="https://s2.loli.net/2023/04/25/xaEPJeC1tMbZ92w.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">rtlin</div><div class="author-info__description">Lin在此创作, 欢迎各位</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mumu-LSL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/zumumu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">JavaScript学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E8%B0%83%E7%94%A8%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.</span> <span class="toc-text">JavaScript 调用策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">语法和数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.3.1.</span> <span class="toc-text">变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"><span class="toc-number">1.3.2.</span> <span class="toc-text">变量赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Javascript%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87"><span class="toc-number">1.3.3.</span> <span class="toc-text">Javascript声明提升</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">现代模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.6.1.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">箭头函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.7.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.2.</span> <span class="toc-text">访问属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">1.8.3.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6"><span class="toc-number">1.8.4.</span> <span class="toc-text">this不受限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.8.5.</span> <span class="toc-text">对象原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB-1"><span class="toc-number">1.8.6.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol"><span class="toc-number">1.8.7.</span> <span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.8.8.</span> <span class="toc-text">对象迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.8.8.1.</span> <span class="toc-text">JavaScript 迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Length"><span class="toc-number">1.9.1.</span> <span class="toc-text">Length</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.2.</span> <span class="toc-text">稀疏数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.3.</span> <span class="toc-text">创建多维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.10.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">1.10.1.</span> <span class="toc-text">事件处理器属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.10.2.</span> <span class="toc-text">事件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">1.10.3.</span> <span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">1.10.4.</span> <span class="toc-text">事件委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javascript%E4%B8%AD%E7%9A%84%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD"><span class="toc-number">1.11.</span> <span class="toc-text">Javascript中的相等判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-Best-Practices"><span class="toc-number">1.12.</span> <span class="toc-text">JavaScript Best Practices</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Avoid-Global-Variables"><span class="toc-number">1.12.1.</span> <span class="toc-text">Avoid Global Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Always-Declare-Local-Variables"><span class="toc-number">1.12.2.</span> <span class="toc-text">Always Declare Local Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Declarations-on-Top"><span class="toc-number">1.12.3.</span> <span class="toc-text">Declarations on Top</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Initialize-Variables"><span class="toc-number">1.12.4.</span> <span class="toc-text">Initialize Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Declare-Objects-with-const"><span class="toc-number">1.12.5.</span> <span class="toc-text">Declare Objects with const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Declare-Arrays-with-const"><span class="toc-number">1.12.6.</span> <span class="toc-text">Declare Arrays with const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Don%E2%80%99t-Use-new-Object"><span class="toc-number">1.12.7.</span> <span class="toc-text">Don’t Use new Object()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Beware-of-Automatic-Type-Conversions"><span class="toc-number">1.12.8.</span> <span class="toc-text">Beware of Automatic Type Conversions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-x3D-x3D-x3D-Comparison"><span class="toc-number">1.12.9.</span> <span class="toc-text">Use &#x3D;&#x3D;&#x3D; Comparison</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#End-Your-Switches-with-Defaults"><span class="toc-number">1.12.10.</span> <span class="toc-text">End Your Switches with Defaults</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Avoid-Number-String-and-Boolean-as-Objects"><span class="toc-number">1.12.11.</span> <span class="toc-text">Avoid Number, String, and Boolean as Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Avoid-Using-eval"><span class="toc-number">1.12.12.</span> <span class="toc-text">Avoid Using eval()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-Performance"><span class="toc-number">1.13.</span> <span class="toc-text">JavaScript Performance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reduce-Activity-in-Loops"><span class="toc-number">1.13.1.</span> <span class="toc-text">Reduce Activity in Loops</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reduce-DOM-Access"><span class="toc-number">1.13.2.</span> <span class="toc-text">Reduce DOM Access</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reduce-DOM-Size"><span class="toc-number">1.13.3.</span> <span class="toc-text">Reduce DOM Size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delay-JavaScript-Loading"><span class="toc-number">1.13.4.</span> <span class="toc-text">Delay JavaScript Loading</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promises"><span class="toc-number">1.14.</span> <span class="toc-text">Promises</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-Promise"><span class="toc-number">1.14.1.</span> <span class="toc-text">构造 Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.2.</span> <span class="toc-text">Promise 的构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Async-x2F-Await"><span class="toc-number">1.15.</span> <span class="toc-text">Async&#x2F;Await</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/32d059c8/" title="过一种轻松的生活"><img src="https://s2.loli.net/2022/11/04/l79ag8sNp5VqPYX.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="过一种轻松的生活"/></a><div class="content"><a class="title" href="/posts/32d059c8/" title="过一种轻松的生活">过一种轻松的生活</a><time datetime="2024-02-21T09:48:34.000Z" title="发表于 2024-02-21 17:48:34">2024-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bf89ac9a/" title="raft学习"><img src="https://s2.loli.net/2022/11/04/iFEwRpHTe73zSUY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="raft学习"/></a><div class="content"><a class="title" href="/posts/bf89ac9a/" title="raft学习">raft学习</a><time datetime="2023-09-07T05:27:39.000Z" title="发表于 2023-09-07 13:27:39">2023-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f7e593b0/" title="Distributed Systems Engineering"><img src="https://s2.loli.net/2023/04/25/Qb7XE4ekWJm8tou.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Distributed Systems Engineering"/></a><div class="content"><a class="title" href="/posts/f7e593b0/" title="Distributed Systems Engineering">Distributed Systems Engineering</a><time datetime="2023-08-07T05:27:22.000Z" title="发表于 2023-08-07 13:27:22">2023-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d3a7443d/" title="JavaScript学习"><img src="https://s2.loli.net/2022/11/04/iFEwRpHTe73zSUY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript学习"/></a><div class="content"><a class="title" href="/posts/d3a7443d/" title="JavaScript学习">JavaScript学习</a><time datetime="2023-07-07T05:26:42.000Z" title="发表于 2023-07-07 13:26:42">2023-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f5f9fa9b/" title="Docker"><img src="https://s2.loli.net/2023/04/25/xaEPJeC1tMbZ92w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/posts/f5f9fa9b/" title="Docker">Docker</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div></div></div></div></div></main><footer id="footer" style="background: -rgb(0,0,255)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By rtlin</div><div class="footer_custom_text">所有你乐于挥霍的时间，都不能算作浪费</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="null" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>