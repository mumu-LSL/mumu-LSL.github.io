<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux多进程编程 | Lin's Blog</title><meta name="keywords" content="Linux网络编程"><meta name="author" content="木木想去北海种花"><meta name="copyright" content="木木想去北海种花"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多进程编程进程进程的概念一个程序文件, 只是一堆待执行的代码和部分待处理的数据它们只有被加载到内存中,然后让CPU逐条执行其代码,根据代码做出相应的动作,才形成一个真正“活的”、动态的 进程(Process)因此, 进程是一个动态变化的过程,是一出有始有终的戏而程序文件只是这一系列动作的原始蓝本,是一个静态的剧本  进程就是程序在内存中 动态执行的过程 进程是系统资源管理的 最小的单位 进程是动态">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux多进程编程">
<meta property="og:url" content="https://mumu-lsl.github.io/posts/716f0d9b/index.html">
<meta property="og:site_name" content="Lin&#39;s Blog">
<meta property="og:description" content="多进程编程进程进程的概念一个程序文件, 只是一堆待执行的代码和部分待处理的数据它们只有被加载到内存中,然后让CPU逐条执行其代码,根据代码做出相应的动作,才形成一个真正“活的”、动态的 进程(Process)因此, 进程是一个动态变化的过程,是一出有始有终的戏而程序文件只是这一系列动作的原始蓝本,是一个静态的剧本  进程就是程序在内存中 动态执行的过程 进程是系统资源管理的 最小的单位 进程是动态">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/11/04/uPLWIx6z9NqDJvg.jpg">
<meta property="article:published_time" content="2022-02-13T02:59:47.000Z">
<meta property="article:modified_time" content="2022-11-04T09:41:18.111Z">
<meta property="article:author" content="木木想去北海种花">
<meta property="article:tag" content="Linux网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/11/04/uPLWIx6z9NqDJvg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mumu-lsl.github.io/posts/716f0d9b/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux多进程编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-04 17:41:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/11/04/uPLWIx6z9NqDJvg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lin's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux多进程编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-13T02:59:47.000Z" title="发表于 2022-02-13 10:59:47">2022-02-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-04T09:41:18.111Z" title="更新于 2022-11-04 17:41:18">2022-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux多进程编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>一个程序文件, 只是一堆待执行的代码和部分待处理的数据<br>它们只有被加载到内存中,然后让CPU逐条执行其代码,根据代码做出相应的动作,才形成一个真正“活的”、动态的 进程(Process)<br>因此, 进程是一个动态变化的过程,是一出有始有终的戏<br>而程序文件只是这一系列动作的原始蓝本,是一个静态的剧本</p>
<ol>
<li>进程就是程序在内存中 动态执行的过程</li>
<li>进程是系统资源管理的 最小的单位</li>
<li>进程是动态的概念, 创建—运行–消亡</li>
<li>每个进程有 4G独立的进程空间,其中0-3G是用户空间,3G-4G是内核空间。 每个进程也有4G地址空间的，仅仅是地址空间，不是实际的内存，需要使用时向系统申请</li>
<li>进程是独立可调度的任务,绝大多数的操作系统都支持多进程</li>
</ol>
<h3 id="Linux中的三个特殊进程"><a href="#Linux中的三个特殊进程" class="headerlink" title="Linux中的三个特殊进程"></a>Linux中的三个特殊进程</h3><p>Linux中的进程都是由其它进程启动。如果进程a启动了进程b, 所以称a是b的父进程, b是a的子进程</p>
<p>Linux下有3个特殊的进程，idle进程(PID &#x3D; 0), init进程(PID &#x3D; 1)和kthreadd(PID &#x3D; 2)</p>
<ol>
<li><strong>idle进程由系统自动创建, 运行在内核态</strong></li>
</ol>
<p>idle进程其pid&#x3D;0，其前身是系统创建的第一个进程，也是唯一一个没有通过fork或者kernel_thread产生的进程。完成加载系统后，演变为进程调度、交换</p>
<ol start="2">
<li><strong>init进程由idle通过kernel_thread创建，在内核空间完成初始化后, 加载init程序, 并最终转向用户空间</strong></li>
</ol>
<p>由0进程创建，完成系统的初始化. 是系统中所有其它用户进程的祖先进程，首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成完成后，init将变为守护进程监视系统其他进程。</p>
<ol start="3">
<li><strong>kthreadd进程由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理</strong></li>
</ol>
<p>它的任务就是管理和调度其他内核线程kernel_thread, 会循环执行一个kthread的函数，该函数的作用就是运行kthread_create_list全局链表中维护的kthread, 当我们调用kernel_thread创建的内核线程会被加入到此链表中，因此所有的内核线程都是直接或者间接的以kthreadd为父进程</p>
<p>参见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/8526970.html">linux的0号进程和1号进程 - AlanTu - 博客园 (cnblogs.com)</a></p>
<h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><p><img src="https://s2.loli.net/2022/02/15/GBNThtrXHYIzsRM.png" alt="img"></p>
<p> 就绪状态: 未占到CPU, 进程准备好了,等待系统调度器调度。<br> 运行状态: 占到CPU  , 已经开始运行。<br> 暂停状态: 没占,收到外部暂停信号,暂停运行 (不在参与任务调度)<br> 挂起(睡眠)状态: IO资源不满足, 导致进程睡眠。 (不在参与任务调度)(例如键盘输入)<br> 僵尸状态: 进程已经结束, 但是资源(内存、硬件接口)没有回收。</p>
<h3 id="Linux的进程地址空间"><a href="#Linux的进程地址空间" class="headerlink" title="Linux的进程地址空间"></a>Linux的进程地址空间</h3><p><img src="https://s2.loli.net/2022/02/15/oRnFS2iuxby8Zre.jpg" alt="img"></p>
<p>**程序段(Text):**程序代码在内存中的映射，存放函数体的二进制代码。</p>
<p>**初始化过的数据(Data):**在程序运行初已经对变量进行初始化的数据。</p>
<p>**未初始化过的数据(BSS):**在程序运行初未对变量进行初始化的数据。</p>
<p>**栈 (Stack):**存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈。</p>
<p>**堆 (Heap):**存储动态内存分配,需要程序员手工分配,手工释放.注意它与数据结构中的堆是两回事，分配方式类似于链表。</p>
<p>  Linux的虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分， 将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，称为“用户空间。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p>
<p>  Linux使用两级保护机制：0级供内核使用，3级供用户程序使用，每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的，最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。<br>  内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。 虽然内核空间占据了每个虚拟空间中的最高1GB字节，但映射到物理内存却总是从最低地址（0x00000000），另外， 使用虚拟地址可以很好的保护 内核空间被用户空间破坏，虚拟地址到物理地址转换过程有操作系统和CPU共同完成(操作系统为CPU设置好页表，CPU通过MMU单元进行地址转换)。</p>
<blockquote>
<p>多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盒中，这个 沙盒就是虚拟地址空间（virtual address space），在32位模式下，它总是一个4GB的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每个进程都拥有一套属于它自己的页表。</p>
</blockquote>
<p>  Linux系统对自身进行了划分，一部分核心软件独立于普通应用程序，运行在较高的特权级别上，它们驻留在被保护的内存空间上，拥有访问硬件设备的所有权限，Linux将此称为内核空间。<br>    相对地，应用程序则是在“用户空间”中运行。运行在用户空间的应用程序只能看到允许它们使用的部分系统资源，并且不能使用某些特定的系统功能，也不能直接访问内核空间和硬件设备，以及其他一些具体的使用限制。<br>    将用户空间和内核空间置于这种非对称访问机制下有很好的安全性，能有效抵御恶意用户的窥探，也能防止质量低劣的用户程序的侵害，从而使系统运行得更稳定可靠。</p>
<p>​       内核空间在页表中拥有较高的特权级（ring2或以下），因此只要用户态的程序试图访问这些页，就会导致一个页错误（page fault）。在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存，内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与之相反，用户模式地址空间的映射随着进程切换的发生而不断的变化</p>
<p>更多请参考：[Linux的进程地址空间<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66794639">一] - 知乎 (zhihu.com)</a></p>
<h3 id="堆栈的比较"><a href="#堆栈的比较" class="headerlink" title="堆栈的比较"></a>堆栈的比较</h3><p><img src="https://s2.loli.net/2022/02/15/ektLo653g9KE74X.png" alt="img"></p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数的每次调用都会返回两次，在父进程中返回的是子进程的PID，在子进程中则返回0。所以可以利用返回值来判断是子进程还是父进程，fork调用失败时，返回-1，并设置errno。fork函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性和原进程相同，比如堆指针、栈指针和标志寄存器的值。但该进程的PPID被设置成原进程的PID，信号位图被清除（元进程设置的信号处理函数不再对新进程起作用）。</p>
<p>子进程的代码和父进程完全相同，同时它还会复制父进程的数据（堆数据、栈数据和静态数据）。数据的复制采用的是写时复制（copy on write），即只有在任一进程（父进程或子进程）对数据执行了写操作时，复制才会发生（先是缺页中断，然后操作系统给子进程分配内存并复制父进程的数据）</p>
<p>此外，创建子进程后，父进程中打开的文件描述符默认在子进程中也是打开的，且文件描述符的引用计数加1，不仅如此，父进程的用户根目录、当前工作目录等变量的引用计数均会加1。</p>
<p><img src="https://s2.loli.net/2022/02/15/laSi5kdwFHcAtLT.jpg" alt="img"></p>
<p>上图是父进程的进程空间,其中代码段是不会不复制到子进程的,而是共享,其它段需要复制,属于写拷贝 (即只有改的时候, 才需要拷贝),这样提高效率, 节省资源,总而言之,<strong>相当于克隆了一个自己</strong></p>
<p>现在我们要让它们分别干不同的事,在fork函数执行完毕后,则有两个进程，一个是子进程，一个是父进程,在子进程中，fork函数返回0，在父进程中，fork返回子进程的进程ID,因此, 我们可以通过fork返回的值来判断当前进程是子进程还是父进程,从而让它们<strong>同时干不同的事情</strong></p>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><p>有时需要在子进程中执行其他程序，即替换当前进程映像，这就需要使用如下exec系列函数之一</p>
<p>用fork函数创建子进程后，子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用一个全新的程序替换了当前进程的正文、数据、堆和栈段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ... )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* arg, ... )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ... , <span class="type">char</span>* <span class="type">const</span> envp[] )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[] )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> argv[] )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[] )</span></span>;</span><br></pre></td></tr></table></figure>

<p>path参数指定可执行文件的完整参数，file参数可以接受文件名，该文件的具体位置则在环境变量PATH中搜寻。arg接受可变参数，argv则接受参数数组，它们都会被传递给新程序（path或file指定的程序）的main函数。envp参数用于设置新程序的环境变量。如果未设置它，则新程序将使用由全局变量environ指定的环境变量。</p>
<p>一般情况下，exec函数是不返回的，除非出错。它出错时返回-1，并设置errno。如果没出错，则原程序中exec调用之后的代码都不会执行。因为此时原程序已经被exec的参数指定的程序完全替换（包括代码和数据）。</p>
<p>exec函数不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC的属性。</p>
<h2 id="处理僵尸进程"><a href="#处理僵尸进程" class="headerlink" title="处理僵尸进程"></a>处理僵尸进程</h2><p>在linux下，如果一个进程终止，内核会释放该进程使用的所有存储区，关闭所有文件句柄等，但是，内核会为每个终止子进程保留一定量的信息。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间。当终止子进程的父进程调用wait或waitpid时就可以得到这些信息</p>
<p>僵尸进程指：一个进程退出后，而其父进程并没有为它收尸(调用wait或waitpid来获得它的结束状态)的进程</p>
<p>任何一个子进程(init除外)在退出后并非马上就消失，而是留下一个称为僵尸进程的数据结构，等待父进程处理。这是每个子进程都必需经历的阶段。另外子进程退出的时候会向其父进程发送一个SIGCHLD信号</p>
<p>作用</p>
<p>设置僵死状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）</p>
<p>僵尸态：</p>
<ul>
<li>case1：在子进程结束运行后，父进程读取其退出状态前的过程。（对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。因此，当子进程结束运行时，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程退出信息的查询（如果父进程还在运行）</li>
<li>case2：父进程结束或者异常终止，而子进程继续运行。此时子进程的PPID将被操作系统设置为1，即init进程。init进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态。</li>
</ul>
<p>如果父进程没有正确地处理子进程地返回信息，子进程都将停留在僵尸态，并占用内核资源。</p>
<p>下面这对函数在父进程中调用，以等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程的产生，或者使子进程的僵尸态立即结束</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span>* stat_loc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">( <span class="type">pid_t</span> pid, nt* stat_loc, <span class="type">int</span> options )</span></span>;</span><br></pre></td></tr></table></figure>

<p>wait 函数将阻塞进程，直到该进程的某个子进程结束运行位置。它返回结束运行的子进程的PID，并将该子进程的退出状态信息存储于stat_loc参数指向的内存中。sys&#x2F;wait.h头文件中定义了几个宏来帮助解释子进程的退出状态信息。</p>
<p><img src="https://s2.loli.net/2022/02/15/yKSsNCnMmHarlJq.png" alt="image-20220215224526707"></p>
<p><strong>僵尸进程的避免</strong></p>
<p>⒈父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。</p>
<p>⒉ 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信号，可以在handler中调用wait回收。</p>
<p>⒊ 如果<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%88%B6%E8%BF%9B%E7%A8%8B">父进程</a>不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN） 通知<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8">内核</a>，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。</p>
<p>⒋ 还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一 个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>pipe除了可以用于进程于进程之间通信外，还可以用于父进程与子进程间的通信。</p>
<p>管道能在父、子进程间传递数据，利用的是fork调用之后两个管道文件描述符（fd[0] 和 fd[1]）都保持打开。一对这样的文件描述符只能保证父、子进程间一个方向的数据传输，父进程和子进程必须都有一个关闭fd[0] ，另一个关闭fd[1]。比如，通过管道实现从父进程向子进程写数据。<br><img src="https://s2.loli.net/2022/02/15/4zRYZjifcoTnwBS.png" alt="image-20220215225819856"></p>
<blockquote>
<p>管道只能用于有关联的两个进程（如父子进程）间的通信。</p>
</blockquote>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="信号量原语"><a href="#信号量原语" class="headerlink" title="信号量原语"></a>信号量原语</h3><p>信号量概念是并发编程中的重要概念，信号量是一种特殊的变量，他只能取自然数并且只支持两种操作：P（进入临界区），V(释放)。假设有信号量SV，则对他的P，V操作含义如下：</p>
<p>P（SV）： 如果SV的值大于0，就将它减一；如果SV操作的值为0，则挂起进程的执行</p>
<p>V（SV）：如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则将SV加一</p>
<blockquote>
<p>使用一个普通变量来模拟二进制信号量是行不通的，因为所有高级语言都没有一个原子操作可以同时完成如下两步操作：检测变量是否为true&#x2F;false, 如果是则将它设置为false&#x2F;true。</p>
</blockquote>
<p>Linux的信号量的API都定义在sys&#x2F;sem.h头文件中，主要包含3个系统调用：semget、semop 和 semctl。它们都被设计为操作一组信号量，即信号量集，而不是单个信号量。</p>
<h3 id="semget系统调用"><a href="#semget系统调用" class="headerlink" title="semget系统调用"></a>semget系统调用</h3><p>semget系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">( <span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>key参数是一个键值，用来标识一个全局唯一的信号量集，就像文件名全局唯一地标识一个文件一样。要通过信号量通信的进程需要使用相同的键值来创建&#x2F;获取该信号量。</p>
</li>
<li><p>num_sems参数指定要创建&#x2F;获取的信号量集中信号量的数目。如果是创建信号量，则该值必须被指定；如果是获取已经存在的信号量，则可以把它设置为0。</p>
</li>
<li><p>sem_flags参数指定一组标志。它低端的9个比特是该信号量的权限，其格式和含义都与系统调用open的mode参数相同。</p>
</li>
</ul>
<p>semget成功时返回一个正整数值，它是信号量集的标识符；semget失败时返回-1，并设置errno。</p>
<p>如果semget用于创建信号量集，则与之关联的内核数据结构体semid_ds将被创建并初始化。</p>
<h3 id="semop系统调用"><a href="#semop系统调用" class="headerlink" title="semop系统调用"></a>semop系统调用</h3><p>semop系统调用改变信号量的值，即执行P、V操作。其相关的内核变量如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semval;    <span class="comment">// 信号量的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semzcnt;    <span class="comment">// 等待信号量变为0的进程数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semncnt；    <span class="comment">// 等待信号量值增加的进程数量</span></span><br><span class="line"><span class="type">pid_t</span> sempid;               <span class="comment">// 最后一次执行semop操作的进程ID</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//semop对信号量的操作实际上就是对这些内核变量的操作。semop的定义如下：</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">( <span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf* sem_ops, <span class="type">size_t</span> num_sem_ops )</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sem_id参数是由semget调用返回的信号量集标识符，用以指定被操作的目标信号量集。</span></span><br><span class="line"><span class="comment">sem_ops参数指定一个sembuf结构体类型的数组，sembuf结构体的定义如下：*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sem_num;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sem_op;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sem_flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="semctl系统调用"><a href="#semctl系统调用" class="headerlink" title="semctl系统调用"></a>semctl系统调用</h3><p>semctl系统调用允许调用者对信号量进行直接控制。其定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">( <span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command, ... )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>sem_id参数是由semget调用返回的信号量集标识符，用以指定被操作的信号量集。</li>
<li>sem_num参数指定被操作的信号量在信号量集中的编号。</li>
<li>command参数指定要执行的命令。</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是最高效的IPC机制，因为它不涉及进程之间的任何数据传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步对共享内存的访问，否则会产生竞态条件</p>
<p>Linux共享内存的API都定义在 sys&#x2F;shm.h头文件中。包括4个系统效用：shmget、shmat、shmdt、和 shmctl。</p>
<h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">( <span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg )</span></span>;</span><br></pre></td></tr></table></figure>

<p>key参数是一个键值，用来标识一段全局唯一的共享内存。</p>
<p>size参数指定共享内存的大小，单位是字节。（如果是创建新的共享内存，则size值必须被指定。如果获取已经存在的共享内存，则可以把size设置为0）</p>
<p>shmflg参数的使用和含义与semget系统调用的sem_flags参数相同。不过shmflag支持两个额外的标志：</p>
<p>shmget成功时返回一个正整数值，它是共享内存的标识符。shmget失败时返回-1，并设置errno。</p>
<h3 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h3><p>共享内存被创建&#x2F;获取之后，我们不能立即访问它，而是需要先将它关联到进程的地址空间中。使用完共享内存之后，还需要将它从进程地址空间中分离。这两项任务是由如下两个系统调用来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">shmat</span><span class="params">( <span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span>* shm_addr, <span class="type">int</span> shmflg )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">( <span class="type">const</span> <span class="type">void</span>* shm_addr )</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h3><p>shmctl系统调用控制共享内存的某些属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">( <span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds* buf )</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>作用：两个进程之间传递二进制块数据的一种方式，简单有效。</p>
<p>特点：每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，不一定像管道和命名管道那样必须先进先出的方式接收数据。</p>
<p>相关的API定义在sys&#x2F;msg.h中，包括四个系统调用：msgget、msgsnd、msgrcv、msgctl</p>
<h3 id="msgget"><a href="#msgget" class="headerlink" title="msgget"></a>msgget</h3><p>msgget系统调用创建一个消息队列，或者获取一个已有的消息队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span> <span class="params">( <span class="type">key_t</span> key, <span class="type">int</span> msgflg )</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>key：标识一个全局唯一的消息队列。</p>
<p>msgflg：和semget系统调用的sem_flags参数相同, 与内核数据结构msqid_ds相关联。</p>
<p>成功时返回一个正整数值，它是消息队列的标识符。msgget失败时返回-1，并设置errno。</p>
<h3 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd"></a>msgsnd</h3><p>msgsnd系统调用：</p>
<p>作用：把一条消息添加到消息队列中。</p>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span>;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span> <span class="params">( <span class="type">int</span> msgid, <span class="type">const</span> <span class="type">void</span>* msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>msgid：由msgget函数返回的消息队列标识符。</li>
<li>msg_ptr：指向一个准备发送的消息，消息必须被定义为如下的类型：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msgbuf</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> mtype; <span class="comment">// 消息类型</span></span><br><span class="line">	<span class="type">char</span> mtext[<span class="number">512</span>]; <span class="comment">// 消息数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>msgflg：控制msgsnd的行为。它通常仅支持IPC_NOWAIT标志，即以非阻塞的方式发送消息。默认情况下，发送消息时如果消息队列满了，则msgsnd函数将阻塞。若IPC_NOWAIT标志被指定，则msgsnd将立即返回并设置errno 为EAGAIN。</li>
</ul>
<p>处于阻塞状态的msgsnd调用可能被如下两种异常情况所中断:</p>
<ul>
<li><strong>消息队列被移除</strong>。此时msgsnd调用将立即返回并设置errno为<em><strong>EIDRM</strong></em></li>
<li><strong>程序接收到信号。</strong>此时msgsnd调用将立即返回并设置errno为<em><strong>EINTR。</strong></em></li>
</ul>
<p>msgsnd成功时返回0，失败时返回-1并设置errno。 msgsnd成功将修改内核数据结构msqid_ds的部分字段。</p>
<h3 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv"></a>msgrcv</h3><p>msgrcv系统调用从消息队列中获取消息。其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgrcv</span> <span class="params">( <span class="type">int</span> msqid, <span class="type">void</span>* msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>msqid：</strong>由msgget调用返回的消息队列标识符。</li>
<li><strong>msg_ptr：</strong>用于存储接收的消息。</li>
<li><strong>msg_sz：</strong>指的是消息数据部分的长度。</li>
<li><strong>msgtype：</strong>指定接收何种类型的消息，可以如下几种方式：（1） msgtype 等于0 。读取消息队列中的第一个消息。 （2）msgtype大于0 。读取消息队列中第一个类型为msgtype的消息。 （3）msgtype 小于0 。读取消息队列中第一个类型值比msgtype的绝对值小的消息。</li>
<li><strong>msgflg</strong>：控制msgrcv 函数的行为。它可以是如下一些标志的按位或：（1）IPC_NOWAIT，如果消息队列中没有任何消息，则msgrcv调用立即返回并设置errno为ENOMSG。（2）MSG_EXCEPT，如果msgtype大于0，则接收消息队列中第一个非msgtype 类型的消息。 （3）MSG_NOERROR，如果消息数据部分的长度超过了msg_sz，就将它截断。</li>
</ul>
<h3 id="msgctl"><a href="#msgctl" class="headerlink" title="msgctl"></a>msgctl</h3><p>msgctl 系统调用控制消息队列的某些属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span> <span class="params">( <span class="type">int</span> msqid, <span class="type">int</span> command, <span class="keyword">struct</span> msqid_ds* buf )</span></span>;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">木木想去北海种花</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mumu-lsl.github.io/posts/716f0d9b/">https://mumu-lsl.github.io/posts/716f0d9b/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mumu-lsl.github.io" target="_blank">Lin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Linux网络编程</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/04/uPLWIx6z9NqDJvg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/341a9d02/"><img class="prev-cover" src="https://s2.loli.net/2022/11/04/hHvKneugsCO7Rb5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux多线程编程</div></div></a></div><div class="next-post pull-right"><a href="/posts/f4bfb319/"><img class="next-cover" src="https://smms.app/image/sog2J4pY6hmNDFq" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">同时监听TCP与UDP端口</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/5c237c5f/" title="IO复用"><img class="cover" src="https://images.unsplash.com/photo-1592561199818-6b69d3d1d6e2?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTh8fGNhcnRvb258ZW58MHx8MHx8&auto=format&fit=crop&w=500&q=60" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-10</div><div class="title">IO复用</div></div></a></div><div><a href="/posts/341a9d02/" title="Linux多线程编程"><img class="cover" src="https://s2.loli.net/2022/11/04/hHvKneugsCO7Rb5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-15</div><div class="title">Linux多线程编程</div></div></a></div><div><a href="/posts/16108/" title="Linux高性能服务器编程"><img class="cover" src="https://plus.unsplash.com/premium_photo-1661510050360-b8447baf1963?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MXx8Y2FydG9vbnxlbnwwfHwwfHw%3D&auto=format&fit=crop&w=500&q=60" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-09</div><div class="title">Linux高性能服务器编程</div></div></a></div><div><a href="/posts/f02c82f1/" title="poll应用——聊天室程序"><img class="cover" src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="title">poll应用——聊天室程序</div></div></a></div><div><a href="/posts/2e29b6af/" title="select应用——非阻塞connect"><img class="cover" src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="title">select应用——非阻塞connect</div></div></a></div><div><a href="/posts/f4bfb319/" title="同时监听TCP与UDP端口"><img class="cover" src="https://smms.app/image/sog2J4pY6hmNDFq" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="title">同时监听TCP与UDP端口</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">木木想去北海种花</div><div class="author-info__description">Lin在此创作, 欢迎各位</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mumu-LSL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/zumumu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">多进程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E6%AE%8A%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">Linux中的三个特殊进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">进程的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.4.</span> <span class="toc-text">Linux的进程地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.5.</span> <span class="toc-text">堆栈的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork"><span class="toc-number">1.2.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">1.3.</span> <span class="toc-text">exec函数族</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">处理僵尸进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.5.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.6.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.6.1.</span> <span class="toc-text">信号量原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#semget%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">semget系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#semop%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">semop系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#semctl%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">semctl系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">1.7.</span> <span class="toc-text">共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shmget"><span class="toc-number">1.7.1.</span> <span class="toc-text">shmget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shmat"><span class="toc-number">1.7.2.</span> <span class="toc-text">shmat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shmctl"><span class="toc-number">1.7.3.</span> <span class="toc-text">shmctl</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.8.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#msgget"><span class="toc-number">1.8.1.</span> <span class="toc-text">msgget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#msgsnd"><span class="toc-number">1.8.2.</span> <span class="toc-text">msgsnd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#msgrcv"><span class="toc-number">1.8.3.</span> <span class="toc-text">msgrcv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#msgctl"><span class="toc-number">1.8.4.</span> <span class="toc-text">msgctl</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/f8540c8f/" title="高性能">高性能</a><time datetime="2022-11-04T07:59:50.000Z" title="发表于 2022-11-04 15:59:50">2022-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/c783f2ce/" title="计算机基础">计算机基础</a><time datetime="2022-11-04T07:59:34.000Z" title="发表于 2022-11-04 15:59:34">2022-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/5cf1c465/" title="分布式系统概述">分布式系统概述</a><time datetime="2022-11-04T07:59:24.000Z" title="发表于 2022-11-04 15:59:24">2022-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/766433e0/" title="SSM框架">SSM框架</a><time datetime="2022-11-04T07:59:06.000Z" title="发表于 2022-11-04 15:59:06">2022-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/96a41905/" title="SpringCloud">SpringCloud</a><time datetime="2022-11-04T07:58:50.000Z" title="发表于 2022-11-04 15:58:50">2022-11-04</time></div></div></div></div></div></div></main><footer id="footer" style="background: -rgb(0,0,255)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 木木想去北海种花</div><div class="footer_custom_text">所有你乐于挥霍的时间，都不能算作浪费</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="null" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>