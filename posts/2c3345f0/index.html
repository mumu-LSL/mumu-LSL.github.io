<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java技术原理 | Lin's Blog</title><meta name="keywords" content="javaSE"><meta name="author" content="木木想去北海种花"><meta name="copyright" content="木木想去北海种花"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java基础参考：JournalDev - Java, Java EE, Android, Python, Web Development Tutorials new 的过程Object o&#x3D;new Object(); 首先JVM会启动，你的代码会编译成一个.class文件，然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，">
<meta property="og:type" content="article">
<meta property="og:title" content="Java技术原理">
<meta property="og:url" content="https://mumu-lsl.github.io/posts/2c3345f0/index.html">
<meta property="og:site_name" content="Lin&#39;s Blog">
<meta property="og:description" content="java基础参考：JournalDev - Java, Java EE, Android, Python, Web Development Tutorials new 的过程Object o&#x3D;new Object(); 首先JVM会启动，你的代码会编译成一个.class文件，然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg">
<meta property="article:published_time" content="2022-05-24T15:13:57.000Z">
<meta property="article:modified_time" content="2022-05-24T15:20:50.947Z">
<meta property="article:author" content="木木想去北海种花">
<meta property="article:tag" content="javaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mumu-lsl.github.io/posts/2c3345f0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java技术原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-24 23:20:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lin's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java技术原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-24T15:13:57.000Z" title="发表于 2022-05-24 23:13:57">2022-05-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-24T15:20:50.947Z" title="更新于 2022-05-24 23:20:50">2022-05-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java技术原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><p>参考：<a target="_blank" rel="noopener" href="https://www.journaldev.com/">JournalDev - Java, Java EE, Android, Python, Web Development Tutorials</a></p>
<h2 id="new-的过程"><a href="#new-的过程" class="headerlink" title="new 的过程"></a>new 的过程</h2><p>Object o&#x3D;new Object();</p>
<p>首先JVM会启动，你的代码会编译成一个.class文件，然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，初始化也就是代码:new Object()。</p>
<p><img src="https://s2.loli.net/2022/04/21/wlEnchZK3Xi6AUe.jpg" alt="preview"></p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p><img src="https://s2.loli.net/2022/04/21/6ECWYB2paN7RULQ.jpg" alt="img"></p>
<p><strong>1、Loading（加载）</strong><br>”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：<br>（1）通过一个类的全限定名来获取其定义的二进制字节流。<br>（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。<br>（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。</p>
<p>相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载。我们在最后一部分会详细介绍这个类加载器。</p>
<p><strong>java虚拟机Class对象是放在 方法区 还是堆中</strong></p>
<p>Class对象是存放在堆区的，不是方法区，这点很多人容易犯错。类的元数据（元数据并不是类的Class对象！Class对象是加载的最终产品，<strong>类的方法代码</strong>，<strong>变量名，方法名，访问权限，返回值</strong>等等都是在方法区的）才是存在方法区的。static成员变量被放在Class对象中</p>
<h2 id="final-、finally-、finalize三个关键字的区别："><a href="#final-、finally-、finalize三个关键字的区别：" class="headerlink" title="final 、finally 、finalize三个关键字的区别："></a>final 、finally 、finalize三个关键字的区别：</h2><hr>
<p>final：修饰符（关键字）有三种用法：修饰类、变量和方法。</p>
<ul>
<li>修饰类时，意味着它不能再派生出新的子类，即不能被继承。</li>
<li>修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
<li>修饰方法时，也同样只能使用，不能在子类中被重写，private 方法隐式地被指定为 final。</li>
</ul>
<p>finally：通常放在 try…catch 的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中。</p>
<p>finalize：Object 类中定义的方法，Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string">java 中String的更多问题</a></p>
<hr>
<p><img src="https://s2.loli.net/2022/04/27/vZn1b3Yok8zaGqV.png" alt="img"></p>
<p><strong>String的不可变性</strong></p>
<p> 我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<p><strong>不可变的好处：</strong></p>
<ul>
<li>满足字符串常量池的需要（有助于共享）<br>可以将字符串对象保存在字符串常量池中以供与字面值相同字符串对象共享。<br>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。<br>如果String对象是可变的，那就不能这样共享，因为一旦对某一个String类型变量引用的对象值改变，将同时改变一起共享字符串对象的其他 String类型变量所引用的对象的值。</li>
<li>线程安全考虑<br>同一个字符串实例可以被多个线程共享。字符串的不变性保证字符串本身便是线程安全的。</li>
<li>支持hash映射和缓存<br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得String很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</li>
</ul>
<p><strong>缺点：</strong>String对象不适用于经常发生修改的场景，会创建大量的String对象。</p>
<p><strong>String 的不可变 真的不可变？</strong><br>通过反射获取value数组直接改变内存数组中的数据是可以修改所谓的”不可变”对象的</p>
<p><strong>可变性</strong><br>String 不可变<br>StringBuffer 和 StringBuilder 可变</p>
<p><strong>线程安全</strong><br>String 不可变，因此是线程安全的<br>StringBuilder 不是线程安全的<br>StringBuffer 是线程安全的（影响效率），内部使用 synchronized 进行同步</p>
<p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p>
<p>新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p>
<p><strong>字符串拼接用“+” 还是 StringBuilder?</strong></p>
<p>Java 语言本身并不支持运算符重载，“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的元素符。对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p><strong>intern 方法有什么作用?</strong></p>
<p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<p><strong>String 类型的变量和常量做“+”运算时发生了什么？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;  <span class="comment">//常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2; <span class="comment">//在堆上创建的新对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;  <span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<h2 id="java的参数传递方式"><a href="#java的参数传递方式" class="headerlink" title="java的参数传递方式"></a>java的参数传递方式</h2><hr>
<ul>
<li>值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li>
<li>引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li>
</ul>
<p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<blockquote>
<p>Java is always <strong>pass-by-value</strong>. Unfortunately, when we deal with objects we are really dealing with object-handles called <em>references</em> which are passed-by-value as well. This terminology and semantics easily confuse many beginners.</p>
</blockquote>
<p>Java中的对象传递，<strong>Java会将对象的地址的拷贝传递给被调函数的形式参数。</strong> 在被调函数中如果是修改引用，是不会对原来的对象有任何影响的（类似于经典的值传递的例子），但是如果直接修改共享对象的属性的值，是会对原来的对象有影响的。例如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="java-异常"><a href="#java-异常" class="headerlink" title="java 异常"></a>java 异常</h2><p>异常的类型：</p>
<p>要理解Java异常处理是如何工作的，你需要掌握以下<strong>三种类型的异常：</strong></p>
<ul>
<li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/690102/201607/690102-20160728164909622-1770558953.png" alt="img"></p>
<p><strong>java异常处理的关键字：</strong></p>
<p>Java异常处理涉及到五个关键字，分别是：<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>、<code>throws</code>。下面将骤一介绍，通过认识这五个关键字，掌握基本异常处理知识。</p>
<p>　　• <strong>try</strong>     – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。<br>　　• <strong>catch</strong>  – 用于捕获异常。catch用来捕获try语句块中发生的异常。<br>　　• <strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。<br>　　• <strong>throw</strong>  – 用于抛出异常。<br>　　• <strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</p>
<p><strong>异常处理的本质：</strong></p>
<p>Java的异常处理本质上是<strong>抛出异常</strong>和<strong>捕获异常</strong>。</p>
<ul>
<li>**<code>抛出异常</code>**：要理解抛出异常，首先要明白什么是异常情形（exception condition），它是指阻止当前方法或作用域继续执行的问题。其次把异常情形和普通问题相区分，普通问题是指在当前环境下能得到足够的信息，总能处理这个错误。对于异常情形，已经无法继续下去了，因为在当前环境下无法获得必要的信息来解决问题，你所能做的就是从当前环境中跳出，并把问题提交给上一级环境，这就是抛出异常时所发生的事情。抛出异常后，会有几件事随之发生。首先，是像创建普通的java对象一样将使用<code>new</code>在堆上创建一个异常对象；然后，当前的执行路径（已经无法继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序，这个恰当的地方就是异常处理程序或者异常处理器，它的任务是将程序从错误状态中恢复，以使程序要么换一种方式运行，要么继续运行下去。</li>
<li>**<code>捕获异常</code>**：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id><a href="#" class="headerlink" title></a></h3><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p>
<p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;调用时传入具体的类型（类型实参）。</strong></p>
<p>泛型只在编译阶段有效。在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。<strong>对此总结成一句话：</strong>泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
<p><code>Generic&lt;Integer&gt;</code>不能被看作为<code>Generic&lt;Number&gt;</code>的子类。由此可以看出:<strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong>。</p>
<h3 id="Java的泛型是如何工作的-什么是类型擦除"><a href="#Java的泛型是如何工作的-什么是类型擦除" class="headerlink" title="Java的泛型是如何工作的 ? 什么是类型擦除 ?"></a>Java的泛型是如何工作的 ? 什么是类型擦除 ?</h3><p>编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。</String></p>
<p><strong>各种语言的编译器处理泛型的方式：</strong></p>
<p>1.Code specialization。在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型list，可能需要 针对string，integer，float产生三份目标代码。</p>
<p>2.Code sharing。对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。</p>
<p>C++ 中的模板（template）是典型的Code specialization实现。 C++ 编译器会为每一个泛型类实例生成一份执行代码。执行代码中integer list和string list是两种不同的类型。这样会导致 代码膨胀（code bloat） Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经被替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>就是同一个类。所以说泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为 类型擦除 ，基于这种方法实现的泛型被称为伪泛型。</String></int></p>
<p><strong>类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。</strong>编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。 类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。（这部分内容可以看：Java泛型中extends和super的理解） 2.移除所有的类型参数。</p>
<h3 id="泛型中的限定通配符和非限定通配符"><a href="#泛型中的限定通配符和非限定通配符" class="headerlink" title="泛型中的限定通配符和非限定通配符 ?"></a>泛型中的限定通配符和非限定通配符 ?</h3><p>限定通配符对类型进行了限制。有两种限定通配符，一种是**<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>**表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代</p>
<h2 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析Java反射</a></p>
<p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p>反射的核心是 JVM 在运行时才动态加载类或调用方法&#x2F;访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p><strong>反射最重要的用途就是开发各种通用框架。</strong>很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p>
<p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解Annotation实现原理与自定义注解例子 - 贾树丙 - 博客园 (cnblogs.com)</a></p>
<p><em><strong>Annontation</strong></em>是Java5开始引入的新特征，中文名称叫<strong>注解</strong>。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。<br>Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。</p>
<ol>
<li>生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等</li>
<li>跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2 依赖注入，未来java 开发，将大量注解配置，具有很大用处;</li>
<li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</li>
</ol>
<p>注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。</p>
<img src="https://s2.loli.net/2022/04/25/UX3pNjCTaKy6q7Q.jpg" alt="img" style="zoom:67%;">

<p><strong>(1) 1 个 Annotation 和 1 个 RetentionPolicy 关联。</strong></p>
<p>可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。</p>
<ul>
<li>a) 若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li>
<li>b) 若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li>
<li>c) 若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li>
</ul>
<p><strong>(2) 1 个 Annotation 和 1~n 个 ElementType 关联。</strong></p>
<p>可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。<strong>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。</strong>当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个 Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。</p>
<p><strong>(3) Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</strong></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><hr>
<p>Java 集合可分为 <strong>Collection</strong> 和 <strong>Map</strong> 两种体系</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3> <img src="https://s2.loli.net/2022/04/28/XlbNUfTRVHePWJC.png" alt="img" style="zoom: 67%;">

<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h4><ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的，<strong>已经被弃用了</strong>。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
<li>ArrayDeque ：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenglc/p/10722304.html">ArrayDeque类的使用详解 - 路迢迢 - 博客园 (cnblogs.com)</a></li>
</ul>
<img src="https://img2020.cnblogs.com/blog/1182288/202108/1182288-20210820071846483-1916174431.png" alt="img" style="zoom:50%;">

<p><strong>使用建议：</strong></p>
<ul>
<li>如果想实现「普通队列 - 先进先出」的语义，就使用 LinkedList 或者 ArrayDeque 来实现；</li>
<li>如果想实现「优先队列」的语义，就使用 PriorityQueue；</li>
<li>如果想实现「栈」的语义，就使用 ArrayDeque。</li>
</ul>
<p>我们一个个来看。</p>
<p>在实现普通队列时，<strong>如何选择用 LinkedList 还是 ArrayDeque 呢？</strong></p>
<p>总结来说就是推荐使用 ArrayDeque，因为效率高，而 LinkedList 还会有其他的额外开销（overhead）。</p>
<p><strong>那 ArrayDeque 和 LinkedList 的区别有哪些呢？</strong></p>
<ol>
<li>ArrayDeque 是一个可扩容的数组，LinkedList 是链表结构；</li>
<li>ArrayDeque 里不可以存 null 值，但是 LinkedList 可以；</li>
<li>ArrayDeque 在操作头尾端的增删操作时更高效，但是 LinkedList 只有在当要移除中间某个元素且已经找到了这个元素后的移除才是 O(1) 的；</li>
<li>ArrayDeque 在内存使用方面更高效。</li>
</ol>
<p><strong>栈</strong></p>
<p>栈是一种先进后出的数据结构，在Java中对应的接口为 Deque，Stack接口已经不建议使用。Deque接口继承自Queue接口，实则为双端队列，支持两端元素的插入、删除与访问。<br>Deque的方法有:</p>
<p>首端操作：</p>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>查看</td>
<td>getFirst()</td>
<td>peekFrist()</td>
</tr>
<tr>
<td>插入</td>
<td>addFirst()</td>
<td>offerFirst()</td>
</tr>
<tr>
<td>删除</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
</tbody></table>
<p>尾端操作：</p>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>查看</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
<tr>
<td>插入</td>
<td>addLast()</td>
<td>offerLast()</td>
</tr>
<tr>
<td>删除</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
</tbody></table>
<p>栈方法对应的 Deque方法：</p>
<table>
<thead>
<tr>
<th></th>
<th>栈方法</th>
<th>Deque方法</th>
</tr>
</thead>
<tbody><tr>
<td>查看</td>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>插入</td>
<td>push()</td>
<td>addFirst()</td>
</tr>
<tr>
<td>删除</td>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
</tbody></table>
<p>Deque主要实现类有：</p>
<p><img src="https://s2.loli.net/2022/04/30/rtxu4T6bEoNzPcZ.png" alt="在这里插入图片描述"></p>
<p>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">deque.push(<span class="number">1</span>);</span><br><span class="line">deque.peek();</span><br><span class="line">deque.pop();</span><br></pre></td></tr></table></figure>






<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><img src="https://s2.loli.net/2022/04/25/EwHhDQAoxsd5e8L.png" alt="img" style="zoom: 67%;">

<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png" alt="img" style="zoom:67%;">





<h2 id="java引用"><a href="#java引用" class="headerlink" title="java引用"></a>java引用</h2><hr>
<p><strong>强引用</strong></p>
<p>强引⽤是使用最普遍的引用。如果⼀个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引⽤的对象来解决内存不足的问题。 </p>
<p><strong>软引用</strong></p>
<p>如果内存空间不足了，就会回收这些对象的内存。软引用可以和⼀个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加⼊到与之关联的引用队列中。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">sf.get();<span class="comment">//获取对象</span></span><br></pre></td></tr></table></figure>

<p><strong>软引用</strong></p>
<p>弱引⽤与软引用的区别在于：只具有弱引用的对象拥有更短暂的⽣命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，⼀旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。弱引⽤可以和⼀个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加⼊到与之关联的引用队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">wf.get();<span class="comment">//获取对象</span></span><br></pre></td></tr></table></figure>

<p><strong>虚引用（PhantomReference）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用队列</span></span><br><span class="line">ReferenceQueue&lt;String&gt; rq = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">// 幽灵引用</span></span><br><span class="line">PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>), rq);</span><br><span class="line"><span class="comment">// 永远为null（幽灵引用相当于无引用）</span></span><br><span class="line">pr.get();</span><br></pre></td></tr></table></figure>

<p>虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到⼀个系统通知。虚引用与软引用和弱引用的⼀个区别在于：虚引用<strong>必须</strong>和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收⼀个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加⼊到与之关联的引用队列中。</p>
<h2 id="java关键字作用"><a href="#java关键字作用" class="headerlink" title="java关键字作用"></a>java关键字作用</h2><hr>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><hr>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c8f997e7f75c">关键字 synchronized - 简书 (jianshu.com)</a></p>
<h2 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h2><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的<strong>任务</strong>，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line">	<span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">		<span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line">		<span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="string">&quot;] &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>] Attach Listener <span class="comment">//添加事件</span></span><br><span class="line">[<span class="number">4</span>] Signal Dispatcher <span class="comment">// 分发处理给 JVM 信号的线程</span></span><br><span class="line">[<span class="number">3</span>] Finalizer <span class="comment">//调用对象 finalize 方法的线程</span></span><br><span class="line">[<span class="number">2</span>] Reference Handler <span class="comment">//清除 reference 线程</span></span><br><span class="line">[<span class="number">1</span>] main <span class="comment">//main 线程,程序入口</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/04/28/GB43TryjhSQ6xIs.png" alt="img"></p>
<p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态</p>
<p><img src="https://s2.loli.net/2022/04/28/US9QhcKJCD72bOa.png" alt="Java 线程的状态 "></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换</p>
<p><img src="https://s2.loli.net/2022/04/28/Bo2XmLG8HEWgfRv.png" alt="Java 线程状态变迁 "></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED_WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<p><strong>线程的上下文切换</strong></p>
<p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>产生死锁的四个必要条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p><strong>如何预防和避免线程死锁?</strong></p>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p>synchronized 关键字特性：</p>
<ul>
<li><strong>原子性</strong>： 确保线程互斥地访问同步代码；</li>
<li><strong>可见性</strong>： 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>线程进入synchronized代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。</li>
<li><strong>有序性</strong>： 程序执行的顺序按照代码的先后顺序执行。在并发时，程序的执行可能会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。但是synchronized提供了有序性保证，这其实和as-if-serial语义有关。as-if-serial语义是指不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的，由于synchronized修饰的代码，同一时间只能被同一线程访问。那么可以认为是单线程执行的。所以可以保证其有序性。</li>
</ul>
<p>synchronized的3种使用方式：</p>
<ul>
<li>修饰实例方法：作用于当前实例加锁</li>
<li>修饰静态方法：作用于当前类对象加锁</li>
<li>修饰代码块：指定加锁对象，对给定对象加锁</li>
</ul>
<p>synchronized 修饰同步语句块的的情况</p>
<p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
<p>synchronized 修饰方法的的情况</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。    如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p>
<p>JDK1.6 之后的 synchronized 关键字底层做了哪些优化</p>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuqinglong/p/9945618.html">Java6及以上版本对synchronized的优化 )</a></p>
<p><strong>双重校验锁实现对象单例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//uniqueInstance 采用 volatile 关键字修饰也是很有必要。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*原理：</span></span><br><span class="line"><span class="comment">第一个判断是为了减少锁竞争，提升效率。第一次判断是在Synchronized同步代码块外，理由是单例模式只会创建一个实例，并通过getUniqueInstance方法返回singleton对象，所以如果已经创建了singleton对象，就不用进入同步代码块，不用竞争锁，直接返回前面创建的实例即可，这样大大提升效率。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二个是为了保证只创建一个实例对象。假若线程A通过了第一次判断，进入了同步代码块，但是还未执行，线程B就进来了（线程B获得CPU时间片），线程B也通过了第一次判断（线程A并未创建实例，所以B通过了第一次判断），准备进入同步代码块，但是B没有锁，会阻塞在获取锁的那个位置，最后会切换回A线程，A线程创建了实例，如果不加第二个判断，当切换回B线程时，B线程也会创建一个实例，这样的话就不是单例模式了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p>
<p>使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h2 id="ReentrantLock（可重入锁）"><a href="#ReentrantLock（可重入锁）" class="headerlink" title="ReentrantLock（可重入锁）"></a>ReentrantLock（可重入锁）</h2><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁，<strong>ReentrantLock与synchronized两者都是可重入锁</strong></p>
<p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。<code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），线程对象可以注册在指定的<code>Condition</code>中，<strong>从而可以有选择性的进行线程通知</strong>，在调度线程上更加灵活。</li>
</ul>
<h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013967628/article/details/85291748">https://blog.csdn.net/u013967628/article/details/85291748</a></p>
<p>​            <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/138819184">https://zhuanlan.zhihu.com/p/138819184</a></p>
<p>volatile 的主要作用有两点： </p>
<ul>
<li>保证变量的内存可见性 </li>
<li>禁止指令重排序</li>
</ul>
<p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile </code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li>
<li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性</strong></li>
</ul>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/298448987">并发理论基础：指令重排序问题 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/java-memory-model-2/">深入理解Java内存模型（二）——重排序_Java_程晓明_InfoQ精选文章</a></p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010445301/article/details/111322569">(185条消息) 史上最全ThreadLocal 详解_FMcGee的博客-CSDN博客_threadlocal</a></p>
<p>ThreadLocal叫做线程变量，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：</p>
<p>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来。<br>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题。<br>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
<p>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</p>
<img src="https://s2.loli.net/2022/05/02/1cVPIM3BCUehi7H.jpg" alt="ThreadLocal数据结构" style="zoom: 80%;">

<p><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p>
<p>线程池<strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个</strong>线程池**还维护一些基本统计信息，例如已完成任务的数量。</p>
<p><strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<p>Runnable与Callable接口：</p>
<p><strong><code>Runnable</code> 接口</strong> 不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong> 可以。</p>
<p><strong>Java中的线程池在进行任务提交时，有两种方式：execute和submit方法。</strong></p>
<ol>
<li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<p>如何创建线程池</p>
<p><strong>方式一：通过构造方法实现</strong></p>
<p><img src="https://s2.loli.net/2022/05/03/LG7QxAiByg8r4pO.jpg" alt="ThreadPoolExecutor构造方法"></p>
<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p>
<p>我们可以创建三种类型的 ThreadPoolExecutor：</p>
<ul>
<li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>参考： <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484834&idx=1&sn=7d3835091af8125c13fc6db765f4c5bd&source=41#wechat_redirect">并发编程面试必备：JUC 中的 Atomic 原子类总结 (qq.com)</a></p>
<p><img src="https://s2.loli.net/2022/05/03/mwXYl9iVfDWnPQG.jpg" alt="图片"></p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<p>CLH(Craig,Landin and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
<p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><strong>Share</strong>（共享）：多个线程可同时执行，如<code> CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。</li>
</ul>
<h2 id="相关提问"><a href="#相关提问" class="headerlink" title="相关提问"></a>相关提问</h2><p><strong>sleep() 方法和 wait() 方法区别和共同点？</strong></p>
<ul>
<li>两者最主要的区别在于：**<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁** 。</li>
<li>两者都可以暂停线程的执行。</li>
<li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep() </code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒</li>
</ul>
<p><strong>调用 start() 方法时会执行 run() 方法，为什么不能直接调用 run() 方法？</strong></p>
<p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。<strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<p><strong>构造方法可以使用 synchronized 关键字修饰么？</strong></p>
<p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p>
<p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><hr>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><hr>
<h2 id="springboot的启动过程"><a href="#springboot的启动过程" class="headerlink" title="springboot的启动过程"></a>springboot的启动过程</h2><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><hr>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><hr>
<h2 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h2><h2 id="redis的缓存同步问题"><a href="#redis的缓存同步问题" class="headerlink" title="redis的缓存同步问题"></a>redis的缓存同步问题</h2><h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h2><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><hr>
<h2 id="数据库的四种隔离级别"><a href="#数据库的四种隔离级别" class="headerlink" title="数据库的四种隔离级别"></a>数据库的四种隔离级别</h2><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><hr>
<h2 id="JVM是解释器吗？"><a href="#JVM是解释器吗？" class="headerlink" title="JVM是解释器吗？"></a>JVM是解释器吗？</h2><p>Java源程序被编译后生成的文件格式后缀为.class，称为字节码文件。</p>
<p>字节码是不能够直接被本地物理机器执行的，需要通过Java虚拟机来执行。</p>
<p>Java虚拟机，本质上仍然是一个软件，它的功能是按照Java字节码的规范解析字节码文件中字节码的语义动作并转化为本地物理机器的指令序列来执行。以字节码为单位逐条解析逐条执行的方式成为解释执行，由解释器完成。</p>
<p>由于即时编译技术的出现，现代虚拟机能够对高频度反复执行的方法，以整个方法为单位，一次性将整个方法的字节码序列编译为本地机器指令序列，然后直接运行编译后的机器指令序列。这种方式称为编译执行，由即时编译器完成。现代Java虚拟机的核心执行引擎既包括了解释器，又包括了即时编译器模块。因此Java虚拟机不等于解释器。</p>
<p><img src="https://s2.loli.net/2022/04/21/CqsrjAbwup78fRm.png" alt="img"></p>
<p><strong>JIT</strong></p>
<blockquote>
<p>A JIT compiler runs after the program has started and compiles the code (usually bytecode or some kind of VM instructions) on the fly (or just-in-time, as it’s called) into a form that’s usually faster, typically the host CPU’s native instruction set. A JIT has access to dynamic runtime information whereas a standard compiler doesn’t and can make better optimizations like inlining functions that are used frequently.</p>
<p>This is in contrast to a traditional compiler that compiles all the code to machine language before the program is first run.</p>
<p>To paraphrase, conventional compilers build the whole program as an EXE file BEFORE the first time you run it. For newer style programs, an assembly is generated with pseudocode (p-code). Only AFTER you execute the program on the OS (e.g., by double-clicking on its icon) will the (JIT) compiler kick in and generate machine code (m-code) that the Intel-based processor or whatever will understand.</p>
</blockquote>
<h2 id="java内存管理"><a href="#java内存管理" class="headerlink" title="java内存管理"></a>java内存管理</h2><p><img src="https://s2.loli.net/2022/04/19/lWzj6wSO1n24B3I.png" alt="img"></p>
<h2 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h2><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p>
<h2 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h2><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的</p>
<h2 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h2><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>JMM（Java Memory Model）：Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别。也就是说，JMM 是 JVM 中定义的一种并发编程的底层模型机制。</p>
<p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读&#x2F;写共享变量的副本。</p>
<p>JMM 的规定：<br>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p>
<ul>
<li>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</li>
<li>线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。</li>
<li>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-3d312429710bd6a11eca171858f67751_r.jpg" alt="preview"></p>
<p>然而，JMM 这样的规定可能会导致线程对共享变量的修改没有即时更新到主内存，或者线程没能够即时将共享变量的最新值同步到工作内存中，从而使得线程在使用共享变量的值时，该值并不是最新的。</p>
<p><strong>正因为 JMM 这样的机制，就出现了可见性问题</strong>，</p>
<p>内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。</p>
<p>我们如何保证多线程下共享变量的可见性呢？也就是当一个线程修改了某个值后，对其他线程是可见的。</p>
<p>这里有两种方案：<strong>加锁</strong> 和 <strong>使用 volatile 关键字</strong>。</p>
<p>使用 synchronizer 进行加锁。因为当一个线程进入 synchronizer 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。里除了 synchronizer 外，其它锁也能保证变量的内存可见性。</p>
<p>使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 <strong>CPU 总线嗅探机制</strong>告知其他线程该变量副本已经失效，需要重新从主内存中读取。volatile 保证了不同线程对共享变量操作的可见性，也就是说一个线程修改了 volatile 修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。</p>
<p><strong>嗅探机制工作原理</strong>：每个处理器通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。</p>
<blockquote>
<p>注意：基于 CPU 缓存一致性协议，JVM 实现了 volatile 的可见性，但由于总线嗅探机制，会不断的监听总线，如果大量使用 volatile 会引起总线风暴。所以，volatile 的使用要适合具体场景。</p>
</blockquote>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/DBC_121/article/details/104005076">(185条消息) 详细讲解systemctl（附常用指令）_BoCong-Deng的博客-CSDN博客_systemctl</a></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><hr>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">Java设计模式：23种设计模式全面解析（超级详细） (biancheng.net)</a></p>
<h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h2><p>单一原则：让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p>
<p>里氏替换原则： 子类对象必须能够替换掉所有父类对象。 子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li>
<li>子类中可以增加自己特有的方法</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li>
<li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等</li>
</ul>
<p>依赖倒置原则：高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<p>接口隔离原则：不应该强迫客户依赖于它们不用的方法。</p>
<p>迪米特原则：最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话</p>
<p>开闭原则：类应该对扩展开放，对修改关闭。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">木木想去北海种花</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mumu-lsl.github.io/posts/2c3345f0/">https://mumu-lsl.github.io/posts/2c3345f0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mumu-lsl.github.io" target="_blank">Lin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javaSE/">javaSE</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/bfaf5b1d/"><img class="next-cover" src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RPC框架</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">木木想去北海种花</div><div class="author-info__description">Lin在此创作, 欢迎各位</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mumu-LSL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/zumumu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">new 的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">类加载的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-%E3%80%81finally-%E3%80%81finalize%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">final 、finally 、finalize三个关键字的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">1.4.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">java的参数传递方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.6.</span> <span class="toc-text">java 异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.7.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">1.7.2.</span> <span class="toc-text">Java的泛型是如何工作的 ? 什么是类型擦除 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E9%9D%9E%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.7.3.</span> <span class="toc-text">泛型中的限定通配符和非限定通配符 ?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%8F%8D%E5%B0%84"><span class="toc-number">1.8.</span> <span class="toc-text">java反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.9.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.10.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection"><span class="toc-number">1.10.1.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">1.10.2.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.10.3.</span> <span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%BC%95%E7%94%A8"><span class="toc-number">1.11.</span> <span class="toc-text">java引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8"><span class="toc-number">1.12.</span> <span class="toc-text">java关键字作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">何为进程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.3.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.4.</span> <span class="toc-text">synchronized 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%EF%BC%88%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">ReentrantLock（可重入锁）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.6.</span> <span class="toc-text">Volatile关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.</span> <span class="toc-text">重排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">2.8.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.9.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.10.</span> <span class="toc-text">原子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number">2.11.</span> <span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8F%90%E9%97%AE"><span class="toc-number">2.12.</span> <span class="toc-text">相关提问</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">3.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC"><span class="toc-number">3.1.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP"><span class="toc-number">3.2.</span> <span class="toc-text">AOP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot"><span class="toc-number">4.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#springboot%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">springboot的启动过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC"><span class="toc-number">5.</span> <span class="toc-text">SpringMVC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">6.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">redis的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%9A%84%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.</span> <span class="toc-text">redis的缓存同步问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">6.3.</span> <span class="toc-text">redis分布式锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">7.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">数据库的四种隔离级别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">8.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E6%98%AF%E8%A7%A3%E9%87%8A%E5%99%A8%E5%90%97%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">JVM是解释器吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">java内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">8.3.</span> <span class="toc-text">程序计数器为什么是私有的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">8.4.</span> <span class="toc-text">虚拟机栈和本地方法栈为什么是私有的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">8.5.</span> <span class="toc-text">堆和方法区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM"><span class="toc-number">8.6.</span> <span class="toc-text">JMM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux"><span class="toc-number">9.</span> <span class="toc-text">Linux</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">10.1.</span> <span class="toc-text">设计模式六大原则</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2c3345f0/" title="Java技术原理"><img src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java技术原理"/></a><div class="content"><a class="title" href="/posts/2c3345f0/" title="Java技术原理">Java技术原理</a><time datetime="2022-05-24T15:13:57.000Z" title="发表于 2022-05-24 23:13:57">2022-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bfaf5b1d/" title="RPC框架"><img src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RPC框架"/></a><div class="content"><a class="title" href="/posts/bfaf5b1d/" title="RPC框架">RPC框架</a><time datetime="2022-05-24T15:13:24.000Z" title="发表于 2022-05-24 23:13:24">2022-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7b25d017/" title="redis"><img src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis"/></a><div class="content"><a class="title" href="/posts/7b25d017/" title="redis">redis</a><time datetime="2022-05-24T15:13:05.000Z" title="发表于 2022-05-24 23:13:05">2022-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6096f3d5/" title="LeetCode"><img src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode"/></a><div class="content"><a class="title" href="/posts/6096f3d5/" title="LeetCode">LeetCode</a><time datetime="2022-05-24T15:07:50.000Z" title="发表于 2022-05-24 23:07:50">2022-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/341a9d02/" title="多线程编程"><img src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程编程"/></a><div class="content"><a class="title" href="/posts/341a9d02/" title="多线程编程">多线程编程</a><time datetime="2022-02-15T04:00:02.000Z" title="发表于 2022-02-15 12:00:02">2022-02-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: -rgb(0,0,255)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 木木想去北海种花</div><div class="footer_custom_text">所有你乐于挥霍的时间，都不能算作浪费</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="null" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>