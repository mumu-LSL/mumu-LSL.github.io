<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux高性能服务器编程 | Lin's Blog</title><meta name="keywords" content="Linux网络编程"><meta name="author" content="rtlin"><meta name="copyright" content="rtlin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux高性能服务器编程Linux网络编程基础API 探讨Linux网络编程基础与内核中TCP&#x2F;IP协议族之间的关系，并为后续章节提供编程基础 从三方面来讨论Linux网络API  socket地址API，socket最开始的含义是一个IP地址和端口对，它唯一的标识了TCP通信的一端 socket基础API，socket的主要的API都定义在 sys&#x2F;socket.h头文件中">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器编程">
<meta property="og:url" content="https://mumu-lsl.github.io/posts/16108/index.html">
<meta property="og:site_name" content="Lin&#39;s Blog">
<meta property="og:description" content="Linux高性能服务器编程Linux网络编程基础API 探讨Linux网络编程基础与内核中TCP&#x2F;IP协议族之间的关系，并为后续章节提供编程基础 从三方面来讨论Linux网络API  socket地址API，socket最开始的含义是一个IP地址和端口对，它唯一的标识了TCP通信的一端 socket基础API，socket的主要的API都定义在 sys&#x2F;socket.h头文件中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://plus.unsplash.com/premium_photo-1661510050360-b8447baf1963?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MXx8Y2FydG9vbnxlbnwwfHwwfHw%3D&auto=format&fit=crop&w=500&q=60">
<meta property="article:published_time" content="2022-02-08T17:55:03.429Z">
<meta property="article:modified_time" content="2022-11-04T07:07:26.434Z">
<meta property="article:author" content="rtlin">
<meta property="article:tag" content="Linux网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://plus.unsplash.com/premium_photo-1661510050360-b8447baf1963?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MXx8Y2FydG9vbnxlbnwwfHwwfHw%3D&auto=format&fit=crop&w=500&q=60"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mumu-lsl.github.io/posts/16108/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux高性能服务器编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-04 15:07:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://plus.unsplash.com/premium_photo-1661510050360-b8447baf1963?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxzZWFyY2h8MXx8Y2FydG9vbnxlbnwwfHwwfHw%3D&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lin's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux高性能服务器编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-08T17:55:03.429Z" title="发表于 2022-02-09 01:55:03">2022-02-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-04T07:07:26.434Z" title="更新于 2022-11-04 15:07:26">2022-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux高性能服务器编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux高性能服务器编程"><a href="#Linux高性能服务器编程" class="headerlink" title="Linux高性能服务器编程"></a>Linux高性能服务器编程</h1><h2 id="Linux网络编程基础API"><a href="#Linux网络编程基础API" class="headerlink" title="Linux网络编程基础API"></a>Linux网络编程基础API</h2><hr>
<p>探讨Linux网络编程基础与内核中TCP&#x2F;IP协议族之间的关系，并为后续章节提供编程基础</p>
<p>从三方面来讨论Linux网络API</p>
<ul>
<li>socket地址API，socket最开始的含义是一个IP地址和端口对，它唯一的标识了TCP通信的一端</li>
<li>socket基础API，socket的主要的API都定义在 sys&#x2F;socket.h头文件中</li>
<li>网络信息API，Linux提供了一套网络信息的API，以实现主机名与IP地址，服务名与端口号之间的转换</li>
</ul>
<h3 id="socket地址API"><a href="#socket地址API" class="headerlink" title="socket地址API"></a>socket地址API</h3><hr>
<h4 id="0-字节序"><a href="#0-字节序" class="headerlink" title="0.字节序"></a>0.字节序</h4><p>在了解socket地址API之前我们应该先了解一下字节序：</p>
<p>字节序的分类</p>
<ul>
<li>大端字节序(big endian)</li>
</ul>
<p>​       大端字节序是指一个整数的高位字节(23-31bit)存储在内存的低地址处,低位字节(0~7bit)存储在内存的高地址处.</p>
<ul>
<li>小端字节序(little endian)</li>
</ul>
<p>​       小端字节序则是指整数的高位字节存储在内存的高地址处,而低位字节则存储在内存的低地址处.</p>
<p>主机字节序和网络字节序</p>
<ul>
<li>现代PC大多采用小端字节序,因此小端字节序又被称为网络字节序</li>
<li>现在网络传输中的字节序都采用大端字节序,所以大端字节序又被称为网络字节序</li>
</ul>
<hr>
<h4 id="1-通用socket地址"><a href="#1-通用socket地址" class="headerlink" title="1. 通用socket地址"></a>1. 通用socket地址</h4><p><code>sockaddr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">//sa_family成员是地址族类型(sa_family_t)的变量,地址族类型通常与协议族类型对应</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];  <span class="comment">//sa_data成员用于存放socket地址值. 但十四字节根本无法存放大多数协议的地址值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sa_family成员是地址族类型(sa_family_t)的变量,地址族类型通常与协议族类型对应</p>
<p>协议族与地址族的关系</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址值含义和长度</th>
<th>地址族</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>文件的路径名,长度可达到108字节</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>16bit端口号和32bitIPv4地址,共5字节</td>
<td>AF_INET</td>
<td>TCP&#x2F;IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>16bit端口号,32bit流标识,126bitIPv6地址,32bit范围ID,共26字节</td>
<td>AF_INET6</td>
<td>TCP&#x2F;IPv6协议族</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span>-<span class="built_in">sizeof</span>(__ss_align)]; <span class="comment">//提供了更大的空间并且是内存对齐的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-专用socket地址"><a href="#2-专用socket地址" class="headerlink" title="2. 专用socket地址"></a>2. 专用socket地址</h4><p>通用的socket地址不能够很方便的使用，所以Linux为各个协议族提供了专门的socket地址结构体</p>
<p>  <strong>Unix本地域协议族</strong>     <code>sockaddr_un</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span>     <span class="comment">//Unix本地域协议族</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">// 地址族:AF_UNIX</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];      <span class="comment">// 文件路径名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>IPV4</strong>   <code>sockaddr_in</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;    <span class="comment">// 地址族:AF_INET</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;        <span class="comment">//端口号,要使用网络字节序表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;   <span class="comment">//IPv4地址结构第</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];          <span class="comment">//不使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;   <span class="comment">//IPv4地址,要用网络字节序表示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sockaddr_in结构体的赋值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line"><span class="type">char</span> * serv_port = <span class="string">&quot;9999&quot;</span>;</span><br><span class="line"><span class="type">char</span> * serv_ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(addr));   <span class="comment">//内存初始化</span></span><br><span class="line">addr.sin_family = AF_INET;   <span class="comment">//设置地址族</span></span><br><span class="line"><span class="comment">// addr.sin_addr.s_addr = htonl(INADDR_ANY);  //设置ip地址,服务器通常采用INADDR_ANY</span></span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(serv_ip);    <span class="comment">//客户端，利用地址转行函数来讲字符串转化为二进制整数</span></span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(serv_port));    <span class="comment">// 设置端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//INADDR_ANY</span></span><br><span class="line"><span class="comment">//自动分配服务器端的IP,不必输入,服务器有限考虑这种方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>IPV6</strong>    <code>sockaddr_in6</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin5_family;   <span class="comment">//地址族,要用AF_INET6</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin6_port;       <span class="comment">//端口号,使用网络字节序</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_flowinfo;   <span class="comment">//流信息,应设置为0</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr; <span class="comment">//IPv6结构体</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_scope_id;   <span class="comment">//scope ID,尚处于实验阶段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sa_addr[<span class="number">16</span>];  <span class="comment">//IPv6地址,网络字节序表示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所有socket地址类型的变量都需要转化为通用的socket地址类型（socketaddr）,直接强制转换即可</p>
<hr>
<h4 id="3-IP地址转换函数"><a href="#3-IP地址转换函数" class="headerlink" title="3. IP地址转换函数"></a><strong>3. IP地址转换函数</strong></h4><p>人们习惯用可读性更好字符串来表示IP地址，但编程中我们需要把它们转化为二进制数方能使用。而记录日志则正好相反</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * strptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * cp,<span class="keyword">struct</span> in_addr* inp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr_in)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af,<span class="type">const</span> <span class="type">char</span> * src,<span class="type">void</span> * dst)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af,<span class="type">const</span> <span class="type">void</span> * src,<span class="type">char</span> * dst,<span class="type">socklen_t</span> cnt)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>inet_addr</code><br>inet_addr将点分十进制字符串标示的IPv4地址转化为用网络字节序整数表示的IPv4地址.失败时返回INADDR_NONE.</p>
<p><code>inet_aton</code><br>inet_aton将点分十进制字符串标示的IPv4地址转化为用网络字节序整数表示的IPv4地址存储到参数inp指向的地址结构中.成功时返回1,失败时返回0</p>
<p><code>inet_ntoa</code><br>inet_ntoa将用网络字节序整数标示的IPv4地址转化为用点分十进制字符串标示的IPv4地址. 但inet_ntoa函数是不可重入的,该函数内部使用一个静态变量存储转化结果,函数的返回值指向该静态内存</p>
<p><code>inet_pton</code><br>inet_pton函数将用字符串表示的IP地址src(用点分十进制字符串标示的IPv4地址或用十六进制字符串表示的IPv6地址)转换成用网络字节序表示的IP地址,并把转换结果存储与dst指向的内存中.</p>
<p>af:指定地址族,可以是AF_INET或者AF_INET6</p>
<p>成功返回1,失败返回0并设置errno</p>
<p><code>inet_ntop</code><br>inet_ntop函数进行和inet_pton相反的转换.前三个参数的含义与inet_pton相同</p>
<p>cnt:制定目标存储单元的大小,使用下面两个宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>

<p>成功时返回目标存储单元的地址,失败返回NULL并设置errno</p>
<hr>
<h3 id="socket基础API"><a href="#socket基础API" class="headerlink" title="socket基础API"></a>socket基础API</h3><hr>
<h4 id="1-socket（）函数："><a href="#1-socket（）函数：" class="headerlink" title="1. socket（）函数："></a><strong>1. socket（）函数：</strong></h4><p>原函数： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocl)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>domain指明了协议族&#x2F;域，通常PF_INET、PF_INET6、PF_UNIX等；<br>type是套接口类型，主要SOCK_STREAM（对应TCP服务）、SOCK_DGRAM（对应UDP服务） 、SOCK_NONBLOCK（新创建的socket设置为非阻塞的 ）；<br>protocol一般取为0。</p>
<p>成功时，返回一个小的非负整数值，与文件描述符类似。<br>作用： socket函数用于创建一个新的socket，也就是向系统申请一个socket资源。</p>
<hr>
<h4 id="2-bind（）函数："><a href="#2-bind（）函数：" class="headerlink" title="2. bind（）函数："></a><strong>2. bind（）函数：</strong></h4><p>原函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="keyword">struct</span> sockaddr* myaddr,<span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>sockfd 表示socket函数创建的通信文件描述符<br>addrlen 表示所指定的结构体变量的大小<br>myaddr 表示struct sockaddr的地址，用于设定要绑定的ip和端口</p>
<p>成功返回0,失败返回-1并设置errno,其中常见的两种errno是:</p>
<ul>
<li>EACCES:被绑定的地址是收保护的地址,仅超级用户能够访问</li>
<li>EADDRINUSE:被绑定的地址正在使用中</li>
</ul>
<p>作用：命名socket. 将一个socket与socket地址绑定称为给socket命名.</p>
<hr>
<h4 id="3-listen（）函数："><a href="#3-listen（）函数：" class="headerlink" title="3. listen（）函数："></a><strong>3. listen（）函数：</strong></h4><p>原函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>listen() 函数的主要作用就是将 socket() 函数得到的 sockfd 变成一个被动监听的套接字, 用来被动等待客户端的连接,而参数 backlog 的作用就是设置连接队列的长度。三次握手,建立连接不是 listen() 函数完成的, 而是内核完成的, listen() 函数只是将 sockfd 和 backlog 告诉内核, 然后就返回了<br>如果有客户端通过 connect() 发起连接请求, 内核就会通过三次握手建立连接, 然后将建立好的连接放到一个队列中,<br>这个队列称为: 已完成连接队列<br>listen函数一般在调用bind之后调用，在accept之前调用，调用成功时返回0,失败时返回-1并设置errno</p>
<hr>
<h4 id="4-accept（）函数："><a href="#4-accept（）函数：" class="headerlink" title="4. accept（）函数："></a><strong>4. accept（）函数：</strong></h4><p>原函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>sockfd</code>:是执行过listen系统调用的监听socket</li>
<li><code>addr</code>:用来获取被接受连接的远端socket地址</li>
<li><code>addrlen</code>:指出<code>addr</code>接收的socket地址的长度</li>
<li>成功时返回一个新的连接socket,失败时返回-1并设置errno</li>
</ul>
<p>作用<br>accept() 函数的作用就是在已完成连接队列中取出一个已经建立好的连接。如果这个队列中已经没有已完成连接的套接字, 那么 accept() 就会一直阻塞, 直到取得一个已经建立连接的套接字</p>
<hr>
<h4 id="5-数据读写"><a href="#5-数据读写" class="headerlink" title="5. 数据读写"></a><strong>5. 数据读写</strong></h4><p><strong>TCP数据读写</strong></p>
<p>对文件的读写操作read和write同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用， 它们增加了对数据读写的控制。 其中适用于TCP流数据读写的系统调用是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span> <span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">void</span>*buf,<span class="type">size_t</span> len,<span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">void</span> * buf,<span class="type">size_t</span> len,<span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>read</code></strong></p>
<p>接受或者输入数据</p>
<ul>
<li><code>fd</code>:显示数据接受对象的文件描述符</li>
<li><code>buf</code>:要保存接收数据的缓冲区地址</li>
<li><code>nbytes</code>:要接收数据的最大字节数</li>
<li>成功时返回接收到的字节数,接收到文件尾或者连接被关闭返回0,失败返回-1</li>
</ul>
<p><strong><code>write</code></strong></p>
<p>向文件或者套接字传递数据.</p>
<ul>
<li><code>fd</code>:显示数据传输对象的文件描述符</li>
<li><code>buf</code>:保存要传输数据的缓冲地址值</li>
<li><code>n</code>:要传输数据的字节数</li>
<li>成功时返回写入的字节数,失败时返回-1</li>
</ul>
<p><strong><code>recv</code></strong><br>接受或者输入数据</p>
<p><code>sockfd</code>:表示数据接收对象的连接的套接字文件描述符<br><code>buf</code>:保存接收数据的缓冲地址值<br><code>len</code>:可接收的最大字节数<br><code>flags</code>传输数据时制定的可选项信息<br>成功时返回接受的字节数(收到EOF返回0),失败时返回-1;</p>
<p><strong><code>send</code></strong><br>向文件或者套接字传递数据</p>
<p><code>sockfd</code>:表示与数据传输对象的连接的套接字文件描述符<br><code>buf</code>:保存带传输数据的缓冲地址值<br><code>len:</code>待传输的字节数<br><code>flags</code>传输数据时制定的可选项信息<br>成功时返回发送的字节数,失败时返回-1</p>
<p><strong>UDP数据读写</strong></p>
<p>socket编程接口中用于UDP数据报读写的系统调用是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span>  <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* src_addr, <span class="type">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span>  <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* dest_addr, <span class="type">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><code> recvfrom</code></strong><br>sock:用于接收数据的UDP套接字文件描述符<br>buff:保存接收数据的缓冲区地址值<br>nbytes:可接受的最大字节数,故无法超过参数buff所指的缓冲区大小<br>flags:可选项参数,若没有则传入0<br>from:存有发送端地址信息的sockaddr结构体变量的地址值<br>addrlen:保存参数from的结构体变量长度的变量地址值</p>
<p><strong><code>sendto</code></strong><br>sock:用于传输数据的UDP套接字文件描述符<br>buff:保存待传输数据的缓冲区地址值<br>nbytes:待传输的数据长度,以字节为单位<br>flags:可选项参数,若没有则传递0<br>to:存有目标地址信息的sockaddr结构体变量的地址值<br>addrlen:传递的参数to地址值结构体变量长度<br>成功时返回传输的字节数,失败时返回-1</p>
<p>UDP通信没有连接的概念，每次读取数据都需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度</p>
<p><strong>通用数据读写函数</strong></p>
<p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅能用于TCP流数据，也能用于UDP数据报：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span>  <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span>  <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockfd参数指定被操作的目标socket。 msg参数是msghdr结构体类型的指针 falgs与前面recv,send的相同</p>
<hr>
<h4 id="6-实例"><a href="#6-实例" class="headerlink" title="6. 实例"></a>6. 实例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @File:serv_1.cpp</span></span><br><span class="line"><span class="comment"> * @Descripttion: socket编程服务器端,简单版本(TCP)</span></span><br><span class="line"><span class="comment"> *  只接受一个客户端连接,并接收客户端发送的信息显示后就退出</span></span><br><span class="line"><span class="comment"> * @Version: </span></span><br><span class="line"><span class="comment"> * @Author: zsj</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-03 15:38:31</span></span><br><span class="line"><span class="comment"> * @LastEditors: zsj</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-03 16:20:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_error</span><span class="params">(<span class="type">char</span> * info)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(info);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//参数数量不对直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个socket</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配地址信息,socket命名</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;bind() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个监听队列</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;listen() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_addr_sz = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="comment">//取出一个连接</span></span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">accept</span>(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr,&amp;clnt_addr_sz);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;accept() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get a connection %d\n&quot;</span>,clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    ret = <span class="built_in">read</span>(clnt_sock,buffer,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client close the connection!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;from %d data %d bytes: %s\n&quot;</span>,clnt_sock,ret,buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @File:clnt_1.cpp</span></span><br><span class="line"><span class="comment"> * @Descripttion: socket编程,客户端简单版本,(TCP)</span></span><br><span class="line"><span class="comment"> *  连接服务器之后,发送数据到服务器之后就退出</span></span><br><span class="line"><span class="comment"> * @Version: </span></span><br><span class="line"><span class="comment"> * @Author: zsj</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-03 16:06:36</span></span><br><span class="line"><span class="comment"> * @LastEditors: zsj</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-03 16:19:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_error</span><span class="params">(<span class="type">char</span> * info)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(info);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;ip&gt; &lt;port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个socket</span></span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端不需要绑定和监听,直接连接服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clnt_sock,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect to %s success!\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>] = <span class="string">&quot;hello server!!!&quot;</span>;</span><br><span class="line">    ret = <span class="built_in">write</span>(clnt_sock,buffer,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;write() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send data success!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-带外数据"><a href="#7-带外数据" class="headerlink" title="7. 带外数据"></a>7. 带外数据</h4><p>我们需要知道的是数据分为两种，一种是带内数据，一种是带外数据。带内数据就是我们平常传输或者说是口头叫的数据。带外数据就是我们接下来讲的内容。</p>
<p>   许多的传输层都具有带外数据（也称为 经加速数据 ）的概念，想法就是连接的某段发生了重要的事情，希望迅速的通知给对端。这里的迅速是指这种通知应该在已经排队了的带内数据之前发送。也就是说，带外数据拥有更高的优先级。带外数据不要求再启动一个连接进行传输，而是使用已有的连接进行传输。其中，UDP没有实现带外数据（是个极端哦～）。TCP中telnet,rlogin,ftp等应用（除了这样的远程非活跃应用之外，几乎很少有使用到带外数据的地方）</p>
<p><a href="https://sm.ms/image/BtwsYAnNfRMaLZk" target="_blank"><img src="https://s2.loli.net/2022/02/11/BtwsYAnNfRMaLZk.jpg" alt="70.png"></a></p>
<p>紧急字段URG：告诉系统此报文段中有紧急数据，应尽快传送。当URG&#x3D;1时。</p>
<p>紧急指针：指出在本报文段中的紧急数据的最后一个字节的序号，即指出带外数据字节在正常字节流中的位置。</p>
<p>所以当TCP发送带外数据时，他的TCP首部一定是设置了URG标志和紧急指针的 。而紧急指针就是用来指出带外数据字节在正常字节流中的位置的 。</p>
<hr>
<h4 id="8-带外标记"><a href="#8-带外标记" class="headerlink" title="8. 带外标记"></a>8. 带外标记</h4><p>内核通知应用程序带外数据到达的两种常见方式是：I&#x2F;O复用产生的异常事件和SIGURG信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">sockatmark</span><span class="params">(<span class="type">int</span>  sockfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockatmark判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据。</p>
<p>如果是，sockatmark返回1，此时我们就可以利用MSG_OOB标志的recv调用来接收带外数据。 如果不是，则sockatmark返回0。</p>
<hr>
<h4 id="9-地址信息函数"><a href="#9-地址信息函数" class="headerlink" title="9. 地址信息函数"></a>9. 地址信息函数</h4><p>在某些情况下，我们想知道一个连接socket的本端socket地址， 以及远端的socket地址。 下面这2个函数正是用于解决这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>getsockname获取sockfd对应的本端socket地址，并将其存储于address参数 指定的内存中，该socket地址的长度则存储于address_len参数指向的变量中。 如果实际socket地址的长度大于address所指内存的大小， 那么该socket地址将被截断。</p>
<ul>
<li>getsockname成功时返回0，失败返回-1，并设置errno。</li>
</ul>
<p>getpeername获取sockfd对应的远端socket地址， 其参数及返回值的含义与getsockname的参数及返回值相同。</p>
<hr>
<h4 id="10-socket选项"><a href="#10-socket选项" class="headerlink" title="10. socket选项"></a>10. socket选项</h4><p>如果说fcntl系统调用是控制文件描述符属性的通用POSIX方法， 那么下面两个系统调用则是专门用来读取和设置socket文件描述符属性的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span>* option_value,<span class="type">socklen_t</span>* restrict option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">const</span> <span class="type">void</span>* option_value, <span class="type">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockfd参数指定被操作的目标socket。 level参数指定要操作哪个协议的选项（即属性），比如IPv4、IPv6、TCP等。 option_name参数则指定选项的名字。 option_value和option_len参数分别是被操作选项的值和长度。</p>
<ul>
<li>getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno。</li>
</ul>
<p>对服务器而言，有部分socket选项要在监听(listen)前针对监听socket设置才有效。 对客户端而言，这些socket选项则应在调用connect函数之前设置， 因为connect调用成功之后，TCP三次握手已完成。</p>
<hr>
<h3 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h3><hr>
<h4 id="1-gethostbyname和gethostbyaddr"><a href="#1-gethostbyname和gethostbyaddr" class="headerlink" title="1. gethostbyname和gethostbyaddr"></a>1. gethostbyname和gethostbyaddr</h4><p>gethostbyname 函数根据主机名称获取主机的完整信息， gethostbyaddr函数根据IP地址获取主机的完整信息。 gethostbyname函数通常先在本地的 &#x2F;etc&#x2F;hsots配置的文件中查找主机， 如果没有找到，再去访问DNS服务器。</p>
<p>这两个函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span>* name);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyaddr</span>(<span class="type">const</span> <span class="type">void</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> type);</span><br></pre></td></tr></table></figure>

<p>hostent结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* h_name;    <span class="comment">//主机名</span></span><br><span class="line">    <span class="type">char</span>** h_aliases; <span class="comment">//主机别名列表，可能有多个</span></span><br><span class="line">    <span class="type">int</span> h_addrtype;   <span class="comment">//地址类型（地址族）</span></span><br><span class="line">    <span class="type">int</span> h_length;     <span class="comment">//地址长度</span></span><br><span class="line">    <span class="type">char</span>** h_addr_list;<span class="comment">//按网络字节序列出的主机IP地址列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-getservbyname和getservbyport"><a href="#2-getservbyname和getservbyport" class="headerlink" title="2. getservbyname和getservbyport"></a>2. getservbyname和getservbyport</h4><p>getservbyname函数根据名称获取某个服务的完整信息， getsrvbyport函数根据端口号获取某个服务的完整信息。 他们实际上都是通过读取 &#x2F;etc&#x2F;services 文件来获取服务信息的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">servent</span>* <span class="built_in">getservbyname</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* proto);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">servent</span>* <span class="built_in">getsrvbyport</span>(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span>* proto);</span><br></pre></td></tr></table></figure>

<p>name参数指定目标服务器的名字，port参数指定目标服务对应的端口号， proto参数指定服务类型。</p>
<p>结构体servent定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">servent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* s_name;       <span class="comment">//服务名称</span></span><br><span class="line">    <span class="type">char</span>** s_aliases;   <span class="comment">//服务的别名列表，可能有多个</span></span><br><span class="line">    <span class="type">int</span> s_port;         <span class="comment">//端口号</span></span><br><span class="line">    <span class="type">char</span>* s_proto;     <span class="comment">//服务类型，通常是tcp或者udp</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-getaddrinfo"><a href="#3-getaddrinfo" class="headerlink" title="3. getaddrinfo"></a>3. getaddrinfo</h4><p>getaddrinfo函数既能通过主机名获取ip地址（内部使用gethostbyname）也能 通过服务名获得端口号（内部使用getservbyname）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hostname, <span class="type">const</span> <span class="type">char</span>* service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo* hints, <span class="keyword">struct</span> addrinfo** result)</span></span></span><br></pre></td></tr></table></figure>



<p>hostname参数可以接收主机名，也可以接收字符串表示的IP地址（IPv4用点分十进制 字符串，IPv6用十六进制字符串）。 同样，service参数可以接收服务名，也可以接收字符串表示的十进制端口号。 hints参数是应用程序给getaddrinfo的一个提示，一对getaddrinfo的输出进行更精确的控制。 result参数指向一个链表，该链表用于存储getaddrinfo反馈的结果。</p>
<ul>
<li>getaddrinfo成功返回0，失败返回错误码</li>
</ul>
<p>getaddrinfo反馈的每一条结果都是addrinfo结构体类型的对象， 结构体addrinfo定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">addrinfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ai_flags;  <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> ai_family;<span class="comment">//地址族</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;<span class="comment">//服务类型，SOCK_STREAM 或 SOCK_DGRAM</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;<span class="comment">//</span></span><br><span class="line">    <span class="type">socklent_t</span> ai_addrlen;<span class="comment">// socket地址 ai_addr的长度</span></span><br><span class="line">    <span class="type">char</span>* ai_canonname;<span class="comment">//主机的别名</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr</span>* ai_addr; <span class="comment">//指向socket地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>* ai_next; <span class="comment">//指向下一个sockinfo结构的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用 getaddrinfo 函数</span></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">addrinfo</span>  hints;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">addrinfo</span>* res;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bzero</span>(&amp;hints, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"><span class="built_in">getaddrinfo</span>(<span class="string">&quot;ernest-laptop&quot;</span>, <span class="string">&quot;daytime&quot;</span>, &amp;hints, &amp;res);</span><br></pre></td></tr></table></figure>



<p>getaddrinfo将隐式地分配堆内存（可通过valgrind工具查看）， 因为res指针原本没有指向一块合法内存的， 所以，getaddrinfo调用结束后，必须使用如下配对函数来释放这块内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo*  res)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-getnameinfo"><a href="#4-getnameinfo" class="headerlink" title="4. getnameinfo"></a>4. getnameinfo</h4><p>getnameinfo函数能通过socket地址同时获得以字符串表示的主机名（内部使用gethostbyaddr函数）和服务名（内部使用getservbyport函数）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr* sockaddr, <span class="type">socklen_t</span> addrlen, <span class="type">char</span>* host, <span class="type">socklen_t</span> hostlen, <span class="type">char</span>* serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>getnameinfo将返回的主机名存储在host参数指向的缓存中， 将服务名存储在serv参数指向的缓存中， hostlen和servlen参数分别指定这两块缓存的长度。 flags参数控制getnameinfo的行为。</p>
<ul>
<li>getnameinfo成功返回0，失败返回错误码</li>
</ul>
<hr>
<h4 id="5-错误码"><a href="#5-错误码" class="headerlink" title="5. 错误码"></a>5. 错误码</h4><p>Linux下strerror函数能将数值错误码errno转换成易读的字符串形式。 同样，下面的函数可将表5-8(getaddrinfo和getnameinfo的错误码)的错误码转换成其字符串形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">gai_strerror</span><span class="params">(<span class="type">int</span> error)</span></span>;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/02/11/awGCn1JZrcgRoXm.png">



<h4 id="关于EAGAIN-与-EWOULDBLOCK"><a href="#关于EAGAIN-与-EWOULDBLOCK" class="headerlink" title="关于EAGAIN 与 EWOULDBLOCK"></a>关于EAGAIN 与 EWOULDBLOCK</h4><p><code>EAGAIN</code>的官方定义：</p>
<blockquote>
<p>“Resource temporarily unavailable.” The call might work if you try again later. The macro <code>EWOULDBLOCK</code> is another name for <code>EAGAIN</code>; they are always the same in the GNU C Library.</p>
</blockquote>
<p>翻译：资源短暂不可用，这个操作可能等下重试后可用。它的另一个名字叫做EWOULDAGAIN，这两个宏定义在GNU的c库中永远是同一个值。</p>
<p><code>EWOULDBLOCK</code>的定义：</p>
<blockquote>
<p>“Operation would block.” In the GNU C Library, this is another name for <code>EAGAIN</code> (above). The values are always the same, on every operating system.</p>
</blockquote>
<p>翻译：操作将会被阻塞，在GNU C的库中，它的另外一个名字是<code>EAGAIN</code>，在任何操作系统中他们两个的值都是一样的。</p>
<p>这两个错误码在大多数系统下是都同一个东西，特别是在使用了GNU的libc库平台（目前广泛使用的centos和ubuntu都是）下一定是相同的。这个错误产生的情况：</p>
<ul>
<li>尝试在一个设置了非阻塞模式的对象上执行阻塞操作，重试这个操作可能会阻塞直到其他条件让它可读、可写或者其他操作。</li>
<li>对某些操作来说，资源短暂不可用。例如<code>fork</code>函数可能返回这个错误（当没有足够的资源能够创建一个进程时），可以采取的操作是休息一段时间然后再继续操作。</li>
</ul>
<h2 id="高级IO函数"><a href="#高级IO函数" class="headerlink" title="高级IO函数"></a>高级IO函数</h2><hr>
<p>Linux提供了许多高级的IO函数，它们可能不像Linux常用的IO函数（如open和read）那么常用，但他们在特定条件下却能表现出优异的性能。 这些函数大致可以分为三类：</p>
<ul>
<li>用于创建文件描述符的函数，包括pipe,dup&#x2F;dup2函数</li>
<li>用于读写数据的函数，readv&#x2F;writev,sendfile,mmap&#x2F;munmap,splice,tee</li>
<li>用于控制I&#x2F;O行为和属性的函数，如fcntl</li>
</ul>
<hr>
<h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><p>pipe函数可以用于创建一个管道，以实现进程间的通信</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>pipe函数的参数是含有两个int 整形的数组指针，成功时返回0 ，并将文件描述符值填写到数组中，fd[0]表示读端，fd[1]表示写，两端不可颠倒，默认情况这两个文件描述符都是阻塞的。如果当管道为空时，调用系统调用read（）时，将被阻塞，直到管道内有数据可读。当管道为满时，调用write（）也会被阻塞，直到管道内有足够的空闲空间。如果将fd[0]  fd[1]设置为非阻塞，则read（）和write（）就会有不同的行为，关于阻塞与非阻塞，我们将在后续文章中进行讨论。</p>
<p>当fd[1]的引用计数减为0则表示，没有任何一个进行往管道中写入数据，则对于fd[0] 的read()操作返回值为0，表示读到末尾（EOF）。反之，当fd[0]的引用计数减为0，表示没有任何一个进程读这个管道，则fd[1]写端的write(）将失败，引发SIGPIPE信号。管道内部传输的也是字节流，这点也和TCP传输有些区别，TCP连接写入的数据，取决于滑动窗口的大小，而管道有一个容量限制，默认大小为65536字节，可通过fcntl函数修改管道大小。</p>
<p>可通过socketpair创建双向管道</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socketpair</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type, <span class="type">int</span> protocol,<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>前三个参数与socket函数中的参数意义相同，但是domain 只能使用AF_UNIX（表示Unix本地域协议族），因为我们仅能在本地使用这个双向管道，socketpair成功时返回0，失败返回-1并设置errno</p>
<hr>
<h3 id="dup函数与dup2函数"><a href="#dup函数与dup2函数" class="headerlink" title="dup函数与dup2函数"></a>dup函数与dup2函数</h3><p>有时候我们希望把标准输入重定向到一个文件，或者标准输出重定向到一个网络连接（如CGI编程）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> file_descriptor_one,file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure>

<p>dup 创建的新文件描述符，和原来的文件描述符file_descriptor指向相同的文件，管道或者网络连接，但不继承原来文件描述符的属性（如close-on-exec和non-blocking等）。dup返回的文件描述符总是取系统当前可用的最小整数值。dup和dup2系统调用失败时返回-1并设置errno</p>
<hr>
<h3 id="readv-x2F-writev-函数"><a href="#readv-x2F-writev-函数" class="headerlink" title="readv &#x2F;writev 函数"></a>readv &#x2F;writev 函数</h3><p> readv将文件描述符读到分散的内存块中，writev 将多块分散的内存中的数据写到一个文件描述符中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="keyword">struct</span> iovec*  vector,<span class="type">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="keyword">struct</span> iovec*  vector,<span class="type">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p> fd 是目标文件描述符，vector 是类型为iovec类型的结构体，该结构描述了一款内存，count 表示vector数组的长度</p>
<hr>
<h3 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h3><p>sendfile函数表示在两个文件描述符之间数据传递，完全在内核完成，避免了内核缓冲区到用户缓冲区的拷贝，效率很高，被称为零拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd,<span class="type">int</span> in_fd,<span class="type">off_t</span>* offset,<span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>in_fd,表示待读出的文件描述符，out_fd ，表示待写入的文件描述符，offset表示读人的位置，NULL表示默认起始位置，count表示在两个文件描述符传递的字节数，in_fd 必须是一个真实的文件，out_fd必须是一个socket，所以sendfile专门为网络传输文件设计的。 </p>
<hr>
<h3 id="mmap-x2F-munmap-函数"><a href="#mmap-x2F-munmap-函数" class="headerlink" title="mmap&#x2F;munmap   函数"></a>mmap&#x2F;munmap   函数</h3><p>mmap 函数是申请了一块内存，我们将这块内存作为进程间通信的共享内存，也可以将文件映射到其中，munmap 释放申请的这块内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mmap</span><span class="params">(<span class="type">void</span> *start,<span class="type">siez_t</span> length,<span class="type">int</span> port,<span class="type">int</span> flags, <span class="type">int</span> fd,<span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *start,<span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>start 表示内存的起始地址，length表示内存段的长度，prot表示内存访问权限，flags 表示内存修改后控制程序的行为，fd 表示映射文件的描述符，offset表示文件映射的位置。</p>
<hr>
<h3 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h3><p> 用于两个文件描述符之间的数据交流，也是一个零拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="type">int</span> fd_in,<span class="type">loff_t</span>* off_in,<span class="type">int</span> fd_out,<span class="type">loff_t</span>* off_out,<span class="type">size_t</span> len,<span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>splice 函数fd_in  或者 fd_out 必须有一个是管道文件描述符</p>
<p>fd_in参数：待读取数据的文件描述符。<br>off_in参数：指示从输入数据的何处开始读取，为NULL表示从当前位置。如果fd_in是一个管道描述符，则off_in必须为NULL。<br>fd_out参数：待写入数据的文件描述符。<br>off_out参数：同off_in，不过用于输出数据。<br>len参数：指定移动数据的长度。<br>flags参数：表示控制数据如何移动，可以为以下值的按位或：</p>
<ul>
<li><strong>SPLICE_F_MOVE</strong>：按整页内存移动数据，存在bug，自内核2.6.21后，实际上没有效果。</li>
<li><strong>SPLICE_F_NONBLOCK</strong>：非阻塞splice操作，实际会受文件描述符本身阻塞状态影响。</li>
<li><strong>SPLICE_F_MORE</strong>：提示内核：后续splice将调用更多数据。</li>
<li><strong>SPLICE_F_GIFT</strong>：对splice没有效果。</li>
</ul>
<p><strong>返回值</strong>：</p>
<p>返回值&gt;0：表示移动的字节数。<br>返回0：表示没有数据可以移动，如果从管道中读，表示管道中没有被写入数据。<br>返回-1；表示失败，并设置errno。</p>
<p>fdin和fdout必须至少有一个是管道文件描述符。</p>
<hr>
<h3 id="tee-函数"><a href="#tee-函数" class="headerlink" title="tee 函数"></a>tee 函数</h3><p> tee 函数用于两个管道之间的数据交流，也是零拷贝操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="type">int</span> fd_in,<span class="type">int</span> fd_out,<span class="type">size_t</span> len,<span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd_in  和fd_out 必须都是管道文件描述符。</p>
<p><strong>参数意义</strong>：</p>
<p>fdin参数：待读取数据的文件描述符。<br>fdout参数：待写入数据的文件描述符。<br>len参数：表示复制的数据的长度。<br>flags参数：同splice( )函数。</p>
<p>fdin和fdout必须都是管道文件描述符。 </p>
<p><strong>返回值</strong>：</p>
<p>返回值&gt;0：表示复制的字节数。<br>返回0：表示没有复制任何数据。<br>返回-1：表示失败，并设置errno。</p>
<hr>
<h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><p>fcntl函数是对各种文件描述符进行操作，修改属性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> cmd,...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>cmd参数：</p>
<p><img src="https://s2.loli.net/2022/02/11/x6m9gXsltKZjkN2.png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setnonblock</span><span class="params">(<span class="type">int</span> fd)</span><span class="comment">//设置非阻塞</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_fcntl = <span class="built_in">fcntl</span>(fd,F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_fcntl = old_fcntl | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">fcntl</span>(fd,F_SETFL,new_fcntl) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Linux-服务器程序规范"><a href="#Linux-服务器程序规范" class="headerlink" title="Linux 服务器程序规范"></a>Linux 服务器程序规范</h2><hr>
<p>除了网络通信外，服务器程序还必须考虑许多其他细节问题，零碎，但基本上是模板式的。比如：</p>
<ul>
<li>Linux服务器程序一般以后台形式运行。后台程序又称守护进程。它没有控制终端，因而也不会意外接受用户输入。守护进程的父进程一般是init进程（PID&#x3D;1）</li>
<li>Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器可以输出日志到专门的UDP服务器。大部分后台进程都在&#x2F;var&#x2F;log下有自己的日志目录</li>
<li>Linux服务器程序一般以某个专门的非root身份运行。比如mysqld, httpd, syslogd等后台进程，并分别有自己的运行账户mysql, apache, syslog</li>
<li>Linux服务器通常时可配置的。服务器程序通常处理很多命令选项，如果一次运行的选项太多，则可以用配置文件来管理。绝大多数服务器程序都有配置文件并存放在&#x2F;etc下 </li>
<li>Linux服务器程序通常在启动时生成一个PID文件并存入&#x2F;var&#x2F;run目录中，以记录该后台进程的PID。</li>
<li>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等</li>
</ul>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><hr>
<p>守护进程（daemon）是生存期长的一种进程，没有控制终端。它们常常在系统引导装入时启动，仅在系统关闭时才终止。UNIX系统有很多守护进程，守护进程程序的名称通常以字母“d”结尾：例如，<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/Syslog">syslogd</a> 就是指管理系统日志的守护进程。通过ps进程查看器 <code>ps -efj</code> 的输出实例</p>
<p>守护进程是在后台运行不受终端控制的进程（如输入、输出等），一般的网络服务都是以守护进程的方式运行。守护进程脱离终端的主要原因有两点：</p>
<ol>
<li>用来启动守护进程的终端在启动守护进程之后，需要执行其他任务。</li>
<li>如其他用户登录该终端后，以前的守护进程的错误信息不应出现）由终端上的一些键所产生的信号（如中断信号），不应对以前从该终端上启动的任何守护进程造成影响。要注意守护进程与后台运行程序（即加＆启动的程序）的区别。</li>
</ol>
<p>**怎样创建守护进程 ？ **</p>
<p>在创建守护进程之前，需要了解一些基础概念：</p>
<p>进程组 ：</p>
<ul>
<li>每个进程除了有一个进程ID之外，还属于一个进程组</li>
<li>进程组是一个或多个进程的集合，同一进程组中的各进程接收来自同一终端的各种信号</li>
<li>每个进程组有一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BB%84%E9%95%BF%E8%BF%9B%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:529315259%7D">组长进程</a>。组长进程的进程组ID等于其进程ID</li>
</ul>
<p>会话：会话（session）是一个或多个进程组的集合，进程调用 setsid 函数（原型：<code>pid_t setsid(void)</code> ）建立一个会话。</p>
<p>  进程调用 setsid 函数建立一个新会话，如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事：</p>
<ul>
<li>该进程变成新会话的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BC%9A%E8%AF%9D%E9%A6%96%E8%BF%9B%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:529315259%7D">会话首进程</a>（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话的唯一进程。</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID</li>
<li>该进程没有控制终端。如果调用setsid之前该进程有一个控制终端，那么这种联系也被切断</li>
</ul>
<p>如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID是重新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。</p>
<p>  对于守护进程，需要遵守一些编写规则：</p>
<ul>
<li>在后台运行：为避免挂起控制终端，将守护进程放入后台运行。方法亦即在进程中调用 fork 后使父进程终止，子进程则继续在后台运行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>脱离控制终端，登陆会话和进程组：调用 setsid 后会发生的3件事上面已经阐述：（a）成为新会话的首进程，（b）成为一个新进程组的组长进程、（c）没有控制终端</li>
<li>禁止进程重新打开控制终端：进程已经成为无终端的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BC%9A%E8%AF%9D%E7%BB%84%E9%95%BF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:529315259%7D">会话组长</a>。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (pid = fork()) != <span class="number">0</span>)<span class="comment">/* parent */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误</li>
<li>当前目录更改为根目录：从父进程处继承过来的当前工作目录可能在一个挂载的文件系统，所以如果守护进程的当前工作目录在一个挂载文件中，那么该文件系统就不能被卸载</li>
<li>关闭不再需要的文件描述符：这使守护进程不再持有从其父进程继承来的任何文件描述符</li>
</ul>
<h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><p>服务器的调试和维护都需要一个专业的日志系统。Linux提供一个守护进程来处理系统日志：<strong>syslogd</strong>, 不过现在的Linux系统上使用的都是它的升级版：<strong>rsyslogd</strong>.</p>
<p>rsyslogd 守护进程既能接收用户进程输出的日志，又能接收内核日志。用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型(AF_UNIX)的文件&#x2F;dev&#x2F;log中，rsyslogd 则监听该文件以获取用户进程的输出。</p>
<p>rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。默认情况下，调试信息会保存至&#x2F;varlog&#x2F;debug文件，普通信息保存至&#x2F;var&#x2F;log&#x2F;messages文件，内核消息则保存至&#x2F;var&#x2F;log&#x2F;kerm.log文件。不过，日志信息具体如何分发，可以在rsyslogd的配置文件中设置。rsyslogd 的主配置文件是&#x2F;ete&#x2F;rsyslog.conf。</p>
<img src="https://s2.loli.net/2022/02/11/jaxQomdguM7VY5q.png">

<p>应用程序使用syslog函数与rsyslogd守护进程通信。syslog 函数的定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">syslog</span><span class="params">( <span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span>* message, ... )</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数采用可变参数(第二个参数message和第三个参数……)来结构化输出。<strong>priority</strong> 参数是所谓的<strong>设施值与日志级别</strong>的按位或。设施值的默认值是<strong>LOG_USER。</strong></p>
<p>下面这个函数可以改变syslog的默认输出方式，进一步结构化日志内容:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openlog</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* ident，<span class="type">int</span> logopt, <span class="type">int</span> facility )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>ident</strong>参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。<strong>logopt</strong> 参数对后续syslog调用的行为进行配置。<strong>facility</strong>参数可用来修改syslog函数中的默认设施值。</p>
<p>日志的过滤也很重要。程序在开发阶段可能需要输出很多调试信息，而发布之后我们又需要将这些调试信息关闭。解决这个问题的方法并不是在程序发布之后删除调试代码(因为日后可能还需要用到)，而是简单地设置<strong>日志掩码</strong>，使日志级别大于日志掩码的日志信息被系统忽略。下面这个函数用于设置syslog的日志掩码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> setlogmask（<span class="type">int</span> maskpri );</span><br></pre></td></tr></table></figure>

<p><strong>maskpri</strong>参数指定日志掩码值。该函数始终会成功，它返回调用进程先前的日志掩码值。最后，不要忘了使用如下函数<strong>关闭</strong>日志功能:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys1og.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="系统资源的限制"><a href="#系统资源的限制" class="headerlink" title="系统资源的限制"></a>系统资源的限制</h3><p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制(CPU数量、内存数量等)、系统策略限制(CPU 时间等)，以及具体实现的限制(比如文件名的最大长度)。Linux系统资源限制可以通过如下一对函数来读取和设置:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">finclude &lt;sys/resource.h&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrlimit</span><span class="params">( <span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setrlimit</span><span class="params">( <span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim )</span></span>;</span><br><span class="line"></span><br><span class="line">rlim参数是rlimit结构体类型的指针，rlimit 结构体的定义如下:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rlimit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>rlim_t是一个整数类型，它描述资源级别。<strong>rlim_cur</strong>成员指定资源的<strong>软限制</strong>，<strong>rlim_max</strong>成员指定资源的<strong>硬限制</strong>。软限制是一个建议性的、最好不要超越的限制，如果超越的话，系运行的程序才能增加硬限制。</p>
<img src="https://s2.loli.net/2022/02/11/dLKhXw1AcGJp7jR.jpg">



<h3 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h3><p>获取进程当前工作目录和改变进程工作目录的函数分别是:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd .h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getcwd</span><span class="params">( <span class="type">char</span>* buf, <span class="type">size_t</span> size )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* path )</span></span>;</span><br></pre></td></tr></table></figure>

<p>buf参数指向的内存用于存储进程当前工作目录的<strong>绝对</strong>路径名，其大小由size参数指定。</p>
<p><strong>getcwd</strong> 函数成功时返回一个指向目标存储区(buf 指向的缓存区或是getcwd在内部动态创建的缓存区)的指针，失败则返回NULL并设置errno.</p>
<p><strong>chdir</strong>函数的path 参数指定要切换到的目标目录。它成功时返回0, 失败时返回-1并设置errno。</p>
<p>改变进程根目录的函数是chroot其定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd. h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chroot</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* path )</span> </span>;</span><br></pre></td></tr></table></figure>

<p>path参数指定要切换到的目标根目录。它成功时返回0，失败时返回-1。但它并不改变当前进程的工作目录</p>
<h3 id="服务器程序后台化"><a href="#服务器程序后台化" class="headerlink" title="服务器程序后台化"></a>服务器程序后台化</h3><p>让一个进程以守护进程的方式运行。</p>
<p>以下是示例的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考《APUE》</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">daemonize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>					i, fd0, fd1, fd2;</span><br><span class="line">	<span class="type">pid_t</span>				pid;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rlimit</span>		rl;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sigaction</span>	sa;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear file creation mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get maximum number of file descriptors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">getrlimit</span>(RLIMIT_NOFILE, &amp;rl) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t get file limit&quot;</span>, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Become a session leader to lose controlling TTY.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t fork&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">setsid</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure future opens won&#x27;t allocate controlling TTYs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sa.sa_handler = SIG_IGN;</span><br><span class="line">	<span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">	sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t ignore SIGHUP&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t fork&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Change the current working directory to the root so</span></span><br><span class="line"><span class="comment">	 * we won&#x27;t prevent file systems from being unmounted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t change directory to /&quot;</span>, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Close all open file descriptors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rl.rlim_max == RLIM_INFINITY)</span><br><span class="line">		rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rl.rlim_max; i++)</span><br><span class="line">		<span class="built_in">close</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attach file descriptors 0, 1, and 2 to /dev/null.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	fd0 = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">	fd1 = <span class="built_in">dup</span>(<span class="number">0</span>);</span><br><span class="line">	fd2 = <span class="built_in">dup</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the log file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">openlog</span>(cmd, LOG_CONS, LOG_DAEMON);</span><br><span class="line">	<span class="keyword">if</span> (fd0 != <span class="number">0</span> || fd1 != <span class="number">1</span> || fd2 != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;unexpected file descriptors %d %d %d&quot;</span>,</span><br><span class="line">		  fd0, fd1, fd2);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux 提供了完成同样功能的库函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd. h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">daemon</span><span class="params">( <span class="type">int</span> nochdir, <span class="type">int</span> noclose )</span> </span>;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>nochdir</strong> 参数用于指定是否改变工作目录，如果给它传递0, 则工作目录将被设置为“1”(根目录)，否则继续使用当前工作目录。noclose 参数为0时，标准输入、标准输出和标准错误输出都被<strong>重定向到&#x2F;dev&#x2F;null</strong>文件，否则依然使用原来的设备。该函数成功时返回0，失败则返回-1并设置errno。</p>
<h2 id="高性能服务器程序框架"><a href="#高性能服务器程序框架" class="headerlink" title="高性能服务器程序框架"></a>高性能服务器程序框架</h2><hr>
<p>我们按照服务器的一般原理，将服务器解构为如下三个模块：</p>
<ul>
<li><p>I&#x2F;O处理单元，我们将介绍I&#x2F;O处理单元的四种I&#x2F;O模型和两种高效事件处理方式</p>
</li>
<li><p>逻辑单元，我们将介绍逻辑单元的两种高效并发模式，以及高效的逻辑处理方式——有限状态机</p>
</li>
<li><p>存储单元</p>
</li>
</ul>
<hr>
<h3 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h3><h4 id="1-C-x2F-S模型"><a href="#1-C-x2F-S模型" class="headerlink" title="1. C&#x2F;S模型"></a>1. C&#x2F;S模型</h4><p>TCP&#x2F;IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有机器都是对等的。但由于资源都被数据提供者所垄断，所以几乎所有的网络应用程序都很自然地采用了C&#x2F;S模型：所有客户端通过访问服务器来获取所需的服务。</p>
<p>服务器启动后，首先创建一个或多个监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户端连接。服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接了。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I&#x2F;O模型来监听这一事件。I&#x2F;O模型有多种。服务器使用的是I&#x2F;O复用技术之一的<a href="#select">select</a>系统调用。当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。</p>
<p>在图8.2中，服务器给客户端分配的逻辑单元是由fork系统调用创建的子进程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端接收到服务器反馈的结果之后，可以继续向服务器发送请求，也可以立即主动关闭连接。</p>
<img src="https://s2.loli.net/2022/02/11/jUXRtgdYAw4nV6m.png">



<h4 id="2-P2P模型"><a href="#2-P2P模型" class="headerlink" title="2. P2P模型"></a>2. P2P模型</h4><p>P2P模型模型比C&#x2F;S模型更符合网络通信的实际情况。它摒弃了以往以服务器为中心的格局，让网络上所有主机重新回归对等的地位。</p>
<p>P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样自愿能够充分、自由地共享。云计算机群可以看做P2P模型的典范。但P2P模型的缺点也很明显：当用户之间传输的请求过多时，网络的负载将加重。</p>
<p>实际使用的P2P模型通常带有一个专门的发现服务器，如图8-3所示。发现服务器通常还提供查找服务，使每个客户都能尽快找到自己需要的资源。</p>
<h3 id="服务器编程框架"><a href="#服务器编程框架" class="headerlink" title="服务器编程框架"></a>服务器编程框架</h3><p>虽然服务器程序种类繁多，但其基本框架是相同的，不同之处在于逻辑处理</p>
<p><img src="https://s2.loli.net/2022/02/11/lZFPHVLXiznyEu7.png" alt="img"></p>
<p>该图既能用来描述一台服务器，也能用来描述一个服务器集群</p>
<img src="https://s2.loli.net/2022/02/11/guEbM6ywQXVpCSm.png" alt="image-20220209140249229" style="zoom:80%;">

<img src="https://s2.loli.net/2022/02/11/kd1InBDPZHcvFNh.png" alt="image-20220209140300668" style="zoom:80%;">

<p>I&#x2F;O处理单元是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户端连接，接收客户数据，将服务器响应数据返回给客户端。但是，数据的收发不一定在I&#x2F;O处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。对于一个服务器机群来说，I&#x2F;O处理单元是一个专门的接入服务器。它实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务。<br>一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给I&#x2F;O处理单元或者直接发送给客户端。对服务器机群而言，一个逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理。</p>
<p>网络存储单元可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单元。</p>
<p>请求队列是各单元之间的通信方式的抽象。I&#x2F;O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制协调处理竞态条件。请求队列通常被实现为池的一部分。对于服务器机群而言，请求队列是各台服务器之间预先建立的、静态的、永久的TCP连接。这种TCP连接能提高服务器之间交换数据的效率，因为它避免了动态建立TCP连接导致的额外的系统开销。</p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>同步IO与异步IO：</p>
<ul>
<li><p>阻塞I&#x2F;O、I&#x2F;O复用和信号驱动I&#x2F;O都是同步I&#x2F;O模型。因为在这三种I&#x2F;O模型中，I&#x2F;O的读写操作，都是在I&#x2F;O事件发生之后，由应用程序完成的。而对异步I&#x2F;O而言，用户可以直接对I&#x2F;O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I&#x2F;O操作完成之后内核通知应用程序的方式。</p>
</li>
<li><p>异步I&#x2F;O的读写操作总是立即返回，而不论I&#x2F;O是否是阻塞的，因为真正的读写操作已经由内核接管。也就是说，同步I&#x2F;O模型要求用户代码自行执行I&#x2F;O操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区），而异步I&#x2F;O机制则由内核来执行I&#x2F;O操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的）。可以这样认为，同步I&#x2F;O向应用程序通知的是I&#x2F;O就绪事件，而异步I&#x2F;O向应用程序通知的是I&#x2F;O完成事件。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/11/o7C6RpFy3AgMckh.png" alt="image-20220209154248787"></p>
<h3 id="两种高效的事件处理方式"><a href="#两种高效的事件处理方式" class="headerlink" title="两种高效的事件处理方式"></a>两种高效的事件处理方式</h3><p>服务器程序通常需要处理三类事件：I&#x2F;O事件、信号及定时事件。<br>同步I&#x2F;O模型通常用于实现Reactor模式，异步I&#x2F;O则用于实现Proactor模式。</p>
<h4 id="1-Reactor"><a href="#1-Reactor" class="headerlink" title="1. Reactor"></a>1. Reactor</h4><p>同步IO模型（以epoll_wait为例）实现的Reactor模式的工作流程：</p>
<ol>
<li><p>主线程往epoll内核事件表中注册socket上的读就绪事件。</p>
</li>
<li><p>主线程调用epoll_wait等待socket上有数据可读。</p>
</li>
<li><p>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</p>
</li>
<li><p>睡眠在请求队列上的工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</p>
</li>
<li><p>主线程调用epoll_wait等待socket可写。</p>
</li>
<li><p>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</p>
</li>
<li><p>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/11/hD6TcXHBtguqPjl.png" alt="img"></p>
<p><strong>工作线程从请求队列中取出事件后，将根据事件的类型来决定如何处理它</strong>：对于可读事件，执行读数据和处理请求的操作；对于可写事件，执行写数据的操作。因此，在Reactor模式中，没必要区分所谓的“读工作线程”和“写工作线程”。</p>
<h4 id="2-Proactor"><a href="#2-Proactor" class="headerlink" title="2. Proactor"></a>2. Proactor</h4><p>与Reactor模式不同，<strong>Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理</strong> （关键之处），工作线程仅仅负责业务逻辑。<br>使用异步I&#x2F;O模型（以aio_read和aio_write为例）实现的Proactor模式的工作流程是：</p>
<ol>
<li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序。（以信号为例）</li>
<li>主线程继续处理其他逻辑。</li>
<li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。（以信号为例）</li>
<li>主线程继续处理其他逻辑。</li>
<li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/11/p8fkyGTEqgsn61V.png" alt="image-20220209164003091"></p>
<p><strong>连接socket上的读写事件是通过aio_read&#x2F;aio_write向内核注册的</strong>，因此内核将通过信号来向应用程序报告连接socket上的读写事件。所以，主线程中的epoll_wait调用仅能检测监听socket上的连接请求事件，而不能用来检测连接socket上的读写事件。</p>
<h3 id="两种高效的并发模式"><a href="#两种高效的并发模式" class="headerlink" title="两种高效的并发模式"></a>两种高效的并发模式</h3><h4 id="1-半同步-x2F-半异步模式"><a href="#1-半同步-x2F-半异步模式" class="headerlink" title="1. 半同步&#x2F;半异步模式"></a>1. 半同步&#x2F;半异步模式</h4><p>这里的“同步”和“异步”和前面的IO的“同步”“异步”是完全不同的概念。在IO模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种IO事件（是就绪事件还是完成事件），以及该由谁来完成IO读写（是应用程序还是内核）。</p>
<p>在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。</p>
<p><img src="https://s2.loli.net/2022/02/11/GIQEFW28Dm6pirf.png" alt="img"></p>
<ul>
<li>异步线程的执行效率高，实时性强，是很多嵌入式系统采用的模型。但编写异步方式执行的程序相对复杂，难于调试和扩展，而且不适合于大量的并发。</li>
<li>同步线程则相反，它虽然效率相对较低，实时性较差，但逻辑简单。</li>
</ul>
<p>在这种模式中，同步线程用于处理客户逻辑，充当逻辑单元，异步线程用于处理IO事件，相当于IO处理单元。异步线程监听到客户请求后，就将其封装为请求对象插入到请求队列中。 请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。具体选择哪个工作线程，这要看请求队列的实现方式。</p>
<p><strong>半同步&#x2F;半异步工作模式流程：</strong></p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20220209171510849-16443981126134.png" alt="image-20220209171510849"></p>
<h5 id="半同步-x2F-半反应堆模式"><a href="#半同步-x2F-半反应堆模式" class="headerlink" title="半同步&#x2F;半反应堆模式"></a>半同步&#x2F;半反应堆模式</h5><p><img src="https://s2.loli.net/2022/02/11/yIfctridFjJwCsS.png" alt="image-20220209172301750"></p>
<p>异步线程只有一个，由主线程充当。它负责监听所有socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。这种模式中，他要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。</p>
<p>缺点：</p>
<ol>
<li><p>主线程和工作线程共享请求队列，主线程往请求队列添加任务和工作线程从请求队列取出任务都需要给队列加锁</p>
</li>
<li><p>每个工作线程同一时间只能处理一个客户请求，工作线程的切换将耗费大量CPU时间</p>
</li>
</ol>
<h5 id="高效的半同步-x2F-半反应堆模式"><a href="#高效的半同步-x2F-半反应堆模式" class="headerlink" title="高效的半同步&#x2F;半反应堆模式"></a>高效的半同步&#x2F;半反应堆模式</h5><p>它的每个所有线程都是异步线程。主线程只管监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I&#x2F;O操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据，工作线程检测到管道有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表中。</p>
<p>每个线程（主线程和工作线程）都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同步&#x2F;半异步模式中，每个线程都工作在异步模式</p>
<p><img src="https://s2.loli.net/2022/02/11/7Kr9sWk4cYbGMDt.png" alt="image-20220209172845562"></p>
<h4 id="2-主-x2F-从模式"><a href="#2-主-x2F-从模式" class="headerlink" title="2. 主&#x2F;从模式"></a>2. 主&#x2F;从模式</h4><p>领导者&#x2F;追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任何时间点，程序都仅有一个领导者线程，它负责监听I&#x2F;O事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I&#x2F;O事件，首先要从线程池中推选出新的领导者线程，然后处理I&#x2F;O事件。此时，新的领导者等待新的I&#x2F;O事件，而原来的领导者则处理I&#x2F;O事件，二者实现了并发。<br><img src="https://s2.loli.net/2022/02/11/4wkFmZ1Xi9YSUQ7.png" alt="image-20220210003942857"></p>
<p>缺点是只支持一个事件源集合</p>
<h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><p>它是逻辑单元内部的一种高效编程方法</p>
<h3 id="提高服务器性能的其他建议"><a href="#提高服务器性能的其他建议" class="headerlink" title="提高服务器性能的其他建议"></a>提高服务器性能的其他建议</h3><ol>
<li><strong>池</strong></li>
</ol>
<p>服务器硬件资源相对“充裕”，那么提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其运行效率。这就是池（pool）的概念。池是一种资源的集合，这组资源在服务器启动之初就被完全创建并初始化，这称为静态资源分配。速度要快得多，因为分配系统资源的系统调用都是很耗时的。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。从最终效果来看，池相当于服务器管理系统资源的应用层设施，它避免了服务器对内核的频繁访问。</p>
<p>按照资源类型分类：<br>内存池：通常用于socket的接收缓存和发送缓存。<br>进程池、线程池：并发编程常用“伎俩”。<br>连接池：常用于服务器或服务器集群的内部永久连接。</p>
<ol start="2">
<li><strong>数据复制（避免不必要的数据复制）</strong></li>
</ol>
<p>应该避免不必要的数据复制，尤其当数据复制发生在用户代码和内核之间的时候。如果内核可以直接处理从socket或者文件读入的数据，则应用程序就没有必要将这些数据从内核缓冲区复制到应用程序缓冲区。如ftp服务器，服务器只需检测目标文件是否存在，以及客户是否有读取权限，而不用关心文件具体内容。就可以使用“零拷贝”sendfile来直接将其发送给客户。</p>
<p>此外，用户代码内部（不访问内核）的数据复制也是应该避免的。如两个工作进程之间要传递大量的数据时，我们就应该考虑使用共享内存来在它们之间直接共享这些数据，而不是使用管道或者消息队列来传递</p>
<ol start="3">
<li><strong>上下文切换和锁</strong></li>
</ol>
<p>并发程序必须考虑上下文切换（context switch）的问题，即进程线程切换导致的系统开销。即使是IO密集型的服务器，也不应该使用过多的工作线程（或进程，下同），否则切换将占用大量CPU时间，服务器真正用于业务逻辑的CPU时间比重就显得不足了。因此为每个客户连接都建立一个服务器线程的模型不可取。之前描述的半同步半异步模型是一个比较合理的解决方案，它允许一个线程同时处理多个客户连接。此外，多线程服务器的一个优点是不同的线程可以同时运行在不同的cpu上。当线程数量不大于cpu的数目时，上下文切换就不是问题了。</p>
<p>并发程序需要考虑的另一个问题是共享资源的加锁保护。锁通常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源。因此，服务器如果有更好的解决方案，就应该避免使用锁。如果服务器必须使用锁，则可以考虑减小锁的粒度，比如使用读写锁。当所有工作线程都只读取一块共享内存的内容时，读写锁并不会增加系统的额外开销。只有当其中一个工作线程需要写这块内存时，系统才必须去锁住这块区域。</p>
<h2 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h2><hr>
<p>迅速看原理，勇敢看源码</p>
<h3 id="select系统调用"><a href="#select系统调用" class="headerlink" title="select系统调用"></a><a id="select">select系统调用</a></h3><p>作用：</p>
<p>  在一段指定时间内，监听用户感兴趣的文件描述符的可读、可写和异常等事件。</p>
<p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span> <span class="params">( <span class="type">int</span> nfds, fd_set* readfds, fde_set* writefds, fd_set* exceptfds, <span class="keyword">struct</span> timeval* timeout )</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<ul>
<li>nfds： 指定被监听的文件描述符的总数，通常为所有文件描述符中的最大值+1</li>
<li>readfds、writefds 、exceptfds： 可读、可写和异常等事件对应的文件描述符集合。</li>
<li>fd_set结构：仅包含一个整型数组，该数组的每个元素的每一位标记了一个文件描述符。fd_set能容纳的文件描述符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述符的总量。</li>
</ul>
<p>​    <strong>select中的fd_set集合容量的限制为FD_SETSIZE，一般为1024 。修改它，需要重新编译内核。</strong></p>
<p>fd_set相关的位操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="built_in">FD_ZERO</span>( fd_set *fdset );</span><br><span class="line"><span class="built_in">FD_SET</span>( <span class="type">int</span> fd, fd_set *fdset );</span><br><span class="line"><span class="built_in">FD_CLR</span>( <span class="type">int</span> fd, fd_set *fdset );</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">( <span class="type">int</span> fd, fd_set *fdset )</span></span>;</span><br><span class="line"><span class="comment">/*对于fd_set类型通过上面四个宏来操作：</span></span><br><span class="line"><span class="comment">    FD_ZERO(fd_set *fdset) 将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。</span></span><br><span class="line"><span class="comment">    FD_SET(int fd,fd_set *fdset) 用于在文件描述符集合中增加一个新的文件描述符。</span></span><br><span class="line"><span class="comment">    FD_CLR(int fd, fd_set *fdset) 用于在文件描述符集合中删除一个文件描述符。</span></span><br><span class="line"><span class="comment">    FD_ISSET(int fd,fd_set *fdset) 用于测试指定的文件描述符是否在该集合中。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">      先调用宏FD_ZERO将指定的fd_set清零，然后调用宏FD_SET将需要测试的fd加入fd_set，接着调用函数select测试fd_set中的所有fd，最后用宏FD_ISSET检查某个fd在函数select调用后，相应位是否仍然为1。*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>timeout：设置select的超时时间。这是timeval结构指针，用来告诉内核select等待多久。<strong>不过我们不能完全信任select调用返回后的timeout值，比如调用失败时，timeout值是不确定的。</strong>timeval结构体如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">long</span> tv_sec;       \\秒数</span><br><span class="line">     <span class="type">long</span> tv_usec;     \\微秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果给timeout变量的tv_sec成员和tv_usec成员都传递0，则select将立即返回。如果给timeout传递NULL，则select将一直阻塞，直到某个文件描述符就绪。</p>
<p>返回状态：</p>
<ul>
<li>select成功时返回就绪（可读、可写和异常）文件描述符的总数。</li>
<li>如果在超时时间内没有任何文件描述符就绪，select将返回0。</li>
<li>select失败时返回-1并设置errno。</li>
<li>如果select 等待期间，程序接收到信号，则select立即返回-1，并设置errno为EINTR。</li>
</ul>
<p>文件描述符就绪条件</p>
<p>可读：</p>
<ul>
<li>socket内核接收缓冲区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地对该socket，并且读操作返回的字节数大于0。</li>
<li>socket通信的对方关闭连接，此时读操作返回0。</li>
<li>监听socket上有新的连接请求。</li>
<li>socekt上有未处理的错误，此时我们可以使用getsockopt来读取和清除该错误。</li>
</ul>
<p>可写：</p>
<ul>
<li>socket内核发送缓冲区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</li>
<li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将出发一个SIGPIPE信号。</li>
<li>socket使用非阻塞connect连接成功或者失败之后。</li>
<li>socket上有未处理的错误，此时我们可以使用getsockopt来读取和清除该错误。</li>
</ul>
<p>异常：</p>
<ul>
<li><strong>socket上接收到带外数据。</strong></li>
</ul>
<p>处理带外数据</p>
<p><strong>socket上接收到普通数据和带外数据都将使select返回，但socket处于不同的就绪状态：前者处于可读状态，后者处于异常状态。</strong></p>
<h3 id="poll系统调用"><a href="#poll系统调用" class="headerlink" title="poll系统调用"></a>poll系统调用</h3><p>poll系统调用</p>
<p>作用：和select类型，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。</p>
<p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span> <span class="params">( <span class="keyword">struct</span> pollfd* fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout )</span></span>;</span><br></pre></td></tr></table></figure>



<p>函数说明：</p>
<ul>
<li>fds：一个pollfd结构类型的数组，指定我们所感兴趣的文件描述符上发生的可读，可写和异常事件。</li>
</ul>
<p>pollfd结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;                <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events;    <span class="comment">/* 注册的事件 */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* 实际发生的事件，由内核填充 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，fd成员指定文件描述符；events 成员告诉poll监听fd上的哪些事件，它是一系列事件的按位或；revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件。 poll 支持的事件类型如下：</p>
<p><img src="https://s2.loli.net/2022/02/11/rSVCZPkidfwuH5W.png" alt="img"></p>
<p><img src="https://s2.loli.net/2022/02/11/cZVCj4iTYSJ2Qm5.png" alt="image-20220211110816948"></p>
<ul>
<li>nfds ：指定被监听事件集合fds的大小。其类型nfds_t 的定义如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">nfds_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>timeout ：指定poll的超时值，单位是毫秒。当timeout 为-1时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。</li>
</ul>
<p><strong>poll系统调用轮询描述符的数量的限制：一个进程所能打开的最大文件描述符有关。可以通过调整内核参数、ulimit -n命令、setrlimit函数。</strong></p>
<ul>
<li>一个系统所能打开的文件描述符的最大数也是有限制的，跟内存有关，可以通过 &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 调整。</li>
<li>一个进程所能打开的文件描述符最大值，可以通过调整内核参数、ulimit -n命令、setrlimit函数。</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>特点：</p>
<p>  epoll是linux上特有的IO复用函数，它在实现上和使用上与select有很大的差异。首先epoll使用一组函数完成任务，而不是单个函数，其次， epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。但需要一个额外的文件描述来唯一标识内核中的这个事件表。</p>
<p>这个事件表的文件描述符由如下函数来创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span> <span class="params">( <span class="type">int</span> size )</span></span>;</span><br></pre></td></tr></table></figure>

<p>size参数现在不起作用，只是给内核一个提示，告诉他事件表需要多大，该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的事件表</p>
<p>操作内核事件表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span> <span class="params">( <span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event )</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<ul>
<li>fd：要操作的文件描述符</li>
<li>op：指定操作类型</li>
<li>epfd：内核事件表</li>
<li>event：指定事件，它是epoll_event结构指针类型，</li>
</ul>
<p>epoll_event定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">__unit32_t</span> events;    <span class="comment">/* epoll事件 */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;    <span class="comment">/* 用户数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体说明：</p>
<p>events：描述事件类型，和poll支持的事件类型基本相同（两个额外的事件：EPOLLET和EPOLLONESHOT，高效运作的关键）</p>
<p>data成员：存储用户数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* ptr;              <span class="comment">/* 指定与fd相关的用户数据 */</span></span><br><span class="line">    <span class="type">int</span> fd;                   <span class="comment">/* 指定事件所从属的目标文件描述符 */</span></span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>



<p>op参数指定操作类型：</p>
<ul>
<li>EPOLL_CTL_ADD：往事件表中注册fd上的事件</li>
<li>EPOLL_CTL_MOD：修改fd上的注册事件</li>
<li>EPOLL_CTL_DEL：删除fd上的注册事件</li>
</ul>
<p><strong>epoll_wait函数</strong></p>
<p>主要接口</p>
<p>作用：在一段超时时间内，等待一组文件描述符上的事件</p>
<p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span> <span class="params">( <span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout )</span></span>;</span><br></pre></td></tr></table></figure>



<p>函数说明：</p>
<p>返回：成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno</p>
<p>参数：</p>
<ul>
<li><p>timeout：与poll相同</p>
</li>
<li><p>maxevents：指定最多监听多少个事件</p>
</li>
<li><p>events：检测到事件，将所有就绪的事件从内核事件表（由第一个参数epfd来指定）中复制到它的第二个参数events指向的数组中。</p>
<p>这个数组只用于输出检测到的就绪事件。而不像select与poll中的数组既用于传入用户注册的事件，又用于输出内核输出的就绪事件。</p>
<p>所以效率较高。</p>
</li>
</ul>
<p>LT和ET模式</p>
<p>对文件操作符的操作模式：</p>
<ul>
<li><strong>LT：</strong>电平触发，<strong>默认的工作模式。</strong>当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，<strong>当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。</strong></li>
<li><strong>ET：</strong>边沿触发，高效工作模式。文件描述符注册为EPOLLET事件，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，<strong>应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。</strong></li>
</ul>
<p>区别：ET模式在很大程度上降低了同一个epoll事件被重复出发的参数，因此效率要比LT模式高。</p>
<p><strong>注意：ET 模式要求socket为非阻塞模式，如果是阻塞的，那么读或写操作将会因为没有后续事件而一直处于阻塞状态（饥渴状态）。LT模式可以是阻塞或者非阻塞。</strong></p>
<p>LT与ET模式的实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: 9-3.cpp</span></span><br><span class="line"><span class="comment">    &gt; Created Time: Sat 03 Feb 2018 10:35:56 PM PST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置文件描述符为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以两种不同模式将事件注册到epoll中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> enable_et)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span>(enable_et) event.events |= EPOLLET;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lt</span><span class="params">(epoll_event* events, <span class="type">int</span> number, <span class="type">int</span> epollfd, <span class="type">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此处的作用是？</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(sockfd == listenfd) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="built_in">addfd</span>(epollfd, connfd, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">close</span>(sockfd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">et</span><span class="params">(epoll_event* events, <span class="type">int</span> number, <span class="type">int</span> epollfd, <span class="type">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span>(sockfd == listenfd) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">addfd</span>(epollfd, connfd, <span class="literal">true</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="comment">//这段代码不会被重复触发，所以我们循环读取</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> ret = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//非阻塞模式的I/O，当下面的条件成立表示数据已经全部取走</span></span><br><span class="line">                    <span class="keyword">if</span>((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">close</span>(sockfd);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) <span class="built_in">close</span>(sockfd);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">    <span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addfd</span>(epollfd, listenfd, <span class="literal">true</span>);<span class="comment">//设置触发方式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//lt(events, ret, epollfd, listenfd);</span></span><br><span class="line">        <span class="built_in">et</span>(events, ret, epollfd, listenfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>测试结果：</strong></p>
<p>ET模式：<img src="https://s2.loli.net/2022/02/11/LusjBnceqmVR4Jw.png" alt="image-20220210224210698"></p>
<p>LT模式：<img src="https://s2.loli.net/2022/02/11/r1vJg6LSYw7xBe9.png" alt="image-20220210224237886"></p>
<h3 id="三组I-x2F-O复用函数的比较"><a href="#三组I-x2F-O复用函数的比较" class="headerlink" title="三组I&#x2F;O复用函数的比较"></a>三组I&#x2F;O复用函数的比较</h3><p>select和poll都只能工作在相对低效的LT模式，而epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件。该事件能进一步减少可读、可写和异常等事件被触发的次数。</p>
<p>从实现原理上来说，select和poll采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是O(n)。epoll则不同，它采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就该文件描述符上对应的事件插入就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法时间复杂度是O(1)。</p>
<table>
<thead>
<tr>
<th align="center">系统调用</th>
<th><strong>select</strong></th>
<th><strong>poll</strong></th>
<th><strong>epoll</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">事件集合</td>
<td>用户通过3个参数分别传入感兴趣的可读、可写及异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。<strong>这使得用户每次调用select都要重置这3个参数</strong></td>
<td>统一处理所有事件类型，因此只需要一个事件集参数。用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件</td>
<td>内核通过一个事件表直接管理用户感兴趣的所有事件。因此每次调用epoll_wait时，无需反复传入用户感兴趣的事件。epoll_wait系统调用的参数events仅用来反馈就绪的事件</td>
</tr>
<tr>
<td align="center">应用程序索引就绪文件描述符的时   间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td align="center">最大支持文件描述符数</td>
<td>一般有最大值限制（<strong>FD_SETSIZE 为1024，修改后需重新编译内核</strong>)</td>
<td>65535（<strong>一个进程所能打开的最大文件描述符数量，ulimit -n或者setrlimit函数</strong>）</td>
<td>65535（<strong>系统能打开的最大文件描述符数量，&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</strong>）</td>
</tr>
<tr>
<td align="center">工作模式</td>
<td>LT</td>
<td>LT</td>
<td>支持ET高效模式</td>
</tr>
<tr>
<td align="center">内核实现和工作效率</td>
<td>采用轮询方式检测就绪事件时间复杂度：O(n)</td>
<td>采用轮询方式检测就绪事件时间复杂度：O(n)</td>
<td>采用回调方式检测就绪事件事件复杂度：O(1)</td>
</tr>
</tbody></table>
<p>​    对于poll函数，内核每次修改的是pollfd结构体的revents成员，而events成员保持不变，因此下次调用poll时应用程序无须重置pollfd类型的事件集参数。由于每次select和poll调用都返回整个用户注册的事件集合（其中包括就绪的和未就绪的的），所以应用程序索引就绪文件描述符的时间复杂度为O(n)。epoll则采用与select和poll完全不同的方式来管理用户注册的事件。它在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中添加、删除、修改事件。这样每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入这些事件。epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引的就绪文件描述符的时间复杂度达到0(1)。</p>
<p>需要说明的是：</p>
<p>​    epoll的效率未必一定比select和poll高。当活动连接比较多的时候，epoll_wait的效率未必比select和poll高，因为此时回调函数被触发的过于频繁。<strong>所以，epoll_wait适用于连接数量多，但活动连接较少的情况。</strong></p>
<p>非阻塞式connect</p>
<p>聊天室程序</p>
<p>同时处理TCP与UDP服务</p>
<h3 id="IO多路复用函数机制详谈："><a href="#IO多路复用函数机制详谈：" class="headerlink" title="IO多路复用函数机制详谈："></a>IO多路复用函数机制详谈：</h3><hr>
<p>参考文献：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanguhung/p/10145755.html">IO多路复用机制详解 - Yeang - 博客园 (cnblogs.com)</a></p>
<h3 id="epoll-机制详谈："><a href="#epoll-机制详谈：" class="headerlink" title="epoll 机制详谈："></a>epoll 机制详谈：</h3><hr>
<p><img src="https://s2.loli.net/2022/02/11/fNvuoMOzJxBnc6G.png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">spin_lock_t</span> lock;            <span class="comment">//对本数据结构的访问</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mutex</span> mtx;            <span class="comment">//防止使用时被删除</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wq;        <span class="comment">//sys_epoll_wait() 使用的等待队列</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> poll_wait; <span class="comment">//file-&gt;poll()使用的等待队列</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllist;    <span class="comment">//事件满足条件的链表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;          <span class="comment">//用于管理所有fd的红黑树</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *ovflist;      <span class="comment">//将事件到达的fd进行链接起来发送至用户空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;            <span class="comment">//用于主结构管理的红黑树</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink;       <span class="comment">//事件就绪队列</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *next;           <span class="comment">//用于主结构体中的链表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd;         <span class="comment">//每个fd生成的一个结构</span></span><br><span class="line">    <span class="type">int</span> nwait;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> pwqlist;     <span class="comment">//poll等待队列</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;          <span class="comment">//该项属于哪个主结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> fllink;         <span class="comment">//链接fd对应的file链表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;  <span class="comment">//注册的感兴趣的事件,也就是用户空间的epoll_event</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<p>参考文献：</p>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/26226">epoll内核源码详解+自己总结的流程_技术交流_牛客网 (nowcoder.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/armlinuxww/article/details/92803381">(163条消息) Epoll原理解析_~~ LINUX ~~-CSDN博客_epoll</a></p>
<h3 id="共享内存技术mmap："><a href="#共享内存技术mmap：" class="headerlink" title="共享内存技术mmap："></a>共享内存技术mmap：</h3><hr>
<h3 id="阻塞IO，非阻塞IO，IO多路复用，信号驱动-IO，异步IO"><a href="#阻塞IO，非阻塞IO，IO多路复用，信号驱动-IO，异步IO" class="headerlink" title="阻塞IO，非阻塞IO，IO多路复用，信号驱动 IO，异步IO"></a>阻塞IO，非阻塞IO，IO多路复用，信号驱动 IO，异步IO</h3><hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rtlin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mumu-lsl.github.io/posts/16108/">https://mumu-lsl.github.io/posts/16108/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mumu-lsl.github.io" target="_blank">Lin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Linux网络编程</a></div><div class="post_share"><div class="social-share" data-image="https://plus.unsplash.com/premium_photo-1661510050360-b8447baf1963?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxzZWFyY2h8MXx8Y2FydG9vbnxlbnwwfHwwfHw%3D&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2e5216dd/"><img class="prev-cover" src="https://s2.loli.net/2023/04/25/yCUd9NoYLRXzeaI.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">定时器</div></div></a></div><div class="next-post pull-right"><a href="/posts/f92d7720/"><img class="next-cover" src="https://s2.loli.net/2023/04/25/Ml2GwJrQNCthEmn.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python中的各项问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/5c237c5f/" title="IO复用"><img class="cover" src="https://images.unsplash.com/photo-1592561199818-6b69d3d1d6e2?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTh8fGNhcnRvb258ZW58MHx8MHx8&auto=format&fit=crop&w=500&q=60" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-10</div><div class="title">IO复用</div></div></a></div><div><a href="/posts/341a9d02/" title="Linux多线程编程"><img class="cover" src="https://s2.loli.net/2022/11/04/hHvKneugsCO7Rb5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-15</div><div class="title">Linux多线程编程</div></div></a></div><div><a href="/posts/716f0d9b/" title="Linux多进程编程"><img class="cover" src="https://s2.loli.net/2022/11/04/uPLWIx6z9NqDJvg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-13</div><div class="title">Linux多进程编程</div></div></a></div><div><a href="/posts/f02c82f1/" title="poll应用——聊天室程序"><img class="cover" src="https://s2.loli.net/2022/11/04/yzHUZnq5PAOJkEQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="title">poll应用——聊天室程序</div></div></a></div><div><a href="/posts/2e29b6af/" title="select应用——非阻塞connect"><img class="cover" src="https://s2.loli.net/2022/11/04/l79ag8sNp5VqPYX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="title">select应用——非阻塞connect</div></div></a></div><div><a href="/posts/2e5216dd/" title="定时器"><img class="cover" src="https://s2.loli.net/2023/04/25/yCUd9NoYLRXzeaI.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-10</div><div class="title">定时器</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">rtlin</div><div class="author-info__description">Lin在此创作, 欢迎各位</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mumu-LSL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/zumumu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Linux高性能服务器编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API"><span class="toc-number">1.1.</span> <span class="toc-text">Linux网络编程基础API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E5%9C%B0%E5%9D%80API"><span class="toc-number">1.1.1.</span> <span class="toc-text">socket地址API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">0.字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1. 通用socket地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">2. 专用socket地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">3. IP地址转换函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E5%9F%BA%E7%A1%80API"><span class="toc-number">1.1.2.</span> <span class="toc-text">socket基础API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-socket%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1. socket（）函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-bind%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2. bind（）函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-listen%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">3. listen（）函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-accept%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">4. accept（）函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">5. 数据读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">6. 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">7. 带外数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">8. 带外标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.9.</span> <span class="toc-text">9. 地址信息函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-socket%E9%80%89%E9%A1%B9"><span class="toc-number">1.1.2.10.</span> <span class="toc-text">10. socket选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AFAPI"><span class="toc-number">1.1.3.</span> <span class="toc-text">网络信息API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-gethostbyname%E5%92%8Cgethostbyaddr"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1. gethostbyname和gethostbyaddr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-getservbyname%E5%92%8Cgetservbyport"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2. getservbyname和getservbyport</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-getaddrinfo"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3. getaddrinfo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-getnameinfo"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">4. getnameinfo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%94%99%E8%AF%AF%E7%A0%81"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">5. 错误码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EEAGAIN-%E4%B8%8E-EWOULDBLOCK"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">关于EAGAIN 与 EWOULDBLOCK</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">高级IO函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">pipe函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup%E5%87%BD%E6%95%B0%E4%B8%8Edup2%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">dup函数与dup2函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readv-x2F-writev-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">readv &#x2F;writev 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendfile%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">sendfile函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-x2F-munmap-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">mmap&#x2F;munmap   函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#splice%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">splice函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tee-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.7.</span> <span class="toc-text">tee 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fcntl%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.8.</span> <span class="toc-text">fcntl函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83"><span class="toc-number">1.3.</span> <span class="toc-text">Linux 服务器程序规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">系统日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">系统资源的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">改变工作目录和根目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E5%8C%96"><span class="toc-number">1.3.5.</span> <span class="toc-text">服务器程序后台化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="toc-number">1.4.</span> <span class="toc-text">高性能服务器程序框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">服务器模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-C-x2F-S%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">1. C&#x2F;S模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-P2P%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">2. P2P模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">服务器编程框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">IO模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">两种高效的事件处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Reactor"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">1. Reactor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Proactor"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">2. Proactor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">两种高效的并发模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%8A%E5%90%8C%E6%AD%A5-x2F-%E5%8D%8A%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">1. 半同步&#x2F;半异步模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5-x2F-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.5.1.1.</span> <span class="toc-text">半同步&#x2F;半反应堆模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E6%95%88%E7%9A%84%E5%8D%8A%E5%90%8C%E6%AD%A5-x2F-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.5.1.2.</span> <span class="toc-text">高效的半同步&#x2F;半反应堆模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BB-x2F-%E4%BB%8E%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">2. 主&#x2F;从模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">1.4.6.</span> <span class="toc-text">有限状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.4.7.</span> <span class="toc-text">提高服务器性能的其他建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">IO复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">select系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">poll系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">1.5.3.</span> <span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BB%84I-x2F-O%E5%A4%8D%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.5.4.</span> <span class="toc-text">三组I&#x2F;O复用函数的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%B0%88%EF%BC%9A"><span class="toc-number">1.5.5.</span> <span class="toc-text">IO多路复用函数机制详谈：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%B0%88%EF%BC%9A"><span class="toc-number">1.5.6.</span> <span class="toc-text">epoll 机制详谈：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AFmmap%EF%BC%9A"><span class="toc-number">1.5.7.</span> <span class="toc-text">共享内存技术mmap：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EIO%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9EIO%EF%BC%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-IO%EF%BC%8C%E5%BC%82%E6%AD%A5IO"><span class="toc-number">1.5.8.</span> <span class="toc-text">阻塞IO，非阻塞IO，IO多路复用，信号驱动 IO，异步IO</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/47b6ee29/" title="Cypher"><img src="https://s2.loli.net/2022/11/04/hHvKneugsCO7Rb5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cypher"/></a><div class="content"><a class="title" href="/posts/47b6ee29/" title="Cypher">Cypher</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f5f9fa9b/" title="Docker"><img src="https://s2.loli.net/2023/04/25/xdrsWiIHuPN8clT.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/posts/f5f9fa9b/" title="Docker">Docker</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c5146ddf/" title="Hanlp Tutorial"><img src="https://s2.loli.net/2023/04/25/eMl8rxiJ2NK3uf6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hanlp Tutorial"/></a><div class="content"><a class="title" href="/posts/c5146ddf/" title="Hanlp Tutorial">Hanlp Tutorial</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2d771287/" title="Kubernetes学习"><img src="https://s2.loli.net/2022/11/04/yzHUZnq5PAOJkEQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kubernetes学习"/></a><div class="content"><a class="title" href="/posts/2d771287/" title="Kubernetes学习">Kubernetes学习</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/da599ed4/" title="NLP概述"><img src="https://s2.loli.net/2023/04/25/ApM5xz9EYwCtXuW.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NLP概述"/></a><div class="content"><a class="title" href="/posts/da599ed4/" title="NLP概述">NLP概述</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div></div></div></div></div></main><footer id="footer" style="background: -rgb(0,0,255)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By rtlin</div><div class="footer_custom_text">所有你乐于挥霍的时间，都不能算作浪费</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="null" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>