<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux高性能服务器编程 | Lin's Blog</title><meta name="keywords" content="Linux网络编程"><meta name="author" content="木木想去北海种花"><meta name="copyright" content="木木想去北海种花"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux高性能服务器编程Linux网络编程基础API 探讨Linux网络编程基础与内核中TCP&#x2F;IP协议族之间的关系，并为后续章节提供编程基础 从三方面来讨论Linux网络API  socket地址API，socket最开始的含义是一个IP地址和端口对，它唯一的标识了TCP通信的一端 socket基础API，socket的主要的API都定义在 sys&#x2F;socket.h头文件中">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器编程">
<meta property="og:url" content="https://mumu-lsl.github.io/posts/16108/index.html">
<meta property="og:site_name" content="Lin&#39;s Blog">
<meta property="og:description" content="Linux高性能服务器编程Linux网络编程基础API 探讨Linux网络编程基础与内核中TCP&#x2F;IP协议族之间的关系，并为后续章节提供编程基础 从三方面来讨论Linux网络API  socket地址API，socket最开始的含义是一个IP地址和端口对，它唯一的标识了TCP通信的一端 socket基础API，socket的主要的API都定义在 sys&#x2F;socket.h头文件中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mumu-LSL/mumu-LSL.github.io@master/img/indextop.jpg">
<meta property="article:published_time" content="2022-02-08T17:55:03.429Z">
<meta property="article:modified_time" content="2022-02-08T18:06:03.060Z">
<meta property="article:author" content="木木想去北海种花">
<meta property="article:tag" content="Linux网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/mumu-LSL/mumu-LSL.github.io@master/img/indextop.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mumu-lsl.github.io/posts/16108/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux高性能服务器编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-09 02:06:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/mumu-LSL/mumu-LSL.github.io@master/img/indextop.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lin's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux高性能服务器编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-08T17:55:03.429Z" title="发表于 2022-02-09 01:55:03">2022-02-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-08T18:06:03.060Z" title="更新于 2022-02-09 02:06:03">2022-02-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux高性能服务器编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux高性能服务器编程"><a href="#Linux高性能服务器编程" class="headerlink" title="Linux高性能服务器编程"></a>Linux高性能服务器编程</h1><h2 id="Linux网络编程基础API"><a href="#Linux网络编程基础API" class="headerlink" title="Linux网络编程基础API"></a>Linux网络编程基础API</h2><hr>
<p>探讨Linux网络编程基础与内核中TCP&#x2F;IP协议族之间的关系，并为后续章节提供编程基础</p>
<p>从三方面来讨论Linux网络API</p>
<ul>
<li>socket地址API，socket最开始的含义是一个IP地址和端口对，它唯一的标识了TCP通信的一端</li>
<li>socket基础API，socket的主要的API都定义在 sys&#x2F;socket.h头文件中</li>
<li>网络信息API，Linux提供了一套网络信息的API，以实现主机名与IP地址，服务名与端口号之间的转换</li>
</ul>
<h3 id="socket地址API"><a href="#socket地址API" class="headerlink" title="socket地址API"></a>socket地址API</h3><hr>
<h4 id="0-字节序"><a href="#0-字节序" class="headerlink" title="0.字节序"></a>0.字节序</h4><p>在了解socket地址API之前我们应该先了解一下字节序：</p>
<p>字节序的分类</p>
<ul>
<li>大端字节序(big endian)</li>
</ul>
<p>​       大端字节序是指一个整数的高位字节(23-31bit)存储在内存的低地址处,低位字节(0~7bit)存储在内存的高地址处.</p>
<ul>
<li>小端字节序(little endian)</li>
</ul>
<p>​       小端字节序则是指整数的高位字节存储在内存的高地址处,而低位字节则存储在内存的低地址处.</p>
<p>主机字节序和网络字节序</p>
<ul>
<li>现代PC大多采用小端字节序,因此小端字节序又被称为网络字节序</li>
<li>现在网络传输中的字节序都采用大端字节序,所以大端字节序又被称为网络字节序</li>
</ul>
<hr>
<h4 id="1-通用socket地址"><a href="#1-通用socket地址" class="headerlink" title="1. 通用socket地址"></a>1. 通用socket地址</h4><p><code>sockaddr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">//sa_family成员是地址族类型(sa_family_t)的变量,地址族类型通常与协议族类型对应</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];  <span class="comment">//sa_data成员用于存放socket地址值. 但十四字节根本无法存放大多数协议的地址值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sa_family成员是地址族类型(sa_family_t)的变量,地址族类型通常与协议族类型对应</p>
<p>协议族与地址族的关系</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址值含义和长度</th>
<th>地址族</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>文件的路径名,长度可达到108字节</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>16bit端口号和32bitIPv4地址,共5字节</td>
<td>AF_INET</td>
<td>TCP&#x2F;IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>16bit端口号,32bit流标识,126bitIPv6地址,32bit范围ID,共26字节</td>
<td>AF_INET6</td>
<td>TCP&#x2F;IPv6协议族</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span>-<span class="built_in">sizeof</span>(__ss_align)]; <span class="comment">//提供了更大的空间并且是内存对齐的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-专用socket地址"><a href="#2-专用socket地址" class="headerlink" title="2. 专用socket地址"></a>2. 专用socket地址</h4><p>通用的socket地址不能够很方便的使用，所以Linux为各个协议族提供了专门的socket地址结构体</p>
<p>  <strong>Unix本地域协议族</strong>     <code>sockaddr_un</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span>     <span class="comment">//Unix本地域协议族</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">// 地址族:AF_UNIX</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];      <span class="comment">// 文件路径名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>IPV4</strong>   <code>sockaddr_in</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;    <span class="comment">// 地址族:AF_INET</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;        <span class="comment">//端口号,要使用网络字节序表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;   <span class="comment">//IPv4地址结构第</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];          <span class="comment">//不使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;   <span class="comment">//IPv4地址,要用网络字节序表示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sockaddr_in结构体的赋值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line"><span class="type">char</span> * serv_port = <span class="string">&quot;9999&quot;</span>;</span><br><span class="line"><span class="type">char</span> * serv_ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(addr));   <span class="comment">//内存初始化</span></span><br><span class="line">addr.sin_family = AF_INET;   <span class="comment">//设置地址族</span></span><br><span class="line"><span class="comment">// addr.sin_addr.s_addr = htonl(INADDR_ANY);  //设置ip地址,服务器通常采用INADDR_ANY</span></span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(serv_ip);    <span class="comment">//客户端，利用地址转行函数来讲字符串转化为二进制整数</span></span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(serv_port));    <span class="comment">// 设置端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//INADDR_ANY</span></span><br><span class="line"><span class="comment">//自动分配服务器端的IP,不必输入,服务器有限考虑这种方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>IPV6</strong>    <code>sockaddr_in6</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin5_family;   <span class="comment">//地址族,要用AF_INET6</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin6_port;       <span class="comment">//端口号,使用网络字节序</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_flowinfo;   <span class="comment">//流信息,应设置为0</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr; <span class="comment">//IPv6结构体</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_scope_id;   <span class="comment">//scope ID,尚处于实验阶段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sa_addr[<span class="number">16</span>];  <span class="comment">//IPv6地址,网络字节序表示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所有socket地址类型的变量都需要转化为通用的socket地址类型（socketaddr）,直接强制转换即可</p>
<hr>
<h4 id="3-IP地址转换函数"><a href="#3-IP地址转换函数" class="headerlink" title="3. IP地址转换函数"></a><strong>3. IP地址转换函数</strong></h4><p>人们习惯用可读性更好字符串来表示IP地址，但编程中我们需要把它们转化为二进制数方能使用。而记录日志则正好相反</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * strptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * cp,<span class="keyword">struct</span> in_addr* inp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr_in)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af,<span class="type">const</span> <span class="type">char</span> * src,<span class="type">void</span> * dst)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af,<span class="type">const</span> <span class="type">void</span> * src,<span class="type">char</span> * dst,<span class="type">socklen_t</span> cnt)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>inet_addr</code><br>inet_addr将点分十进制字符串标示的IPv4地址转化为用网络字节序整数表示的IPv4地址.失败时返回INADDR_NONE.</p>
<p><code>inet_aton</code><br>inet_aton将点分十进制字符串标示的IPv4地址转化为用网络字节序整数表示的IPv4地址存储到参数inp指向的地址结构中.成功时返回1,失败时返回0</p>
<p><code>inet_ntoa</code><br>inet_ntoa将用网络字节序整数标示的IPv4地址转化为用点分十进制字符串标示的IPv4地址. 但inet_ntoa函数是不可重入的,该函数内部使用一个静态变量存储转化结果,函数的返回值指向该静态内存</p>
<p><code>inet_pton</code><br>inet_pton函数将用字符串表示的IP地址src(用点分十进制字符串标示的IPv4地址或用十六进制字符串表示的IPv6地址)转换成用网络字节序表示的IP地址,并把转换结果存储与dst指向的内存中.</p>
<p>af:指定地址族,可以是AF_INET或者AF_INET6</p>
<p>成功返回1,失败返回0并设置errno</p>
<p><code>inet_ntop</code><br>inet_ntop函数进行和inet_pton相反的转换.前三个参数的含义与inet_pton相同</p>
<p>cnt:制定目标存储单元的大小,使用下面两个宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>

<p>成功时返回目标存储单元的地址,失败返回NULL并设置errno</p>
<hr>
<h3 id="socket基础API"><a href="#socket基础API" class="headerlink" title="socket基础API"></a>socket基础API</h3><hr>
<h4 id="1-socket（）函数："><a href="#1-socket（）函数：" class="headerlink" title="1. socket（）函数："></a><strong>1. socket（）函数：</strong></h4><p>原函数： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocl)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>domain指明了协议族&#x2F;域，通常PF_INET、PF_INET6、PF_UNIX等；<br>type是套接口类型，主要SOCK_STREAM（对应TCP服务）、SOCK_DGRAM（对应UDP服务） 、SOCK_NONBLOCK（新创建的socket设置为非阻塞的 ）；<br>protocol一般取为0。</p>
<p>成功时，返回一个小的非负整数值，与文件描述符类似。<br>作用： socket函数用于创建一个新的socket，也就是向系统申请一个socket资源。</p>
<hr>
<h4 id="2-bind（）函数："><a href="#2-bind（）函数：" class="headerlink" title="2. bind（）函数："></a><strong>2. bind（）函数：</strong></h4><p>原函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="keyword">struct</span> sockaddr* myaddr,<span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>sockfd 表示socket函数创建的通信文件描述符<br>addrlen 表示所指定的结构体变量的大小<br>myaddr 表示struct sockaddr的地址，用于设定要绑定的ip和端口</p>
<p>成功返回0,失败返回-1并设置errno,其中常见的两种errno是:</p>
<ul>
<li>EACCES:被绑定的地址是收保护的地址,仅超级用户能够访问</li>
<li>EADDRINUSE:被绑定的地址正在使用中</li>
</ul>
<p>作用：命名socket. 将一个socket与socket地址绑定称为给socket命名.</p>
<hr>
<h4 id="3-listen（）函数："><a href="#3-listen（）函数：" class="headerlink" title="3. listen（）函数："></a><strong>3. listen（）函数：</strong></h4><p>原函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>listen() 函数的主要作用就是将 socket() 函数得到的 sockfd 变成一个被动监听的套接字, 用来被动等待客户端的连接,而参数 backlog 的作用就是设置连接队列的长度。三次握手,建立连接不是 listen() 函数完成的, 而是内核完成的, listen() 函数只是将 sockfd 和 backlog 告诉内核, 然后就返回了<br>如果有客户端通过 connect() 发起连接请求, 内核就会通过三次握手建立连接, 然后将建立好的连接放到一个队列中,<br>这个队列称为: 已完成连接队列<br>listen函数一般在调用bind之后调用，在accept之前调用，调用成功时返回0,失败时返回-1并设置errno</p>
<hr>
<h4 id="4-accept（）函数："><a href="#4-accept（）函数：" class="headerlink" title="4. accept（）函数："></a><strong>4. accept（）函数：</strong></h4><p>原函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>sockfd</code>:是执行过listen系统调用的监听socket</li>
<li><code>addr</code>:用来获取被接受连接的远端socket地址</li>
<li><code>addrlen</code>:指出<code>addr</code>接收的socket地址的长度</li>
<li>成功时返回一个新的连接socket,失败时返回-1并设置errno</li>
</ul>
<p>作用<br>accept() 函数的作用就是在已完成连接队列中取出一个已经建立好的连接。如果这个队列中已经没有已完成连接的套接字, 那么 accept() 就会一直阻塞, 直到取得一个已经建立连接的套接字</p>
<hr>
<h4 id="5-数据读写"><a href="#5-数据读写" class="headerlink" title="5. 数据读写"></a><strong>5. 数据读写</strong></h4><p><strong>TCP数据读写</strong></p>
<p>对文件的读写操作read和write同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用， 它们增加了对数据读写的控制。 其中适用于TCP流数据读写的系统调用是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span> <span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">void</span>*buf,<span class="type">size_t</span> len,<span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">void</span> * buf,<span class="type">size_t</span> len,<span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>read</code></strong></p>
<p>接受或者输入数据</p>
<ul>
<li><code>fd</code>:显示数据接受对象的文件描述符</li>
<li><code>buf</code>:要保存接收数据的缓冲区地址</li>
<li><code>nbytes</code>:要接收数据的最大字节数</li>
<li>成功时返回接收到的字节数,接收到文件尾或者连接被关闭返回0,失败返回-1</li>
</ul>
<p><strong><code>write</code></strong></p>
<p>向文件或者套接字传递数据.</p>
<ul>
<li><code>fd</code>:显示数据传输对象的文件描述符</li>
<li><code>buf</code>:保存要传输数据的缓冲地址值</li>
<li><code>n</code>:要传输数据的字节数</li>
<li>成功时返回写入的字节数,失败时返回-1</li>
</ul>
<p><strong><code>recv</code></strong><br>接受或者输入数据</p>
<p><code>sockfd</code>:表示数据接收对象的连接的套接字文件描述符<br><code>buf</code>:保存接收数据的缓冲地址值<br><code>len</code>:可接收的最大字节数<br><code>flags</code>传输数据时制定的可选项信息<br>成功时返回接受的字节数(收到EOF返回0),失败时返回-1;</p>
<p><strong><code>send</code></strong><br>向文件或者套接字传递数据</p>
<p><code>sockfd</code>:表示与数据传输对象的连接的套接字文件描述符<br><code>buf</code>:保存带传输数据的缓冲地址值<br><code>len:</code>待传输的字节数<br><code>flags</code>传输数据时制定的可选项信息<br>成功时返回发送的字节数,失败时返回-1</p>
<p><strong>UDP数据读写</strong></p>
<p>socket编程接口中用于UDP数据报读写的系统调用是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span>  <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* src_addr, <span class="type">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span>  <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* dest_addr, <span class="type">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><code> recvfrom</code></strong><br>sock:用于接收数据的UDP套接字文件描述符<br>buff:保存接收数据的缓冲区地址值<br>nbytes:可接受的最大字节数,故无法超过参数buff所指的缓冲区大小<br>flags:可选项参数,若没有则传入0<br>from:存有发送端地址信息的sockaddr结构体变量的地址值<br>addrlen:保存参数from的结构体变量长度的变量地址值</p>
<p><strong><code>sendto</code></strong><br>sock:用于传输数据的UDP套接字文件描述符<br>buff:保存待传输数据的缓冲区地址值<br>nbytes:待传输的数据长度,以字节为单位<br>flags:可选项参数,若没有则传递0<br>to:存有目标地址信息的sockaddr结构体变量的地址值<br>addrlen:传递的参数to地址值结构体变量长度<br>成功时返回传输的字节数,失败时返回-1</p>
<p>UDP通信没有连接的概念，每次读取数据都需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度</p>
<p><strong>通用数据读写函数</strong></p>
<p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅能用于TCP流数据，也能用于UDP数据报：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span>  <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span>  <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockfd参数指定被操作的目标socket。 msg参数是msghdr结构体类型的指针 falgs与前面recv,send的相同</p>
<hr>
<h4 id="6-实例"><a href="#6-实例" class="headerlink" title="6. 实例"></a>6. 实例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @File:serv_1.cpp</span></span><br><span class="line"><span class="comment"> * @Descripttion: socket编程服务器端,简单版本(TCP)</span></span><br><span class="line"><span class="comment"> *  只接受一个客户端连接,并接收客户端发送的信息显示后就退出</span></span><br><span class="line"><span class="comment"> * @Version: </span></span><br><span class="line"><span class="comment"> * @Author: zsj</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-03 15:38:31</span></span><br><span class="line"><span class="comment"> * @LastEditors: zsj</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-03 16:20:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_error</span><span class="params">(<span class="type">char</span> * info)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(info);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//参数数量不对直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个socket</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配地址信息,socket命名</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;bind() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个监听队列</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;listen() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_addr_sz = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="comment">//取出一个连接</span></span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">accept</span>(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr,&amp;clnt_addr_sz);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;accept() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get a connection %d\n&quot;</span>,clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    ret = <span class="built_in">read</span>(clnt_sock,buffer,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client close the connection!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;from %d data %d bytes: %s\n&quot;</span>,clnt_sock,ret,buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @File:clnt_1.cpp</span></span><br><span class="line"><span class="comment"> * @Descripttion: socket编程,客户端简单版本,(TCP)</span></span><br><span class="line"><span class="comment"> *  连接服务器之后,发送数据到服务器之后就退出</span></span><br><span class="line"><span class="comment"> * @Version: </span></span><br><span class="line"><span class="comment"> * @Author: zsj</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-03 16:06:36</span></span><br><span class="line"><span class="comment"> * @LastEditors: zsj</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-03 16:19:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_error</span><span class="params">(<span class="type">char</span> * info)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(info);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;ip&gt; &lt;port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个socket</span></span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端不需要绑定和监听,直接连接服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clnt_sock,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect to %s success!\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>] = <span class="string">&quot;hello server!!!&quot;</span>;</span><br><span class="line">    ret = <span class="built_in">write</span>(clnt_sock,buffer,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">show_error</span>(<span class="string">&quot;write() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send data success!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-带外数据"><a href="#7-带外数据" class="headerlink" title="7. 带外数据"></a>7. 带外数据</h4><p>我们需要知道的是数据分为两种，一种是带内数据，一种是带外数据。带内数据就是我们平常传输或者说是口头叫的数据。带外数据就是我们接下来讲的内容。</p>
<p>   许多的传输层都具有带外数据（也称为 经加速数据 ）的概念，想法就是连接的某段发生了重要的事情，希望迅速的通知给对端。这里的迅速是指这种通知应该在已经排队了的带内数据之前发送。也就是说，带外数据拥有更高的优先级。带外数据不要求再启动一个连接进行传输，而是使用已有的连接进行传输。其中，UDP没有实现带外数据（是个极端哦～）。TCP中telnet,rlogin,ftp等应用（除了这样的远程非活跃应用之外，几乎很少有使用到带外数据的地方）</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/70.png" alt="img"></p>
<p>紧急字段URG：告诉系统此报文段中有紧急数据，应尽快传送。当URG&#x3D;1时。</p>
<p>紧急指针：指出在本报文段中的紧急数据的最后一个字节的序号，即指出带外数据字节在正常字节流中的位置。</p>
<p>所以当TCP发送带外数据时，他的TCP首部一定是设置了URG标志和紧急指针的 。而紧急指针就是用来指出带外数据字节在正常字节流中的位置的 。</p>
<hr>
<h4 id="8-带外标记"><a href="#8-带外标记" class="headerlink" title="8. 带外标记"></a>8. 带外标记</h4><p>内核通知应用程序带外数据到达的两种常见方式是：I&#x2F;O复用产生的异常事件和SIGURG信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">sockatmark</span><span class="params">(<span class="type">int</span>  sockfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockatmark判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据。</p>
<p>如果是，sockatmark返回1，此时我们就可以利用MSG_OOB标志的recv调用来接收带外数据。 如果不是，则sockatmark返回0。</p>
<hr>
<h4 id="9-地址信息函数"><a href="#9-地址信息函数" class="headerlink" title="9. 地址信息函数"></a>9. 地址信息函数</h4><p>在某些情况下，我们想知道一个连接socket的本端socket地址， 以及远端的socket地址。 下面这2个函数正是用于解决这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>getsockname获取sockfd对应的本端socket地址，并将其存储于address参数 指定的内存中，该socket地址的长度则存储于address_len参数指向的变量中。 如果实际socket地址的长度大于address所指内存的大小， 那么该socket地址将被截断。</p>
<ul>
<li>getsockname成功时返回0，失败返回-1，并设置errno。</li>
</ul>
<p>getpeername获取sockfd对应的远端socket地址， 其参数及返回值的含义与getsockname的参数及返回值相同。</p>
<hr>
<h4 id="10-socket选项"><a href="#10-socket选项" class="headerlink" title="10. socket选项"></a>10. socket选项</h4><p>如果说fcntl系统调用是控制文件描述符属性的通用POSIX方法， 那么下面两个系统调用则是专门用来读取和设置socket文件描述符属性的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span>* option_value,<span class="type">socklen_t</span>* restrict option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">const</span> <span class="type">void</span>* option_value, <span class="type">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockfd参数指定被操作的目标socket。 level参数指定要操作哪个协议的选项（即属性），比如IPv4、IPv6、TCP等。 option_name参数则指定选项的名字。 option_value和option_len参数分别是被操作选项的值和长度。</p>
<ul>
<li>getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno。</li>
</ul>
<p>对服务器而言，有部分socket选项要在监听(listen)前针对监听socket设置才有效。 对客户端而言，这些socket选项则应在调用connect函数之前设置， 因为connect调用成功之后，TCP三次握手已完成。</p>
<hr>
<h3 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h3><hr>
<h4 id="1-gethostbyname和gethostbyaddr"><a href="#1-gethostbyname和gethostbyaddr" class="headerlink" title="1. gethostbyname和gethostbyaddr"></a>1. gethostbyname和gethostbyaddr</h4><p>gethostbyname 函数根据主机名称获取主机的完整信息， gethostbyaddr函数根据IP地址获取主机的完整信息。 gethostbyname函数通常先在本地的 &#x2F;etc&#x2F;hsots配置的文件中查找主机， 如果没有找到，再去访问DNS服务器。</p>
<p>这两个函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span>* name);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyaddr</span>(<span class="type">const</span> <span class="type">void</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> type);</span><br></pre></td></tr></table></figure>

<p>hostent结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* h_name;    <span class="comment">//主机名</span></span><br><span class="line">    <span class="type">char</span>** h_aliases; <span class="comment">//主机别名列表，可能有多个</span></span><br><span class="line">    <span class="type">int</span> h_addrtype;   <span class="comment">//地址类型（地址族）</span></span><br><span class="line">    <span class="type">int</span> h_length;     <span class="comment">//地址长度</span></span><br><span class="line">    <span class="type">char</span>** h_addr_list;<span class="comment">//按网络字节序列出的主机IP地址列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-getservbyname和getservbyport"><a href="#2-getservbyname和getservbyport" class="headerlink" title="2. getservbyname和getservbyport"></a>2. getservbyname和getservbyport</h4><p>getservbyname函数根据名称获取某个服务的完整信息， getsrvbyport函数根据端口号获取某个服务的完整信息。 他们实际上都是通过读取 &#x2F;etc&#x2F;services 文件来获取服务信息的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">servent</span>* <span class="built_in">getservbyname</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* proto);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">servent</span>* <span class="built_in">getsrvbyport</span>(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span>* proto);</span><br></pre></td></tr></table></figure>

<p>name参数指定目标服务器的名字，port参数指定目标服务对应的端口号， proto参数指定服务类型。</p>
<p>结构体servent定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">servent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* s_name;       <span class="comment">//服务名称</span></span><br><span class="line">    <span class="type">char</span>** s_aliases;   <span class="comment">//服务的别名列表，可能有多个</span></span><br><span class="line">    <span class="type">int</span> s_port;         <span class="comment">//端口号</span></span><br><span class="line">    <span class="type">char</span>* s_proto;     <span class="comment">//服务类型，通常是tcp或者udp</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-getaddrinfo"><a href="#3-getaddrinfo" class="headerlink" title="3. getaddrinfo"></a>3. getaddrinfo</h4><p>getaddrinfo函数既能通过主机名获取ip地址（内部使用gethostbyname）也能 通过服务名获得端口号（内部使用getservbyname）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hostname, <span class="type">const</span> <span class="type">char</span>* service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo* hints, <span class="keyword">struct</span> addrinfo** result)</span></span></span><br></pre></td></tr></table></figure>



<p>hostname参数可以接收主机名，也可以接收字符串表示的IP地址（IPv4用点分十进制 字符串，IPv6用十六进制字符串）。 同样，service参数可以接收服务名，也可以接收字符串表示的十进制端口号。 hints参数是应用程序给getaddrinfo的一个提示，一对getaddrinfo的输出进行更精确的控制。 result参数指向一个链表，该链表用于存储getaddrinfo反馈的结果。</p>
<ul>
<li>getaddrinfo成功返回0，失败返回错误码</li>
</ul>
<p>getaddrinfo反馈的每一条结果都是addrinfo结构体类型的对象， 结构体addrinfo定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">addrinfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ai_flags;  <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> ai_family;<span class="comment">//地址族</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;<span class="comment">//服务类型，SOCK_STREAM 或 SOCK_DGRAM</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;<span class="comment">//</span></span><br><span class="line">    <span class="type">socklent_t</span> ai_addrlen;<span class="comment">// socket地址 ai_addr的长度</span></span><br><span class="line">    <span class="type">char</span>* ai_canonname;<span class="comment">//主机的别名</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr</span>* ai_addr; <span class="comment">//指向socket地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>* ai_next; <span class="comment">//指向下一个sockinfo结构的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用 getaddrinfo 函数</span></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">addrinfo</span>  hints;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">addrinfo</span>* res;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bzero</span>(&amp;hints, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"><span class="built_in">getaddrinfo</span>(<span class="string">&quot;ernest-laptop&quot;</span>, <span class="string">&quot;daytime&quot;</span>, &amp;hints, &amp;res);</span><br></pre></td></tr></table></figure>



<p>getaddrinfo将隐式地分配堆内存（可通过valgrind工具查看）， 因为res指针原本没有指向一块合法内存的， 所以，getaddrinfo调用结束后，必须使用如下配对函数来释放这块内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo*  res)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-getnameinfo"><a href="#4-getnameinfo" class="headerlink" title="4. getnameinfo"></a>4. getnameinfo</h4><p>getnameinfo函数能通过socket地址同时获得以字符串表示的主机名（内部使用gethostbyaddr函数）和服务名（内部使用getservbyport函数）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr* sockaddr, <span class="type">socklen_t</span> addrlen, <span class="type">char</span>* host, <span class="type">socklen_t</span> hostlen, <span class="type">char</span>* serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>getnameinfo将返回的主机名存储在host参数指向的缓存中， 将服务名存储在serv参数指向的缓存中， hostlen和servlen参数分别指定这两块缓存的长度。 flags参数控制getnameinfo的行为。</p>
<ul>
<li>getnameinfo成功返回0，失败返回错误码</li>
</ul>
<hr>
<h4 id="5-错误码"><a href="#5-错误码" class="headerlink" title="5. 错误码"></a>5. 错误码</h4><p>Linux下strerror函数能将数值错误码errno转换成易读的字符串形式。 同样，下面的函数可将表5-8(getaddrinfo和getnameinfo的错误码)的错误码转换成其字符串形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">gai_strerror</span><span class="params">(<span class="type">int</span> error)</span></span>;</span><br></pre></td></tr></table></figure>



<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20220205143510927-16443431320901.png" alt="image-20220205143510927"></p>
<h2 id="高级IO函数"><a href="#高级IO函数" class="headerlink" title="高级IO函数"></a>高级IO函数</h2><hr>
<p>Linux提供了许多高级的IO函数，它们可能不像Linux常用的IO函数（如open和read）那么常用，但他们在特定条件下却能表现出优异的性能。 这些函数大致可以分为三类：</p>
<ul>
<li>用于创建文件描述符的函数，包括pipe,dup&#x2F;dup2函数</li>
<li>用于读写数据的函数，readv&#x2F;writev,sendfile,mmap&#x2F;munmap,splice,tee</li>
<li>用于控制I&#x2F;O行为和属性的函数，如fcntl</li>
</ul>
<hr>
<h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><p>pipe函数可以用于创建一个管道，以实现进程间的通信</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>pipe函数的参数是含有两个int 整形的数组指针，成功时返回0 ，并将文件描述符值填写到数组中，fd[0]表示读端，fd[1]表示写，两端不可颠倒，默认情况这两个文件描述符都是阻塞的。如果当管道为空时，调用系统调用read（）时，将被阻塞，直到管道内有数据可读。当管道为满时，调用write（）也会被阻塞，直到管道内有足够的空闲空间。如果将fd[0]  fd[1]设置为非阻塞，则read（）和write（）就会有不同的行为，关于阻塞与非阻塞，我们将在后续文章中进行讨论。</p>
<p>当fd[1]的引用计数减为0则表示，没有任何一个进行往管道中写入数据，则对于fd[0] 的read()操作返回值为0，表示读到末尾（EOF）。反之，当fd[0]的引用计数减为0，表示没有任何一个进程读这个管道，则fd[1]写端的write(）将失败，引发SIGPIPE信号。管道内部传输的也是字节流，这点也和TCP传输有些区别，TCP连接写入的数据，取决于滑动窗口的大小，而管道有一个容量限制，默认大小为65536字节，可通过fcntl函数修改管道大小。</p>
<p>可通过socketpair创建双向管道</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socketpair</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type, <span class="type">int</span> protocol,<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>前三个参数与socket函数中的参数意义相同，但是domain 只能使用AF_UNIX（表示Unix本地域协议族），因为我们仅能在本地使用这个双向管道，socketpair成功时返回0，失败返回-1并设置errno</p>
<hr>
<h3 id="dup函数与dup2函数"><a href="#dup函数与dup2函数" class="headerlink" title="dup函数与dup2函数"></a>dup函数与dup2函数</h3><p>有时候我们希望把标准输入重定向到一个文件，或者标准输出重定向到一个网络连接（如CGI编程）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> file_descriptor_one,file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure>

<p>dup 创建的新文件描述符，和原来的文件描述符file_descriptor指向相同的文件，管道或者网络连接，但不继承原来文件描述符的属性（如close-on-exec和non-blocking等）。dup返回的文件描述符总是取系统当前可用的最小整数值。dup和dup2系统调用失败时返回-1并设置errno</p>
<hr>
<h3 id="readv-x2F-writev-函数"><a href="#readv-x2F-writev-函数" class="headerlink" title="readv &#x2F;writev 函数"></a>readv &#x2F;writev 函数</h3><p> readv将文件描述符读到分散的内存块中，writev 将多块分散的内存中的数据写到一个文件描述符中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="keyword">struct</span> iovec*  vector,<span class="type">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="keyword">struct</span> iovec*  vector,<span class="type">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p> fd 是目标文件描述符，vector 是类型为iovec类型的结构体，该结构描述了一款内存，count 表示vector数组的长度</p>
<hr>
<h3 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h3><p>sendfile函数表示在两个文件描述符之间数据传递，完全在内核完成，避免了内核缓冲区到用户缓冲区的拷贝，效率很高，被称为零拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd,<span class="type">int</span> in_fd,<span class="type">off_t</span>* offset,<span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>in_fd,表示待读出的文件描述符，out_fd ，表示待写入的文件描述符，offset表示读人的位置，NULL表示默认起始位置，count表示在两个文件描述符传递的字节数，in_fd 必须是一个真实的文件，out_fd必须是一个socket，所以sendfile专门为网络传输文件设计的。 </p>
<hr>
<h3 id="mmap-x2F-munmap-函数"><a href="#mmap-x2F-munmap-函数" class="headerlink" title="mmap&#x2F;munmap   函数"></a>mmap&#x2F;munmap   函数</h3><p>mmap 函数是申请了一块内存，我们将这块内存作为进程间通信的共享内存，也可以将文件映射到其中，munmap 释放申请的这块内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mmap</span><span class="params">(<span class="type">void</span> *start,<span class="type">siez_t</span> length,<span class="type">int</span> port,<span class="type">int</span> flags, <span class="type">int</span> fd,<span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *start,<span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>start 表示内存的起始地址，length表示内存段的长度，prot表示内存访问权限，flags 表示内存修改后控制程序的行为，fd 表示映射文件的描述符，offset表示文件映射的位置。</p>
<hr>
<h3 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h3><p> 用于两个文件描述符之间的数据交流，也是一个零拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="type">int</span> fd_in,<span class="type">loff_t</span>* off_in,<span class="type">int</span> fd_out,<span class="type">loff_t</span>* off_out,<span class="type">size_t</span> len,<span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>splice 函数fd_in  或者 fd_out 必须有一个是管道文件描述符</p>
<hr>
<h3 id="tee-函数"><a href="#tee-函数" class="headerlink" title="tee 函数"></a>tee 函数</h3><p> tee 函数用于两个管道之间的数据交流，也是零拷贝操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="type">int</span> fd_in,<span class="type">int</span> fd_out,<span class="type">size_t</span> len,<span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd_in  和fd_out 必须都是管道文件描述符。</p>
<hr>
<h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><p>fcntl函数是对各种文件描述符进行操作，修改属性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> cmd,...)</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setnonblock</span><span class="params">(<span class="type">int</span> fd)</span><span class="comment">//设置非阻塞</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_fcntl = <span class="built_in">fcntl</span>(fd,F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_fcntl = old_fcntl | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">fcntl</span>(fd,F_SETFL,new_fcntl) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Linux-服务器程序规范"><a href="#Linux-服务器程序规范" class="headerlink" title="Linux 服务器程序规范"></a>Linux 服务器程序规范</h2><hr>
<p>除了网络通信外，服务器程序还必须考虑许多其他细节问题，零碎，但基本上是模板式的。比如：</p>
<ul>
<li>Linux服务器程序一般以后台形式运行。后台程序又称守护进程。它没有控制终端，因而也不会意外接受用户输入。守护进程的父进程一般是init进程（PID&#x3D;1）</li>
<li>Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器可以输出日志到专门的UDP服务器。大部分后台进程都在&#x2F;var&#x2F;log下有自己的日志目录</li>
<li>Linux服务器程序一般以某个专门的非root身份运行。比如mysqld, httpd, syslogd等后台进程，并分别有自己的运行账户mysql, apache, syslog</li>
<li>Linux服务器通常时可配置的。服务器程序通常处理很多命令选项，如果一次运行的选项太多，则可以用配置文件来管理。绝大多数服务器程序都有配置文件并存放在&#x2F;etc下 </li>
<li>Linux服务器程序通常在启动时生成一个PID文件并存入&#x2F;var&#x2F;run目录中，以记录该后台进程的PID。</li>
<li>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等</li>
</ul>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><hr>
<p>守护进程（daemon）是生存期长的一种进程，没有控制终端。它们常常在系统引导装入时启动，仅在系统关闭时才终止。UNIX系统有很多守护进程，守护进程程序的名称通常以字母“d”结尾：例如，<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/Syslog">syslogd</a> 就是指管理系统日志的守护进程。通过ps进程查看器 <code>ps -efj</code> 的输出实例</p>
<p>守护进程是在后台运行不受终端控制的进程（如输入、输出等），一般的网络服务都是以守护进程的方式运行。守护进程脱离终端的主要原因有两点：</p>
<ol>
<li>用来启动守护进程的终端在启动守护进程之后，需要执行其他任务。</li>
<li>如其他用户登录该终端后，以前的守护进程的错误信息不应出现）由终端上的一些键所产生的信号（如中断信号），不应对以前从该终端上启动的任何守护进程造成影响。要注意守护进程与后台运行程序（即加＆启动的程序）的区别。</li>
</ol>
<p>**怎样创建守护进程 ？ **</p>
<p>在创建守护进程之前，需要了解一些基础概念：</p>
<p>进程组 ：</p>
<ul>
<li>每个进程除了有一个进程ID之外，还属于一个进程组</li>
<li>进程组是一个或多个进程的集合，同一进程组中的各进程接收来自同一终端的各种信号</li>
<li>每个进程组有一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BB%84%E9%95%BF%E8%BF%9B%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:529315259%7D">组长进程</a>。组长进程的进程组ID等于其进程ID</li>
</ul>
<p>会话：会话（session）是一个或多个进程组的集合，进程调用 setsid 函数（原型：<code>pid_t setsid(void)</code> ）建立一个会话。</p>
<p>  进程调用 setsid 函数建立一个新会话，如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事：</p>
<ul>
<li>该进程变成新会话的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BC%9A%E8%AF%9D%E9%A6%96%E8%BF%9B%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:529315259%7D">会话首进程</a>（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话的唯一进程。</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID</li>
<li>该进程没有控制终端。如果调用setsid之前该进程有一个控制终端，那么这种联系也被切断</li>
</ul>
<p>如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID是重新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。</p>
<p>  对于守护进程，需要遵守一些编写规则：</p>
<ul>
<li>在后台运行：为避免挂起控制终端，将守护进程放入后台运行。方法亦即在进程中调用 fork 后使父进程终止，子进程则继续在后台运行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>脱离控制终端，登陆会话和进程组：调用 setsid 后会发生的3件事上面已经阐述：（a）成为新会话的首进程，（b）成为一个新进程组的组长进程、（c）没有控制终端</li>
<li>禁止进程重新打开控制终端：进程已经成为无终端的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BC%9A%E8%AF%9D%E7%BB%84%E9%95%BF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:529315259%7D">会话组长</a>。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (pid = fork()) != <span class="number">0</span>)<span class="comment">/* parent */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误</li>
<li>当前目录更改为根目录：从父进程处继承过来的当前工作目录可能在一个挂载的文件系统，所以如果守护进程的当前工作目录在一个挂载文件中，那么该文件系统就不能被卸载</li>
<li>关闭不再需要的文件描述符：这使守护进程不再持有从其父进程继承来的任何文件描述符</li>
</ul>
<h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><p>服务器的调试和维护都需要一个专业的日志系统。Linux提供一个守护进程来处理系统日志：<strong>syslogd</strong>, 不过现在的Linux系统上使用的都是它的升级版：<strong>rsyslogd</strong>.</p>
<p>rsyslogd 守护进程既能接收用户进程输出的日志，又能接收内核日志。用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型(AF_UNIX)的文件&#x2F;dev&#x2F;log中，rsyslogd 则监听该文件以获取用户进程的输出。</p>
<p>rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。默认情况下，调试信息会保存至&#x2F;varlog&#x2F;debug文件，普通信息保存至&#x2F;var&#x2F;log&#x2F;messages文件，内核消息则保存至&#x2F;var&#x2F;log&#x2F;kerm.log文件。不过，日志信息具体如何分发，可以在rsyslogd的配置文件中设置。rsyslogd 的主配置文件是&#x2F;ete&#x2F;rsyslog.conf。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/1.png" alt="image-20220208224854069"></p>
<p>应用程序使用syslog函数与rsyslogd守护进程通信。syslog 函数的定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">syslog</span><span class="params">( <span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span>* message, ... )</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数采用可变参数(第二个参数message和第三个参数……)来结构化输出。<strong>priority</strong> 参数是所谓的<strong>设施值与日志级别</strong>的按位或。设施值的默认值是<strong>LOG_USER。</strong></p>
<p>下面这个函数可以改变syslog的默认输出方式，进一步结构化日志内容:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openlog</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* ident，<span class="type">int</span> logopt, <span class="type">int</span> facility )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>ident</strong>参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。<strong>logopt</strong> 参数对后续syslog调用的行为进行配置。<strong>facility</strong>参数可用来修改syslog函数中的默认设施值。</p>
<p>日志的过滤也很重要。程序在开发阶段可能需要输出很多调试信息，而发布之后我们又需要将这些调试信息关闭。解决这个问题的方法并不是在程序发布之后删除调试代码(因为日后可能还需要用到)，而是简单地设置<strong>日志掩码</strong>，使日志级别大于日志掩码的日志信息被系统忽略。下面这个函数用于设置syslog的日志掩码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> setlogmask（<span class="type">int</span> maskpri );</span><br></pre></td></tr></table></figure>

<p><strong>maskpri</strong>参数指定日志掩码值。该函数始终会成功，它返回调用进程先前的日志掩码值。最后，不要忘了使用如下函数<strong>关闭</strong>日志功能:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys1og.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="系统资源的限制"><a href="#系统资源的限制" class="headerlink" title="系统资源的限制"></a>系统资源的限制</h3><p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制(CPU数量、内存数量等)、系统策略限制(CPU 时间等)，以及具体实现的限制(比如文件名的最大长度)。Linux系统资源限制可以通过如下一对函数来读取和设置:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">finclude &lt;sys/resource.h&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrlimit</span><span class="params">( <span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setrlimit</span><span class="params">( <span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim )</span></span>;</span><br><span class="line"></span><br><span class="line">rlim参数是rlimit结构体类型的指针，rlimit 结构体的定义如下:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rlimit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>rlim_t是一个整数类型，它描述资源级别。<strong>rlim_cur</strong>成员指定资源的<strong>软限制</strong>，<strong>rlim_max</strong>成员指定资源的<strong>硬限制</strong>。软限制是一个建议性的、最好不要超越的限制，如果超越的话，系运行的程序才能增加硬限制。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/v2-4eca7cce6b6508292dd0414cadd38497_r.jpg" alt="preview"></p>
<h3 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h3><p>获取进程当前工作目录和改变进程工作目录的函数分别是:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd .h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getcwd</span><span class="params">( <span class="type">char</span>* buf, <span class="type">size_t</span> size )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* path )</span></span>;</span><br></pre></td></tr></table></figure>

<p>buf参数指向的内存用于存储进程当前工作目录的<strong>绝对</strong>路径名，其大小由size参数指定。</p>
<p><strong>getcwd</strong> 函数成功时返回一个指向目标存储区(buf 指向的缓存区或是getcwd在内部动态创建的缓存区)的指针，失败则返回NULL并设置errno.</p>
<p><strong>chdir</strong>函数的path 参数指定要切换到的目标目录。它成功时返回0, 失败时返回-1并设置errno。</p>
<p>改变进程根目录的函数是chroot其定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd. h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chroot</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* path )</span> </span>;</span><br></pre></td></tr></table></figure>

<p>path参数指定要切换到的目标根目录。它成功时返回0，失败时返回-1。但它并不改变当前进程的工作目录</p>
<h3 id="服务器程序后台化"><a href="#服务器程序后台化" class="headerlink" title="服务器程序后台化"></a>服务器程序后台化</h3><p>让一个进程以守护进程的方式运行。</p>
<p>以下是示例的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考《APUE》</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">daemonize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>					i, fd0, fd1, fd2;</span><br><span class="line">	<span class="type">pid_t</span>				pid;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rlimit</span>		rl;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sigaction</span>	sa;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear file creation mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get maximum number of file descriptors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">getrlimit</span>(RLIMIT_NOFILE, &amp;rl) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t get file limit&quot;</span>, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Become a session leader to lose controlling TTY.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t fork&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">setsid</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure future opens won&#x27;t allocate controlling TTYs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sa.sa_handler = SIG_IGN;</span><br><span class="line">	<span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">	sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t ignore SIGHUP&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t fork&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Change the current working directory to the root so</span></span><br><span class="line"><span class="comment">	 * we won&#x27;t prevent file systems from being unmounted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t change directory to /&quot;</span>, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Close all open file descriptors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rl.rlim_max == RLIM_INFINITY)</span><br><span class="line">		rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rl.rlim_max; i++)</span><br><span class="line">		<span class="built_in">close</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attach file descriptors 0, 1, and 2 to /dev/null.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	fd0 = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">	fd1 = <span class="built_in">dup</span>(<span class="number">0</span>);</span><br><span class="line">	fd2 = <span class="built_in">dup</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the log file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">openlog</span>(cmd, LOG_CONS, LOG_DAEMON);</span><br><span class="line">	<span class="keyword">if</span> (fd0 != <span class="number">0</span> || fd1 != <span class="number">1</span> || fd2 != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;unexpected file descriptors %d %d %d&quot;</span>,</span><br><span class="line">		  fd0, fd1, fd2);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux 提供了完成同样功能的库函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd. h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">daemon</span><span class="params">( <span class="type">int</span> nochdir, <span class="type">int</span> noclose )</span> </span>;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>nochdir</strong> 参数用于指定是否改变工作目录，如果给它传递0, 则工作目录将被设置为“1”(根目录)，否则继续使用当前工作目录。noclose 参数为0时，标准输入、标准输出和标准错误输出都被<strong>重定向到&#x2F;dev&#x2F;null</strong>文件，否则依然使用原来的设备。该函数成功时返回0，失败则返回-1并设置errno。</p>
<h2 id="高性能服务器程序框架"><a href="#高性能服务器程序框架" class="headerlink" title="高性能服务器程序框架"></a>高性能服务器程序框架</h2><p>。。。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">木木想去北海种花</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mumu-lsl.github.io/posts/16108/">https://mumu-lsl.github.io/posts/16108/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mumu-lsl.github.io" target="_blank">Lin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Linux网络编程</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/mumu-LSL/mumu-LSL.github.io@master/img/indextop.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/f92d7720/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/mumu-LSL/mumu-LSL.github.io@master/img/indextop.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python中的各项问题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">木木想去北海种花</div><div class="author-info__description">Lin在此创作, 欢迎各位</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mumu-LSL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/zumumu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Linux高性能服务器编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API"><span class="toc-number">1.1.</span> <span class="toc-text">Linux网络编程基础API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E5%9C%B0%E5%9D%80API"><span class="toc-number">1.1.1.</span> <span class="toc-text">socket地址API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">0.字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1. 通用socket地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">2. 专用socket地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">3. IP地址转换函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E5%9F%BA%E7%A1%80API"><span class="toc-number">1.1.2.</span> <span class="toc-text">socket基础API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-socket%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1. socket（）函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-bind%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2. bind（）函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-listen%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">3. listen（）函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-accept%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">4. accept（）函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">5. 数据读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">6. 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">7. 带外数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">8. 带外标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.9.</span> <span class="toc-text">9. 地址信息函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-socket%E9%80%89%E9%A1%B9"><span class="toc-number">1.1.2.10.</span> <span class="toc-text">10. socket选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AFAPI"><span class="toc-number">1.1.3.</span> <span class="toc-text">网络信息API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-gethostbyname%E5%92%8Cgethostbyaddr"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1. gethostbyname和gethostbyaddr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-getservbyname%E5%92%8Cgetservbyport"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2. getservbyname和getservbyport</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-getaddrinfo"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3. getaddrinfo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-getnameinfo"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">4. getnameinfo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%94%99%E8%AF%AF%E7%A0%81"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">5. 错误码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">高级IO函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">pipe函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup%E5%87%BD%E6%95%B0%E4%B8%8Edup2%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">dup函数与dup2函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readv-x2F-writev-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">readv &#x2F;writev 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendfile%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">sendfile函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-x2F-munmap-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">mmap&#x2F;munmap   函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#splice%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">splice函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tee-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.7.</span> <span class="toc-text">tee 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fcntl%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.8.</span> <span class="toc-text">fcntl函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83"><span class="toc-number">1.3.</span> <span class="toc-text">Linux 服务器程序规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">系统日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">系统资源的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">改变工作目录和根目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E5%8C%96"><span class="toc-number">1.3.5.</span> <span class="toc-text">服务器程序后台化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="toc-number">1.4.</span> <span class="toc-text">高性能服务器程序框架</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/16108/" title="Linux高性能服务器编程"><img src="https://cdn.jsdelivr.net/gh/mumu-LSL/mumu-LSL.github.io@master/img/indextop.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux高性能服务器编程"/></a><div class="content"><a class="title" href="/posts/16108/" title="Linux高性能服务器编程">Linux高性能服务器编程</a><time datetime="2022-02-08T17:55:03.429Z" title="发表于 2022-02-09 01:55:03">2022-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f92d7720/" title="python中的各项问题"><img src="https://cdn.jsdelivr.net/gh/mumu-LSL/mumu-LSL.github.io@master/img/indextop.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python中的各项问题"/></a><div class="content"><a class="title" href="/posts/f92d7720/" title="python中的各项问题">python中的各项问题</a><time datetime="2022-02-08T17:53:13.000Z" title="发表于 2022-02-09 01:53:13">2022-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/16107/" title="Hello World"><img src="https://cdn.jsdelivr.net/gh/mumu-LSL/mumu-LSL.github.io@master/img/indextop.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/posts/16107/" title="Hello World">Hello World</a><time datetime="2022-02-06T17:38:00.000Z" title="发表于 2022-02-07 01:38:00">2022-02-07</time></div></div></div></div></div></div></main><footer id="footer" style="background: -rgb(0,0,255)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 木木想去北海种花</div><div class="footer_custom_text">落在这里的雪，我能全部看见</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="null" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>