<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>RPC-框架 | Lin's Blog</title><meta name="keywords" content="分布式系统"><meta name="author" content="rtlin"><meta name="copyright" content="rtlin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是 RPC ？ RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。  RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。 RPC会隐藏底层的通讯细节（不">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC-框架">
<meta property="og:url" content="https://mumu-lsl.github.io/posts/865846/index.html">
<meta property="og:site_name" content="Lin&#39;s Blog">
<meta property="og:description" content="什么是 RPC ？ RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。  RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。 RPC会隐藏底层的通讯细节（不">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/11/04/sog2J4pY6hmNDFq.jpg">
<meta property="article:published_time" content="2022-11-04T07:32:59.981Z">
<meta property="article:modified_time" content="2022-11-04T10:07:27.592Z">
<meta property="article:author" content="rtlin">
<meta property="article:tag" content="分布式系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/11/04/sog2J4pY6hmNDFq.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mumu-lsl.github.io/posts/865846/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RPC-框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-04 18:07:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/11/04/sog2J4pY6hmNDFq.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lin's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RPC-框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-04T07:32:59.981Z" title="发表于 2022-11-04 15:32:59">2022-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-04T10:07:27.592Z" title="更新于 2022-11-04 18:07:27">2022-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RPC-框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="什么是-RPC-？"><a href="#什么是-RPC-？" class="headerlink" title="什么是 RPC ？"></a>什么是 RPC ？</h1><p><img src="https://uploadfiles.nowcoder.com/files/20220607/3639882_1654583266812/4e7dfea3-6814-497f-a0db-31b59f0f3c10.png" alt="img"></p>
<p>RPC (Remote Procedure Call)即<strong>远程过程调用</strong>，是分布式系统常见的一种通信方法。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。</p>
<ul>
<li>RPC就是从一台机器（客户端）上<strong>通过参数传递的方式调用</strong>另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</li>
<li>RPC会<strong>隐藏底层的通讯细节</strong>（不需要直接处理Socket通讯或Http通讯）。</li>
<li>客户端发起请求，服务器返回响应（类似于Http的工作方式）RPC在<strong>使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）</strong>。</li>
</ul>
<p><strong>最终解决的问题：让分布式或者微服务系统中不同服务之间的调用（远程调用）像本地调用一样简单！</strong>调用者感知不到远程调用的逻辑。为此rpc需要解决三个问题（实现的关键）：</p>
<ul>
<li><strong>Call ID映射</strong>。我们怎么告诉远程机器（注册中心）我们要<strong>调用哪个函数呢</strong>？</li>
<li><strong>序列化和反序列化</strong>。客户端<strong>怎么把参数值传给远程的函数呢？</strong></li>
<li><strong>数据网络传输</strong>。远程调用往往是基于网络的，客户端和服务端是通过网络连接的。<strong>所有的数据都需要通过网络传输，因此就需要有一个网络传输层。</strong></li>
</ul>
<p>一个RPC框架要包含</p>
<ul>
<li>客户端和服务端建立网络连接模块( <strong>server</strong>模块、<strong>client</strong>模块 )</li>
<li>服务端<strong>处理请求模块</strong></li>
<li><strong>协议</strong>模块</li>
<li><strong>序列化</strong>和<strong>反序列</strong>模块。</li>
</ul>
<img src="https://upload-images.jianshu.io/upload_images/23383522-f5ebdd4af38ca892.png?imageMogr2/auto-orient/strip|imageView2/2/w/1132/format/webp" alt="img" style="zoom:67%;"> 

<p><strong>一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub可以理解为存根（调用与返回）</strong>。分别说说这几个组件：</p>
<ul>
<li>客户端（Client）： 服务的调用方。</li>
<li>服务端（Server）：真正的服务提供者。</li>
<li>客户端存根：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li>
<li>服务端存根：接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li>
</ul>
<img src="https://s2.loli.net/2022/05/12/pdEfnNuIwT6rJkK.png" alt="img" style="zoom: 80%;"> 

<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>代理模式是一种设计模式，能够使得在不修改源目标的前提下，额外扩展源目标的功能。即通过访问源目标的代理类，再由代理类去访问源目标。这样一来，要扩展功能，就无需修改源目标的代码了。只需要在代理类上增加就可以了。</p>
<p>其实代理模式的核心思想就是这么简单，在java中，代理又分静态代理和动态代理2种，其中动态代理根据不同实现又区分基于接口的的动态代理和基于子类的动态代理。</p>
<p>静态代理这种模式虽然好理解，但是缺点也很明显：</p>
<ul>
<li>会存在大量的冗余的代理类，这里演示了2个接口，如果有10个接口，就必须定义10个代理类。</li>
<li>不易维护，一旦接口更改，代理类和目标类都需要更改。</li>
</ul>
<p><strong>Jdk中的动态代理</strong></p>
<p>JDK中的动态代理是通过反射类Proxy以及InvocationHandler回调接口实现的，但是JDK中所有要进行动态代理的类必须要实现一个接口，也就是说只能对该类所实现接口中定义的方法进行代理，这在实际编程中有一定的局限性，而且使用反射的效率也不高</p>
<p><strong>Cglib实现</strong></p>
<p>使用cglib是实现动态代理，不受代理类必须实现接口的限制，因为cglib底层是用ASM框架，利用ASM框架，对代理对象类生成的class文件加载进来，通过修改其字节码生成子类来处理。比使用Java反射的效率要高，cglib不能对声明final的方法进行代理，因为cglib原理是动态生成被代理类的子类</p>
<p><strong>什么时候用cglib什么时候用jdk动态代理？</strong></p>
<p>1、目标对象生成了接口 默认用JDK动态代理</p>
<p>2、如果目标对象使用了接口，可以强制使用cglib</p>
<p>3、如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代理和cglib之间转换</p>
<p><strong>JDK动态代理和cglib字节码生成的区别？</strong></p>
<ul>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>Cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法的增强，但是因为采用的是继承，所以该类或方法最好不要生成final，对于final类或方法，是无法继承的</li>
</ul>
<p> <strong>Cglib比JDK快？</strong></p>
<ul>
<li>cglib底层是ASM字节码生成框架，但是字节码技术生成代理类，在JDL1.6之前比使用java反射的效率要高</li>
<li>在jdk6之后逐步对JDK动态代理进行了优化，在调用次数比较少时效率高于cglib代理效率</li>
<li>只有在大量调用的时候cglib的效率高，但是在1.8的时候JDK的效率已高于cglib</li>
<li>Cglib不能对声明final的方法进行代理，因为cglib是动态生成代理对象，final关键字修饰的类不可变只能被引用不能被修改</li>
</ul>
<p><strong>Spring如何选择是用JDK还是cglib？</strong></p>
<ul>
<li>当bean实现接口时，会用JDK代理模式</li>
<li>当bean没有实现接口，用cglib实现</li>
<li>可以强制使用cglib（在spring配置中加入&lt;aop:aspectj-autoproxy proxyt-target-class&#x3D;”true”&#x2F;&gt;）</li>
</ul>
<p>还有： 在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理。</p>
<p>动态代理，通俗点说就是：无需声明式的创建java代理类，而是在运行过程中生成”虚拟”的代理类，被ClassLoader加载。从而避免了静态代理那样需要声明大量的代理类。JDK从1.3版本就开始支持动态代理类的创建。主要核心类只有2个：<code>java.lang.reflect.Proxy</code>和<code>java.lang.reflect.InvocationHandler</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*处理代理实例上的方法并返回实例并返回结果,我们一般在此方法中添加一些额外的逻辑</span></span><br><span class="line"><span class="comment">* @param   proxy:   the proxy instance that the method was invoked on</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @param   method the &#123;@code Method&#125; instance corresponding to</span></span><br><span class="line"><span class="comment">* the interface method invoked on the proxy instance.  The declaring</span></span><br><span class="line"><span class="comment">* class of the &#123;@code Method&#125; object will be the interface that</span></span><br><span class="line"><span class="comment">* the method was declared in, which may be a superinterface of the</span></span><br><span class="line"><span class="comment">* proxy interface that the proxy class inherits the method through.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @param   args an array of objects containing the values of the</span></span><br><span class="line"><span class="comment">* arguments passed in the method invocation on the proxy instance,</span></span><br><span class="line"><span class="comment">* or &#123;@code null&#125; if interface method takes no arguments.</span></span><br><span class="line"><span class="comment">* Arguments of primitive types are wrapped in instances of the</span></span><br><span class="line"><span class="comment">* appropriate primitive wrapper class, such as</span></span><br><span class="line"><span class="comment">* &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*   @param  loader:   the class loader to define the proxy class</span></span><br><span class="line"><span class="comment">*    @param  interfaces:  the list of interfaces for the proxy class  to implement</span></span><br><span class="line"><span class="comment">*    @param  h :  the invocation handler to dispatch method invocations to</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span> </span><br><span class="line">    </span><br><span class="line"><span class="comment">//一般步骤为先new一个被代理对象，再生成调用处理器，最后得到代理对象的实例</span></span><br><span class="line"><span class="comment">//invoke()这个方法的第一个参数proxy可以用于返回，实现连续调用的效果	</span></span><br></pre></td></tr></table></figure>

<p>JDK的动态代理使用的最多的一种代理方式。也叫做接口代理。</p>
<p>JDK动态代理说白了只是根据接口”凭空“来生成类，至于具体的执行，都被代理到了<code>InvocationHandler</code> 的实现类里。上述例子我是需要继续执行原有bean的逻辑，才将原有的bean构造进来。只要你需要，你可以构造进任何对象到这个代理实现类。也就是说，你可以传入多个对象，或者说你什么类都不代理。只是为某一个接口”凭空“的生成多个代理实例，这多个代理实例最终都会进入<code>InvocationHandler</code>的实现类来执行某一个段共同的代码。</p>
<p>基于接口的代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JDKProxy</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">//处理代理实例上的方法并返回实例并返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke执行&quot;</span>);</span><br><span class="line">        String s=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JDKProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDKProxy</span>();</span><br><span class="line">        Person personProxy=(Person)Proxy.newProxyInstance(Person.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Person.class&#125;, proxy);</span><br><span class="line">        personProxy.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="BIO与NIO"><a href="#BIO与NIO" class="headerlink" title="BIO与NIO"></a>BIO与NIO</h1><p>参考： <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/769587#slide-12">https://developer.aliyun.com/article/769587#slide-12</a></p>
<ul>
<li>BIO 适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。</li>
<li>NIO 适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比 BIO，相对来说编程比较复杂。</li>
<li>AIO 适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及 I&#x2F;O 操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。</li>
</ul>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO是传统的Java IO编程，其基本的类和接口在java.io包中<br>BIO(blocking I&#x2F;O)：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销<br>BIO方式使用于连接数目比较小且固定的架构，这种服务方式对服务器资源要求比价高，并且局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</p>
<p><img src="https://img2020.cnblogs.com/blog/1563713/202011/1563713-20201105205737333-798691609.png" alt="img"></p>
<p>可以看出BIO编程的两个问题：</p>
<ol>
<li>服务器端在监听客户端连接时(serverSocket.accept())，服务器端处于阻塞状态，不能处理其他事务</li>
<li>服务器端需要为每个客户端建立一个线程，虽然可以用线程池来优化，但在并发较大时，线程开销依旧很大</li>
<li>当连接的客户端没有发送数据时，服务器端会阻塞在read操作上，等待客户端输入，造成线程资源浪费</li>
</ol>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>从JDK1.4开始，java提供了一系列改进输入&#x2F;输出的新特性，统称为<strong>NIO</strong>，全称n为<strong>new I&#x2F;O</strong>，是同步非阻塞的，所以也有人称为<strong>non-blocking I&#x2F;O</strong>。NIO的相关类都放在java.nio包或其子包下，并对原先java.io包中许多类进行了改写。</p>
<p><img src="https://img2020.cnblogs.com/blog/1563713/202011/1563713-20201105205852291-1646956541.png" alt="img"></p>
<p><strong>NIO的三大核心</strong></p>
<ol>
<li><strong>缓冲区(Buffer)</strong></li>
</ol>
<p>NIO是面向缓冲区, 或者说是面向块编程的。在NIO的IO传输中，数据会先读入到缓冲区，当需要时再从缓冲区写出，这样减少了直接读写磁盘的次数，提高了IO传输的效率。</p>
<p>缓冲区(buffer)本质上是一个可以读写数据的内存块，即在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入和输出的数据，这部分预留的存储空间就叫缓冲区。在NIO程序中，通道channel虽然负责数据的传输，但是输入和输出的数据都必须经过缓冲区buffer。</p>
<p>Buffer的常用子类（它们之间最大区别在于底层实现数组的数据类型）：</p>
<ul>
<li>ByteBuffer：存储字节数据到缓冲区</li>
<li>CharBuffer：存储字符数据到缓冲区</li>
<li>IntBuffer：存储整型数据到缓冲区</li>
<li>ShortBuffer：存储短整型数据到缓冲区</li>
<li>LongBuffer：存储长整型数据到缓冲区</li>
<li>FloatBuffer：存储浮点型数据到缓冲区</li>
<li>DoubleBuffer：存储双精度浮点型数据到缓冲区</li>
</ul>
<ol start="2">
<li><strong>通道(Channel)</strong></li>
</ol>
<p>在NIO程序中服务器端和客户端之间的数据读写不是通过流，而是通过通道来读写的。</p>
<p>通道类似于流，都是用来读写数据的，但它们之间也是有区别的：</p>
<ul>
<li>通道是双向的，即可以读也可以写，而流是单向的，只能读或写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲区读数据，也可以把数据写入缓冲区</li>
</ul>
<p>java中channel的相关类在java.nio.channel包下。Channel是一个接口，其常用的实现类有：</p>
<ul>
<li>FileChannel：用于文件的数据读写，其真正的实现类为FileChannelImpl</li>
<li>DatagramChannel：用于UDP的数据读写，其真正的实现类为DatagramChannelImpl</li>
<li>ServerSocketChannel：用于监听TCP连接，每当有客户端连接时都会创建一个SocketChannel，功能类似ServerSocket，其真正的实现类为ServerSocketChannelImpl</li>
<li>SocketChannel：用于TCP的数据读写，功能类似节点流+Socket，其真正的实现类为SocketChannelImpl</li>
</ul>
<ol start="3">
<li><strong>选择器(Selector)</strong></li>
</ol>
<p>在NIO程序中，可以用选择器Selector实现<strong>一个选择器处理多个通道，即一个线程处理多个连接</strong>。只要把通道注册到Selector上，就可以通过Selector来监测通道，如果通道有事件发生，便获取事件然后针对每个事件进行相应的处理。这样，只有在通道(连接)有真正的读&#x2F;写事件发生时，才会进行读写操作，大大减少了系统开销，并且不必为每个连接创建单独线程，就不用去维护过多的线程。</p>
<p>如果用阻塞I&#x2F;O，需要多线程（浪费内存），如果用非阻塞I&#x2F;O，需要不断重试（耗费CPU）。Selector的出现解决了这尴尬的问题，非阻塞模式下，通过Selector，我们的线程只为已就绪的通道工作，不用盲目的重试了。比如，当所有通道都没有数据到达时，也就没有Read事件发生，我们的线程会在select()方法处被挂起，从而让出了CPU资源。</p>
<p>选择器的相关类在java.nio.channels包和其子包下，顶层类是Selector，它是一个抽象类，它的常用方法有：</p>
<p><img src="https://s2.loli.net/2022/05/14/CEvQMDTjLr4F3ho.png" alt="图片"> </p>
<p>NIO服务器端如何实现非阻塞？</p>
<p>服务器上所有Channel需要向Selector注册，而Selector则负责监视这些Socket的IO状态(观察者)，当其中任意一个或者多个Channel具有可用的IO操作时，该Selector的select()方法将会返回大于0的整数，该整数值就表示该Selector上有多少个Channel具有可用的IO操作，并提供了selectedKeys（）方法来返回这些Channel对应的SelectionKey集合(一个SelectionKey对应一个就绪的通道)。正是通过Selector，使得服务器端只需要不断地调用Selector实例的select()方法即可知道当前所有Channel是否有需要处理的IO操作。注：java NIO就是多路复用IO，jdk7之后底层是epoll模型。</p>
<h2 id="NIO与BIO的对比"><a href="#NIO与BIO的对比" class="headerlink" title="NIO与BIO的对比"></a>NIO与BIO的对比</h2><p>Linux IO模式 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003063859">https://segmentfault.com/a/1190000003063859</a></p>
<p>阻塞式IO</p>
<p><img src="https://pic1.zhimg.com/v2-7f73fdcaca316aa0f12d77b6873785e5_r.jpg?source=1940ef5c" alt="preview"></p>
<p>非阻塞IO</p>
<p><img src="https://pic1.zhimg.com/v2-51e052e2beecef41da3aed3ebc2b80bd_r.jpg?source=1940ef5c" alt="preview"></p>
<p>异步IO</p>
<p><img src="https://pica.zhimg.com/80/v2-b01988dd44a5edbe596a280d1c266033_1440w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="Reactor模型和Proactor模型"><a href="#Reactor模型和Proactor模型" class="headerlink" title="Reactor模型和Proactor模型"></a>Reactor模型和Proactor模型</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)</a></p>
<h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>常见的 Reactor 实现方案有三种。</p>
<ul>
<li><p>第一种方案单 Reactor 单进程 &#x2F; 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于CPU密集型的场景，适用于业务处理快速的场景，比如 Redis 采用的是单 Reactor 单进程的方案。</p>
</li>
<li><p>第二种方案单 Reactor 多线程，通过多线程的方式解决了方案一的缺陷，但它离高并发还差一点距离，差在只有一个 Reactor 对象来承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。</p>
</li>
<li><p>第三种方案多 Reactor 多进程 &#x2F; 线程，通过多个 Reactor 来解决了方案二的缺陷，主 Reactor 只负责监听事件，响应事件的工作交给了从 Reactor，Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案，Nginx 则采用了类似于 「多 Reactor 多进程」的方案。</p>
<img src="https://picx.zhimg.com/80/v2-4da008d8b7f55a0c18bef0e87c5c5bb1_1440w.jpg?source=1940ef5c" alt="img" style="zoom: 50%;"></li>
</ul>
<h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p>前面提到的 Reactor 是非阻塞同步网络模式，而 <strong>Proactor 是异步网络模式</strong>。真正的<strong>异步 I&#x2F;O</strong> 是「内核数据准备好」和「数据从内核态拷贝到<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%A8%E6%88%B7%E6%80%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1856426252%7D">用户态</a>」这<strong>两个过程都不用等待</strong>。</p>
<p><img src="https://picx.zhimg.com/80/v2-35bd4bdf3b12246fb005415d3a29ecc0_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」。</p>
<p>现在我们再来理解 Reactor 和 Proactor 的区别，</p>
<ul>
<li><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li>
<li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li>
</ul>
<p>不过，无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 Reactor 模式是基于「待完成」的 I&#x2F;O 事件，而 Proactor 模式则是基于「已完成」的 I&#x2F;O 事件。</p>
<h1 id="两个项目的难点"><a href="#两个项目的难点" class="headerlink" title="两个项目的难点"></a>两个项目的难点</h1><h1 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h1><h2 id="最初的实现"><a href="#最初的实现" class="headerlink" title="最初的实现"></a>最初的实现</h2><p>定义接口: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServiceRegistry</span> &#123;  </span><br><span class="line">    &lt;T&gt; <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(T service)</span>;</span><br><span class="line">    Object <span class="title function_">getService</span><span class="params">(String serviceName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用DefaultServiceRegistry 来实现这个接口，并提供服务。这里的重点是使用<code>ConcurrentHashMap</code> 来保存服务名与提供服务的对象的对应关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(T service)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> service.getClass().getCanonicalName(); <span class="comment">//获取服务的全类名</span></span><br><span class="line">        <span class="keyword">if</span>(registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(interfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.SERVICE_NOT_IMPLEMENT_ANY_INTERFACE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; i : interfaces) &#123;</span><br><span class="line">            serviceMap.put(i.getCanonicalName(), service);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;</span>, interfaces, serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">getService</span><span class="params">(String serviceName)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">service</span> <span class="operator">=</span> serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span>(service == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个请求处理线程要执行的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line">             <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream())) &#123;</span><br><span class="line">            <span class="comment">//获取请求对象</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> (RpcRequest) objectInputStream.readObject();</span><br><span class="line">            <span class="comment">//获取需要的服务名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">interfaceName</span> <span class="operator">=</span> rpcRequest.getInterfaceName();</span><br><span class="line">            <span class="comment">//获取服务</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">service</span> <span class="operator">=</span> serviceRegistry.getService(interfaceName);</span><br><span class="line">            <span class="comment">//使用动态代理来执行服务，并获取结果</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> requestHandler.handle(rpcRequest, service);</span><br><span class="line">           </span><br><span class="line">       		<span class="comment">//将结果写回并刷新缓冲区</span></span><br><span class="line">            objectOutputStream.writeObject(RpcResponse.success(result));</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="rpc-core"><a href="#rpc-core" class="headerlink" title="rpc-core"></a>rpc-core</h2><h3 id="注解类"><a href="#注解类" class="headerlink" title="注解类"></a>注解类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 个 Annotation 和 <span class="number">1</span>~n 个 ElementType 关联。ElementType.TYPE</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 个 Annotation 和 <span class="number">1</span> 个 RetentionPolicy 关联。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个服务提供类，用于远程接口的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ziyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Target</span>(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。</span></span><br><span class="line"><span class="comment"> * 这就意味着，MyAnnotation1 是来修饰&quot;类、接口（包括注释类型）或枚举声明&quot;的注解。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个注解将在服务器端启动时，将我们用注解标注过的服务自动注册。具体的逻辑就是：</p>
<p>我们使用ReflectUtil.getStackTrace() 这个方法获取主类名以及具体的路径，并获取启动类的类对象。这个类对象中包含了标注的注解信息，其中就有ServiceScan注解，然后通过ServiceScan注解的value属性 获取服务所在的基包。最后我们扫描这个基包拥有的所有类（即服务），并获取它们的类对象以及实例对象，最后将其注册到注册中心去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scanServices</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">mainClassName</span> <span class="operator">=</span> ReflectUtil.getStackTrace();</span><br><span class="line">      Class&lt;?&gt; startClass;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          startClass = Class.forName(mainClassName);</span><br><span class="line">          <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan.class)) &#123;</span><br><span class="line">              logger.error(<span class="string">&quot;启动类缺少 @ServiceScan 注解&quot;</span>);</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          logger.error(<span class="string">&quot;出现未知错误&quot;</span>);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.UNKNOWN_ERROR);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> startClass.getAnnotation(ServiceScan.class).value();</span><br><span class="line">      <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(basePackage)) &#123;</span><br><span class="line">          basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          basePackage = mainClassName.substring(<span class="number">0</span>,mainClassName.lastIndexOf(<span class="string">&quot;.&quot;</span>))+<span class="string">&quot;.&quot;</span>+basePackage;</span><br><span class="line">      &#125;</span><br><span class="line">      Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">      <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">          <span class="keyword">if</span>(clazz.isAnnotationPresent(Service.class)) &#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> clazz.getAnnotation(Service.class).name();</span><br><span class="line">              Object obj;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  obj = clazz.newInstance();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                  logger.error(<span class="string">&quot;创建 &quot;</span> + clazz + <span class="string">&quot; 时有错误发生&quot;</span>);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(serviceName)) &#123;</span><br><span class="line">                  Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                  <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                      publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  publishService(obj, serviceName);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>在传输过程中，我们可以在发送的数据上加上各种必要的数据，形成自定义的协议，而自动加上这个数据就是编码器的工作，解析数据获得原始数据就是解码器的工作。编解码器都继承了netty的编解码器的类</p>
<p>+—————+—————+—————–+————-+<br>|  Magic Number |  Package Type | Serializer Type | Data Length |<br>|    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |<br>+—————+—————+—————–+————-+<br>|                          Data Bytes                                   |<br>|                   Length: ${Data Length}                      |<br>+—————————————————————+</p>
<p>Data Length 就是实际数据的长度，设置这个字段主要防止<strong>粘包</strong></p>
<p>编解码器的实现都非常简单，主要就是按照协议的格式来进行编码s和解码，其中会涉及到netty的知识以及序列化和反序列化的知识。</p>
<p>序列化和反序列化的实现方式需要我们自己去实现</p>
<p>一个简单的例子：使用Jkson工具实现Json方式的序列化和反序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerializer</span> <span class="keyword">implements</span> <span class="title class_">CommonSerializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(JsonSerializer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Overrid</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsBytes(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;序列化时有错误发生: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> objectMapper.readValue(bytes, clazz);</span><br><span class="line">            <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">                obj = handleRequest(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;反序列化时有错误发生: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里由于使用JSON序列化和反序列化Object数组，无法保证反序列化后仍然为原实例类型</span></span><br><span class="line"><span class="comment">        需要重新判断处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">handleRequest</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> (RpcRequest) obj;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rpcRequest.getParamTypes().length; i ++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = rpcRequest.getParamTypes()[i];</span><br><span class="line">            <span class="keyword">if</span>(!clazz.isAssignableFrom(rpcRequest.getParameters()[i].getClass())) &#123;</span><br><span class="line">                <span class="type">byte</span>[] bytes = objectMapper.writeValueAsBytes(rpcRequest.getParameters()[i]);</span><br><span class="line">                rpcRequest.getParameters()[i] = objectMapper.readValue(bytes, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">&quot;JSON&quot;</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化和反序列化都比较循规蹈矩，把对象翻译成字节数组，和根据字节数组和 Class 反序列化成对象。这里有一个需要注意的点，就是在 RpcRequest 反序列化时，由于其中有一个字段是 Object 数组，在反序列化时序列化器会根据字段类型进行反序列化，而 Object 就是一个十分模糊的类型，会出现反序列化失败的现象，这时就需要 RpcRequest 中的另一个字段 ParamTypes 来获取到 Object 数组中的每个实例的实际类，辅助反序列化，这就是 handleRequest() 方法的作用。</p>
<p>上面提到的这种情况不会在其他序列化方式中出现，因为其他序列化方式是转换成字节数组，会记录对象的信息，而 JSON 方式本质上只是转换成 JSON 字符串，会丢失对象的<strong>类型信息</strong>。</p>
<h3 id="NettyServer的实现："><a href="#NettyServer的实现：" class="headerlink" title="NettyServer的实现："></a>NettyServer的实现：</h3><p>NettyRpcServerHandler业务处理器<br>业务处理器处理三类事件：</p>
<ul>
<li>异常事件：直接关闭连接</li>
<li>心跳事件：客户端会每隔5s发送一次心跳ping，如果服务端持续30s没有收到心跳消息，说明连接可能已失效，则关闭连接</li>
<li>读事件：根据RpcMessage的属性确定接收到的消息类型：<ul>
<li>若是心跳ping，则返回心跳pong</li>
<li>若是RpcRequest，则调用服务方法，返回调用结果</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">256</span>)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">CommonEncoder</span>(<span class="keyword">new</span> <span class="title class_">JsonSerializer</span>()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">CommonDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;启动服务器时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="NettyClient-的实现"><a href="#NettyClient-的实现" class="headerlink" title="NettyClient 的实现"></a>NettyClient 的实现</h3><p>客户端主要实现服务调用请求的发送和请求结果的接收</p>
<p>客户端通过Bootstrap创建，在pipeline中添加IdleStateHandler心跳处理器，编码解码器，NettyRpcClientHandler业务处理器</p>
<p>1）发送服务调用请求<br>发送服务调用请求的步骤：</p>
<ol>
<li>根据服务名获取服务提供方的地址</li>
<li>根据地址创建与服务端的连接（连接利用一个Map进行存储，如果已经创建过了则复用该连接）</li>
<li>构建RpcMessage并通过该连接发送</li>
</ol>
<p>2）请求结果的接收<br>难点：通过上述方法异步发送RpcRequest后，RpcResponse只能在NettyRpcClientHandler中通过read方法接收，那么该如何获取请求结果呢</p>
<p>解决方案：通过CompletableFuture异步获取请求</p>
<p>步骤：</p>
<ol>
<li>为每个请求创建一个CompletableFuture<RpcResponse></RpcResponse></li>
<li>用一个ConcurrentHashMap保存已发送且未收到回复的请求（key为requestId，value为该请求的CompletableFuture<RpcResponse>）</RpcResponse></li>
<li>通过上述发送请求时，在该Map中存入该请求的CompletableFuture<RpcResponse>，且方法返回该Future<br>NettyRpcClientHandler收到服务器返回的调用结果后，从Map中移除该CompletableFuture<RpcResponse>，并为该Future设置好调用结果</RpcResponse></RpcResponse></li>
<li>这样调用方就可以通过CompletableFuture.get()获取到调用结果了（如果未设置结果则一直阻塞）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;RpcResponse&gt; <span class="title function_">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="literal">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//利用服务发现，在nacos注册中心找到可用的服务地址，并将请求发送到这个地址去请求服务。</span></span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span> (!channel.isActive()) &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">&quot;客户端发送消息: %s&quot;</span>, rpcRequest.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future1.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">                    logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, future1.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            unprocessedRequests.remove(rpcRequest.getRequestId());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>channel 将 RpcRequest 对象写出，并且等待服务端返回的结果。注意这里的发送是非阻塞的，所以发送后会立刻返回，而无法得到结果。这里通过 <code>AttributeKey</code> 的方式阻塞获得返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line"><span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> channel.attr(key).get();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这种方式获得全局可见的返回结果，在获得返回结果 RpcResponse 后，将这个对象以 key 为 rpcResponse 放入 ChannelHandlerContext 中，这里就可以立刻获得结果并返回，我们会在 <code>NettyClientHandler</code> 中看到放入的过程。</p>
<h3 id="NettyServerHandler-和-NettyClientHandler"><a href="#NettyServerHandler-和-NettyClientHandler" class="headerlink" title="NettyServerHandler 和 NettyClientHandler"></a>NettyServerHandler 和 NettyClientHandler</h3><p>NettyServerHandler 和 NettyClientHandler 都分别位于服务器端和客户端责任链的尾部，直接和 RpcServer 对象或 RpcClient 对象打交道，而无需关心字节序列的情况。</p>
<ul>
<li>NettyServerhandler 用于接收 RpcRequest，并且执行调用，将调用结果返回封装成 RpcResponse 发送出去。</li>
<li>NettyClientHandler用于接受响应包，并将响应包向上传递。</li>
</ul>
<h3 id="kryo序列化方法"><a href="#kryo序列化方法" class="headerlink" title="kryo序列化方法"></a>kryo序列化方法</h3><p>我们将kryo对象放在ThreadLocal对象中，一个线程一个kryo。</p>
<p>序列化时：先创建一个 Output 对象（Kryo 框架的概念），接着使用 writeObject 方法将对象写入 Output 中，最后调用 Output 对象的 toByte() 方法即可获得对象的字节数组</p>
<p>反序列化时：是从 Input 对象中直接 readObject，这里只需要传入对象的类型，而不需要具体传入每一个属性的类型信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">CommonSerializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(KryoSerializer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        kryo.setReferences(<span class="literal">true</span>);</span><br><span class="line">        kryo.setRegistrationRequired(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">             <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream))&#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;序列化时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;序列化时有错误发生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;反序列化时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;反序列化时有错误发生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">&quot;KRYO&quot;</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="几种序列化方式的优劣"><a href="#几种序列化方式的优劣" class="headerlink" title="几种序列化方式的优劣"></a>几种序列化方式的优劣</h3><p>实现了 JSON、Kryo、和 <a href>Proto</a>buf 的序列化。</p>
<p>JSON 是一种轻量级的<a href>数据</a>交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的<a href>数据</a>对象，类似 xml，Json 比 xml更小、更快更容易解析。JSON 由于采用字符方式存储，占用相对于字节方式较大，并且序列化后类的信息会丢失，可能导致反序列化失败。</p>
<p>剩下的都是基于字节的序列化。</p>
<p>Kryo 是一个快速高效的 Java 序列化框架，旨在提供快速、高效和易用的 API。无论文件、<a href>数据</a>库或网络<a href>数据</a> Kryo 都可以随时完成序列化。 <strong>Kryo 还可以执行自动深拷贝、浅拷贝</strong>。这是对象到对象的直接拷贝，而不是对象-&gt;字节-&gt;对象的拷贝。kryo 速度较快，序列化后体积较小，<strong>但是跨语言支持较复杂。</strong></p>
<p>protobuf（Protocol Buffers）是由 Google 发布的<a href>数据</a>交换格式，提供跨语言、跨平台的序列化和反序列化实现，底层由 C++ 实现，其他平台使用时必须使用 protocol compiler 进行预编译生成 protoc 二进制文件。性能主要消耗在文件的预编译上。序列化反序列化性能较高，平台无关。</p>
<p><strong>jdk 自带对象序列化类</strong></p>
<ul>
<li>1.无法跨语言。这应该是java序列化最致命的问题了。由于java序列化是java内部私有的协议，其他语言不支持，导致别的语言无法反序列化，这严重阻碍了它的应用。</li>
<li>2.序列后的码流太大，java序列化的大小是二进制编码的5倍多！</li>
<li>3.序列化性能太低。java序列化的性能只有二进制编码的6.17倍，可见java序列化性能实在太差了。</li>
</ul>
<p><strong>Thrift 方式</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>序列化和RPC支持一站式解决，比pb更方便 。</li>
<li>跨语言，IDL接口定义语言，自动生成多语言文件 。</li>
<li>省流量，体积较小 。</li>
<li>包含完整的客户端&#x2F;服务端堆栈，可快速实现RPC 。</li>
<li>为服务端提供了多种工作模式，如线程池模型、非阻塞模型。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>不支持双通道 。</li>
<li>rpc方法非线程安全，服务器容易被挂死，需要串行化。</li>
<li>默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li>
<li>开发环境、编译较麻烦。</li>
</ol>
<h3 id="使用Nacos作为服务器注册与发现"><a href="#使用Nacos作为服务器注册与发现" class="headerlink" title="使用Nacos作为服务器注册与发现"></a>使用Nacos作为服务器注册与发现</h3><h1 id="几种注册中心的对比"><a href="#几种注册中心的对比" class="headerlink" title="几种注册中心的对比"></a>几种注册中心的对比</h1><p>我们之前的注册与发现是用一个ConcurrentHashMap来进行存储的。这存在一个隐患，当我们将服务端地址固化在代码中，对于客户端来说，它只会去寻找一个服务提供者，但如果这个提供者挂掉了或者换了地址，那就没有办法了。</p>
<p>在分布式架构中，有一个重要的组件，就是服务注册中心，它用于保存多个服务提供者的信息，每个服务提供者在启动时都需要向注册中心注册自己所拥有的服务。这样客户端在发起 RPC 时，就可以直接去向注册中心请求服务提供者的信息，如果拿来的这个挂了，还可以重新请求，并且在这种情况下可以很方便地实现负载均衡。</p>
<p>在最初的实现中，我们使用了本地保存服务的类称为 <code>ServiceRegistry</code>，现在更改为 <code>ServiceProvider</code>，而 <code>ServiceRegistry</code> 作为远程注册表（Nacos）使用，对应的类名也有修改。我们定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServiceRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span>;</span><br><span class="line">    InetSocketAddress <span class="title function_">lookupService</span><span class="params">(String serviceName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法很好理解，register 方法将服务的名称和地址注册进服务注册中心，lookupService 方法则是根据服务名称从注册中心获取到一个服务提供者的地址。</p>
<p>我们让NacosServiceRegistry实现这个接口,以供服务器调用，注册服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosServiceRegistry</span> <span class="keyword">implements</span> <span class="title class_">ServiceRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(NacosServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_ADDR</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1:8848&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            namingService = NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接到Nacos时有错误发生: &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            namingService.registerInstance(serviceName, inetSocketAddress.getHostName(), inetSocketAddress.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;注册服务时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InetSocketAddress <span class="title function_">lookupService</span><span class="params">(String serviceName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = namingService.getAllInstances(serviceName);</span><br><span class="line">            <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取服务时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自动注销服务和负载均衡策略"><a href="#自动注销服务和负载均衡策略" class="headerlink" title="自动注销服务和负载均衡策略"></a>自动注销服务和负载均衡策略</h3><h4 id="自动注销服务"><a href="#自动注销服务" class="headerlink" title="自动注销服务"></a>自动注销服务</h4><p>如果你启动完成服务端后把服务端给关闭了，并不会自动地注销 Nacos 中对应的服务信息，这样就导致了当客户端再次向 Nacos 请求服务时，会获取到已经关闭的服务端信息，最终就有可能因为连接不到服务器而调用失败。</p>
<p>那么我们就需要一种办法，在服务端关闭之前自动向 Nacos 注销服务。但是有一个问题，我们不知道什么时候服务器会关闭，也就不知道这个方法调用的时机，就没有办法手工去调用。这时，我们就需要钩子。</p>
<p>钩子是什么呢？是在某些事件发生后自动去调用的方法。那么我们只需要把注销服务的方法写到关闭系统的钩子方法里就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//钩子函数    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> address.getHostName();</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;注销服务 &#123;&#125; 失败&quot;</span>, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用了单例模式创建其对象，在 addClearAllHook 中，Runtime 对象是 JVM 虚拟机的运行时环境，调用其<code>addShutdownHook</code>方法增加一个钩子函数，创建一个新线程调用 clearRegistry 方法完成注销工作。这个钩子函数会在 JVM 关闭之前被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShutdownHook</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ShutdownHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> ThreadPoolFactory.createDefaultThreadPool(<span class="string">&quot;shutdown-hook&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ShutdownHook</span> <span class="variable">shutdownHook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShutdownHook</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title function_">getShutdownHook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addClearAllHook</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;关闭后将自动注销所有服务&quot;</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><p>一个客户端的负载均衡器， 使用自己定义的负载均衡器（随机算法，轮转算法），当我们在客户端需要某个服务的时候，就利用服务发现机制，以及负载均衡算法得到一个适合的服务地址，然后向对应地址的服务器发起请求。</p>
<h2 id="rpc-client-rpc-server"><a href="#rpc-client-rpc-server" class="headerlink" title="rpc-client,rpc-server"></a>rpc-client,rpc-server</h2><p>保证通用性，我们定义两个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RpcClient</span> &#123;</span><br><span class="line">    Object <span class="title function_">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158516573">一、Netty简介与IO模型 - 知乎 (zhihu.com)</a></p>
<h2 id="RPC调用过程"><a href="#RPC调用过程" class="headerlink" title="RPC调用过程"></a>RPC调用过程</h2><ol>
<li><p>首先服务器端启动，通过我们自定义的注解将服务地址等信息注册到注册中心，客户端要发起请求，它首先会创建一个请求的实例，客户端组装的请求实例中包含这样几个属性，调用接口名称，方法名称，方法参数，参数类型，是否心跳包。</p>
</li>
<li><p>它首先会来到注册中心，根据请求实例对象，获取所有对应的服务实例信息，然后通过本地的负载均衡算法选择一个合适的服务器来发起请求。</p>
</li>
<li><p>在发起请求之前，客户端通过netty来与服务器端建立连接（通过异步的方式），然后得到相应的channel。之后这个客户端与服务器的交互都是通过这个channel来实现。</p>
</li>
<li><p>得到channel之后，客户端在发起请求，这个请求首先经过客户端的netty的出站处理器的处理。在客户端的出栈处理器里包含编码器（编码器中进行序列化），空闲时处理器。经过了出栈处理器的处理后。请求会到达服务器端。</p>
</li>
<li><p>请求到达服务器端，服务器端其实也有一个被注册到工作线程组中某个事件循环的selector的channel。它用于与客户端的相应的channel通信。channel事件消息在ChannelPipeline中流动和传播，相应的事件能够被ChannelHandler拦截处理、传递、忽略或者终止 。 客户端发起的请求报文会经过该channel入栈处理器的处理。主要是在解码器中进行解码和反序列化。</p>
</li>
<li><p>解码器将请求报文解析成一个request类，它会被channelPipeline的末端NettyServerHandler处理。在这个处理器中调用请求的方法，我们在服务器端会将所有的服务和它的全类名存入到一个Map的集合中，在处理器中我们通过全类名得到服务实例对象，然后通过实例对象的Class对象获取方法的实例，最后通过调用method.invoke方法来得到最终的结果。</p>
</li>
<li><p>我们将结果封装为一个response对象，通过ChannelHandlerContext对象将响应包写回发送给客户端，当然这个过程也要经过服务器端的出站处理器的处理，主要是在编码器中进行编码和序列化。</p>
</li>
</ol>
<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangwei19871103/article/details/104011694">(229条消息) 吃透Netty源码系列一之NioEventLoopGroup_王伟王胖胖的博客-CSDN博客</a></p>
<p><a href>Netty</a> 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。<a href>Netty</a> 基于 NIO 的，封装了 JDK 的 NIO，让我们使用起来更加方法灵活。</p>
<p>特点和优势：</p>
<ul>
<li>使用简单：封装了 NIO 的很多细节，使用更简单。 </li>
<li>功能强大：预置了多种编解码功能，支持多种主流协议。 </li>
<li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。 </li>
<li>性能高：通过与其他业界主流的 NIO 框架对比，<a href>Netty</a> 的综合性能最优。</li>
</ul>
<h3 id="为什么-Netty-性能高"><a href="#为什么-Netty-性能高" class="headerlink" title="为什么 Netty 性能高"></a>为什么 <a href>Netty</a> 性能高</h3><ul>
<li>IO 线程模型：同步非阻塞，用最少的资源做更多的事。 </li>
<li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。 </li>
<li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。 </li>
<li>串行化处理读写：避免使用锁带来的性能开销。 </li>
<li>高性能序列化协议：支持 protobuf 等高性能序列化协议。</li>
</ul>
<p>Netty是一个NIO框架，它将IO通道的建立、可读、可写等状态变化，抽象成事件，以责任链的方式进行传递，可以在处理链上插入自定义的Handler，对感兴趣的事件进行监听和处理。Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端&#x2F;服务器框架。</p>
<p>Netty 推荐使用<strong>主从Reactor模型</strong>，Netty 主线程组BossGroup用于客户端的监听，并将监听到的客户端Channel注册到从线程组WorkGroup上的一个NIOEventLoop的Selector上，这个NIOEventLoop主要用于和客户端数据的 Read &#x2F; Write，客户端和服务端会在数据传输的管道ChannelPipeline中调用InboundHandler&#x2F;OutboundHandler对数据进行处理。</p>
<p>在netty中I&#x2F;O操作都是异步执行，所以任何的I&#x2F;O调用都将立即返回。netty为我们提供了一个ChannelFuture实例，这个实例将会返回关于I&#x2F;O操作结果或者状态。<strong>我们可以通过 addListener()为ChannelFuture添加监听器</strong>，这样当相关的操作执行结束之后就会发送消息给监听器。</p>
<ul>
<li>Netty 是由 JBOSS 提供的一个 Java 开源框架， 现为 Github 上的独立项目。</li>
<li>Netty 是一个异步的、 基于事件驱动的网络应用框架， 用以快速开发高性能、 高可靠性的网络 IO 程序。</li>
<li>Netty 本质是一个 NIO 框架， 适用于服务器通讯相关的多种应用场景。</li>
</ul>
<p><img src="https://s2.loli.net/2022/05/14/VnOqH4UGvl1JeB2.png" alt="image.png">  </p>
<p><img src="https://s2.loli.net/2022/08/17/2StsFBWNvxCbX7z.png" alt="在这里插入图片描述"></p>
<p>Netty pipeline 分析：</p>
<p>参考： <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6efa9c5fa702">https://www.jianshu.com/p/6efa9c5fa702</a></p>
<h3 id="说下-Netty-零拷贝"><a href="#说下-Netty-零拷贝" class="headerlink" title="说下 Netty 零拷贝"></a>说下 <a href>Netty</a> 零拷贝</h3><p><a href>Netty</a> 的零拷贝主要包含三个方面：</p>
<ul>
<li><a href>Netty</a> 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，<strong>使用堆外直接内存进行 Socket 读写</strong>，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 </li>
<li><a href>Netty</a> 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。 </li>
<li><a href>Netty</a> 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的<a href>数据</a>发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</li>
</ul>
<h3 id="Netty-中责任链"><a href="#Netty-中责任链" class="headerlink" title="Netty 中责任链"></a><a href>Netty</a> 中责任链</h3><p>首先说明责任链模式：</p>
<p>适用场景:</p>
<ul>
<li>对于一个请求来说,如果有个对象都有机会处理它,而且不明确到底是哪个对象会处理请求时,我们可以考虑使用责任链模式实现它,让请求从链的头部往后移动,直到链上的一个节点成功处理了它为止</li>
</ul>
<p>优点:</p>
<ul>
<li>发送者不需要知道自己发送的这个请求到底会被哪个对象处理掉,实现了发送者和接受者的解耦 </li>
<li>简化了发送者对象的设计 </li>
<li>可以动态的添加节点和删除节点</li>
</ul>
<p>缺点:</p>
<ul>
<li>所有的请求都从链的头部开始遍历,对性能有损耗 </li>
<li>极差的情况,不保证请求一定会被处理</li>
</ul>
<p><a href>Netty</a>的责任链：</p>
<p>netty 的 pipeline 设计,就采用了责任链设计模式, 底层采用双向<a href>链表</a>的数据结构, 将链上的各个处理器串联起来</p>
<p>客户端每一个请求的到来，netty 都认为，pipeline 中的所有的处理器都有机会处理它，因此，对于入栈的请求，全部从头节点开始往后传播，一直传播到尾节点（来到尾节点的 msg 会被释放掉）。</p>
<p>责任终止机制</p>
<ul>
<li>在pipeline中的任意一个节点，只要我们不手动的往下传播下去，这个事件就会终止传播在当前节点 </li>
<li>对于入站<a href>数据</a>，默认会传递到尾节点，进行回收，如果我们不进行下一步传播，事件就会终止在当前节点</li>
</ul>
<h3 id="简单说下-Netty-中的重要组件"><a href="#简单说下-Netty-中的重要组件" class="headerlink" title="简单说下 Netty 中的重要组件"></a>简单说下 <a href>Netty</a> 中的重要组件</h3><ul>
<li>Channel：<a href>Netty</a> 网络操作抽象类，它除了包括基本的 I&#x2F;O 操作，如 bind、connect、read、write 等。 </li>
<li>EventLoop：主要是配合 Channel 处理 I&#x2F;O 操作，用来处理连接的生命周期中所发生的事情。 </li>
<li>ChannelFuture：<a href>Netty</a> 框架中所有的 I&#x2F;O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。 </li>
<li>ChannelHandler：充当了所有处理入站和出站<a href>数据</a>的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、<a href>数据</a>接收、异常、<a href>数据</a>转换等。 </li>
<li>ChannelPipeline：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。</li>
</ul>
<h3 id="netty粘包和拆包问题"><a href="#netty粘包和拆包问题" class="headerlink" title="netty粘包和拆包问题"></a>netty粘包和拆包问题</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rickiyang/p/12904552.html">Netty 中的粘包和拆包 - rickiyang - 博客园 (cnblogs.com)</a></p>
<p>在RPC框架中，粘包和拆包问题是必须解决一个问题，因为RPC框架中，各个微服务相互之间都是维系了一个TCP长连接，比如dubbo就是一个全双工的长连接。由于微服务往对方发送信息的时候，所有的请求都是使用的同一个连接，这样就会产生粘包和拆包的问题</p>
<p><strong>出现粘包、拆包现象的根本原因</strong></p>
<p>1、客户端要发送的数据小于TCP发送缓冲区的大小，TCP为了提升效率，将多个写入缓冲区的数据包一次发送出去，多个数据包粘在一起，造成粘包；<br>2、服务端的应用层没有及时处理接收缓冲区中的数据，再次进行读取时出现粘包问题；<br>3、数据发送过快，数据包堆积导致缓冲区积压多个数据后才一次性发送出去；<br>4、拆包一般由于一次发送的数据包太大，超过MSS的大小，那么这个数据包就会被拆成多个TCP报文分开进行传输。</p>
<h4 id="1-定长协议"><a href="#1-定长协议" class="headerlink" title="1. 定长协议"></a>1. 定长协议</h4><p>指定一个报文具有固定长度。比如约定一个报文的长度是 5 字节，那么：</p>
<p>报文：1234，只有4字节，但是还差一个怎么办呢，不足部分用空格补齐。就变为：1234 。</p>
<p>如果不补齐空格，那么就会读到下一个报文的字节来填充上一个报文直到补齐为止，这样粘包了。</p>
<p>定长协议的优点是使用简单，缺点很明显：浪费带宽。</p>
<p>Netty 中提供了 <code>FixedLengthFrameDecoder</code> ，支持把固定的长度的字节数当做一个完整的消息进行解码。</p>
<h4 id="2-特殊字符分割协议"><a href="#2-特殊字符分割协议" class="headerlink" title="2. 特殊字符分割协议"></a>2. 特殊字符分割协议</h4><p>很好理解，在每一个你认为是一个完整的包的尾部添加指定的特殊字符，比如：\n，\r等等。</p>
<p>需要注意的是：约定的特殊字符要保证唯一性，不能出现在报文的正文中，否则就将正文一分为二了。</p>
<p>Netty 中提供了 <code>DelimiterBasedFrameDecoder</code> 根据特殊字符进行解码，<code>LineBasedFrameDecoder</code>默认以换行符作为分隔符。</p>
<h4 id="3-变长协议"><a href="#3-变长协议" class="headerlink" title="3. 变长协议"></a>3. 变长协议</h4><p>变长协议的核心就是：<strong>将消息分为消息头和消息体，消息头中标识当前完整的消息体长度。</strong></p>
<ol>
<li>发送方在发送数据之前先获取数据的二进制字节大小，然后在消息体前面添加消息大小；</li>
<li>接收方在解析消息时先获取消息大小，之后必须读到该大小的字节数才认为是完整的消息。</li>
</ol>
<p>Netty 中提供了 <code>LengthFieldBasedFrameDecoder</code> ，通过<code>LengthFieldPrepender</code> 来给实际的消息体添加 length 字段。</p>
<h3 id="如何解决-TCP-的粘包拆包问题"><a href="#如何解决-TCP-的粘包拆包问题" class="headerlink" title="如何解决 TCP 的粘包拆包问题"></a>如何解决 TCP 的粘包拆包问题</h3><p>TCP 是以流的方式来处理<a href>数据</a>，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的<a href>数据</a>包发送。</p>
<p>TCP 粘包&#x2F;分包的原因：应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入<a href>数据</a>小于套接字缓冲区大小，网卡将应用多次写入的<a href>数据</a>发送到网络上，这将会发生粘包现象；</p>
<p><a href>Netty</a> 自带解决方式：</p>
<ul>
<li>消息定长：FixedLengthFrameDecoder 类</li>
<li>包尾增加特殊字符分割：<ul>
<li>行分隔符类：LineBasedFrameDecoder </li>
<li>自定义分隔符类 ：DelimiterBasedFrameDecoder</li>
</ul>
</li>
<li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li>
</ul>
<p>框架解决方式：</p>
<p><strong>自定义协议，其中有字段标明包长度。</strong></p>
<h3 id="netty心跳机制"><a href="#netty心跳机制" class="headerlink" title="netty心跳机制"></a>netty心跳机制</h3><p>在RpcRequest中，我们增加了一个属性<code>heartBeat</code> ,使用这个属性在NettyClientHandler中我们定义了一个触发器，这个触发器会在ChannelProvider类的get方法中，我们绑定了这样一个处理器：<code>addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS))</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">               <span class="comment">/*自定义序列化编解码器*/</span></span><br><span class="line">               <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">               ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">CommonEncoder</span>(serializer))</span><br><span class="line">                       .addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                       .addLast(<span class="keyword">new</span> <span class="title class_">CommonDecoder</span>())</span><br><span class="line">                       .addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<p>IdleStateHandler 是实现心跳的关键, 它会根据不同的 IO idle 类型来产生不同的 IdleStateEvent 事件,而这个事件的捕获, 其实就是在 <strong>userEventTriggered</strong> 方法中实现的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当出现空闲时间的触发器</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">           <span class="type">IdleState</span> <span class="variable">state</span> <span class="operator">=</span> ((IdleStateEvent) evt).state();</span><br><span class="line">           <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;发送心跳包 [&#123;&#125;]&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">               <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">               <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequest</span>();</span><br><span class="line">               rpcRequest.setHeartBeat(<span class="literal">true</span>);</span><br><span class="line">               channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当IdleStateHandler产生这样一个事件时，上述方法会创建一个RpcRequest对象，并将它的HearBeat属性置位true，并使用<code>channel.writeAndFlush（）</code>方法发送出去</p>
<p>在服务端，当接收到一个请求时，它会首先判断是否是心跳包，如果是心跳包就直接返回，如果不是，则调用对应的服务</p>
<h3 id="Netty-是如何保持长连接的"><a href="#Netty-是如何保持长连接的" class="headerlink" title="Netty 是如何保持长连接的"></a><a href>Netty</a> 是如何保持长连接的</h3><p>首先 TCP 协议的实现中也提供了 <a href>keep</a>Alive 报文用来探测对端是否可用。TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。</p>
<p><code>ChannelOption.SO_KEEPALIVE, true</code> 表示打开 TCP 的 <a href>keep</a>Alive 设置。</p>
<p>TCP 心跳的问题：</p>
<p>考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态一直向当前服务器发送些必然会失败的请求。</p>
<p><a href>Netty</a> 中提供了 <code>IdleStateHandler</code> 类专门用于处理心跳。</p>
<p><code>IdleStateHandler</code> 的构造函数如下：</p>
<p><a href="#">复制代码</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">IdleStateHandler</span><span class="params">(<span class="type">long</span> readerIdleTime, <span class="type">long</span> writerIdleTime, </span></span><br><span class="line"><span class="params">                        <span class="type">long</span> allIdleTime,TimeUnit unit)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数是隔多久检查一下读事件是否发生，如果 <code>channelRead()</code> 方法超过 readerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p>
<p>第二个参数是隔多久检查一下写事件是否发生，writerIdleTime 写空闲超时时间设定，如果 <code>write()</code> 方法超过 writerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p>
<p>第三个参数是全能型参数，隔多久检查读写事件；</p>
<p>第四个参数表示当前的时间单位。</p>
<p>所以这里可以分别控制读，写，读写超时的时间，单位为秒，如果是0表示不检测，所以如果全是0，则相当于没添加这个 IdleStateHandler，连接是个普通的短连接。</p>
<h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/120814088">(229条消息) 一致性哈希算法原理详解_张维鹏的博客-CSDN博客_一致性哈希</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40378034/article/details/117870061">(229条消息) 一致性哈希算法详解_邋遢的流浪剑客的博客-CSDN博客_一致性哈希算法</a></p>
<p>是一种特殊的哈希算法，目的是解决分布式缓存的问题。 在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/5981869">哈希表</a>( Distributed Hash Table，DHT) 中存在的动态伸缩等问题 。</p>
<p>在分布式系统中应用非常广泛。一致性哈希是一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/4960188">哈希算法</a>，简单地说在移除或者添加一个服务器时，此算法能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系，尽可能满足单调性的要求。在普通分布式集群中，服务请求与处理请求服务器之间可以一一对应，也就是说固定服务请求与处理服务器之间的映射关系，某个请求由固定的服务器去处理。这种方式无法对整个系统进行负载均衡，可能会造成某些服务器过于繁忙以至于无法处理新来的请求。而另一些服务器则过于空闲，整体系统的资源利用率低，并且当分布式集群中的某个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>宕机，会直接导致某些服务请求无法处理 。</p>
<p>一致性哈希算法将整个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%80%BC/5896926">哈希值</a>空间映射成一个虚拟的圆环，整个哈希空间的取值范围为0<del>232-1。整个空间按顺时针方向组织。0</del>232-1在零点中方向重合。接下来使用如下算法对服务请求进行映射，将服务请求使用哈希算法算出对应的hash值，然后根据hash值的位置沿圆环顺时针查找，第一台遇到的服务器就是所对应的处理请求服务器。当增加一台新的服务器，受影响的数据仅仅是新添加的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性</p>
<p>一致性哈希算法是在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/4960188">哈希算法</a>基础上提出的，在动态变化的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232">分布式</a>环境中，哈希算法应该满足的几个条件:平衡性、单调性和分散性 </p>
<ol>
<li><p>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p>
</li>
<li><p>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</p>
</li>
<li><p>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p>
</li>
</ol>
<h3 id="数据倾斜问题"><a href="#数据倾斜问题" class="headerlink" title="数据倾斜问题"></a>数据倾斜问题</h3><p>在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成数据倾斜（被缓存的对象大部分缓存在某一台服务器上）问题，如图特例</p>
<img src="https://img-blog.csdnimg.cn/3bcc11c6a1ba4b619e41eb2ec056ff88.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWF4d2VsbC1tYQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom: 67%;">

<p>这时我们发现有大量数据集中在节点A上，而节点B只有少量数据。在极端情况下，假如A节点出现故障，存储在A上的数据要全部转移到B上，大量的数据导可能会导致节点B的崩溃，之后A和B上所有的数据向节点C迁移，导致节点C也崩溃，由此导致整个集群宕机。这种情况被称为<strong>雪崩效应</strong>。为了解决数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体操作可以为服务器IP或主机名后加入编号来实现数据定位算法不变，只需要增加一步：虚拟节点到实际点的映射。所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p>
<h2 id="服务之间的调用为啥不直接用-HTTP-而用-RPC？"><a href="#服务之间的调用为啥不直接用-HTTP-而用-RPC？" class="headerlink" title="服务之间的调用为啥不直接用 HTTP 而用 RPC？"></a>服务之间的调用为啥不直接用 HTTP 而用 RPC？</h2><p>RPC 只是一种概念、一种设计，就是为了解决 <strong>不同服务之间的调用问题</strong>, 它一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。但是，HTTP 是一种协议，RPC框架可以使用 HTTP协议作为传输协议或者直接使用TCP作为传输协议，使用不同的协议一般也是为了适应不同的场景。</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 <strong>IP 地址和端口</strong> 。这个找到服务对应的 IP 端口的过程，其实就是 <strong>服务发现</strong>。</p>
<p>在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong> 去解析得到它背后的 IP 地址，默认 <strong>80 端口</strong>。</p>
<p>而 <strong>RPC</strong> 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 <strong>Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 <strong>CoreDNS</strong>。</p>
<p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p>
<h3 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h3><p>以主流的 <strong>HTTP1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p>
<p>而 <strong>RPC</strong> 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 <strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/72fcad064c9e4103a11f1a2d579f79b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="connection_pool"></p>
<p>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。</p>
<p>可以看出这一块两者也没太大区别，所以也不是关键。</p>
<h3 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h3><p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p>
<p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p>
<p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p>
<p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/d501dfc6f764430188ce61fda0f3e5d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="序列化和反序列化"></p>
<p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p>
<p>我们可以随便截个图直观看下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/04e8a79ddb7247759df23f1132c01655~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="HTTP报文"></p>
<p>可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 <code>Content-Type</code>，就不需要每次都真的把 <code>Content-Type</code> 这个字段都传过来，类似的情况其实在 Body 的 JSON 结构里也特别明显。</p>
<p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/284c26bb7f2848889d1d9b95cf49decb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="HTTP原理"></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/edb050d383c644e895e505253f1c4d90~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="RPC原理"></p>
<p>当然上面说的 HTTP，其实 <strong>特指的是现在主流使用的 HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以 <strong>性能可能比很多 RPC 协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息， RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></li>
</ul>
<ul>
<li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 <strong>消息边界</strong> 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li>
<li>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。</strong> 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li>
<li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li>
<li><strong>HTTP2.0</strong> 在 <strong>HTTP1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rtlin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mumu-lsl.github.io/posts/865846/">https://mumu-lsl.github.io/posts/865846/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mumu-lsl.github.io" target="_blank">Lin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/04/sog2J4pY6hmNDFq.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/b543ced0/"><img class="prev-cover" src="https://s2.loli.net/2022/11/04/LJg62o37TxV1MPI.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ</div></div></a></div><div class="next-post pull-right"><a href="/posts/2c3345f0/"><img class="next-cover" src="https://s2.loli.net/2022/11/04/QZiRYA5t3VGMwKe.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/5cf1c465/" title="分布式系统概述"><img class="cover" src="https://s2.loli.net/2022/11/04/IY3VqXhfAMZxUjy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-04</div><div class="title">分布式系统概述</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">rtlin</div><div class="author-info__description">Lin在此创作, 欢迎各位</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mumu-LSL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/zumumu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-RPC-%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是 RPC ？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BIO%E4%B8%8ENIO"><span class="toc-number">3.</span> <span class="toc-text">BIO与NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO"><span class="toc-number">3.1.</span> <span class="toc-text">BIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO"><span class="toc-number">3.2.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B8%8EBIO%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.3.</span> <span class="toc-text">NIO与BIO的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%9E%8B%E5%92%8CProactor%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">Reactor模型和Proactor模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reactor"><span class="toc-number">3.4.1.</span> <span class="toc-text">Reactor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proactor"><span class="toc-number">3.4.2.</span> <span class="toc-text">Proactor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%9A%BE%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">两个项目的难点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC%E9%A1%B9%E7%9B%AE"><span class="toc-number">5.</span> <span class="toc-text">RPC项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%88%9D%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.</span> <span class="toc-text">最初的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rpc-core"><span class="toc-number">5.2.</span> <span class="toc-text">rpc-core</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%B1%BB"><span class="toc-number">5.2.1.</span> <span class="toc-text">注解类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">编解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServer%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">5.2.3.</span> <span class="toc-text">NettyServer的实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyClient-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.4.</span> <span class="toc-text">NettyClient 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServerHandler-%E5%92%8C-NettyClientHandler"><span class="toc-number">5.2.5.</span> <span class="toc-text">NettyServerHandler 和 NettyClientHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kryo%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.6.</span> <span class="toc-text">kryo序列化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="toc-number">5.2.7.</span> <span class="toc-text">几种序列化方式的优劣</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Nacos%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="toc-number">5.2.8.</span> <span class="toc-text">使用Nacos作为服务器注册与发现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.</span> <span class="toc-text">几种注册中心的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">6.0.1.</span> <span class="toc-text">自动注销服务和负载均衡策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">自动注销服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">负载均衡策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rpc-client-rpc-server"><span class="toc-number">6.1.</span> <span class="toc-text">rpc-client,rpc-server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">RPC调用过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#netty"><span class="toc-number">6.3.</span> <span class="toc-text">netty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Netty-%E6%80%A7%E8%83%BD%E9%AB%98"><span class="toc-number">6.3.1.</span> <span class="toc-text">为什么 Netty 性能高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B-Netty-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.3.2.</span> <span class="toc-text">说下 Netty 零拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty-%E4%B8%AD%E8%B4%A3%E4%BB%BB%E9%93%BE"><span class="toc-number">6.3.3.</span> <span class="toc-text">Netty 中责任链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B-Netty-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="toc-number">6.3.4.</span> <span class="toc-text">简单说下 Netty 中的重要组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netty%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.5.</span> <span class="toc-text">netty粘包和拆包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E9%95%BF%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.3.5.1.</span> <span class="toc-text">1. 定长协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.3.5.2.</span> <span class="toc-text">2. 特殊字符分割协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%98%E9%95%BF%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.3.5.3.</span> <span class="toc-text">3. 变长协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-TCP-%E7%9A%84%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.6.</span> <span class="toc-text">如何解决 TCP 的粘包拆包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netty%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">6.3.7.</span> <span class="toc-text">netty心跳机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9A%84"><span class="toc-number">6.3.8.</span> <span class="toc-text">Netty 是如何保持长连接的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">一致性哈希算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E9%97%AE%E9%A2%98"><span class="toc-number">6.4.1.</span> <span class="toc-text">数据倾斜问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8-HTTP-%E8%80%8C%E7%94%A8-RPC%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">服务之间的调用为啥不直接用 HTTP 而用 RPC？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">6.5.1.</span> <span class="toc-text">服务发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E8%BF%9E%E6%8E%A5%E5%BD%A2%E5%BC%8F"><span class="toc-number">6.5.2.</span> <span class="toc-text">底层连接形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">6.5.3.</span> <span class="toc-text">传输的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/f5f9fa9b/" title="Docker"><img src="https://s2.loli.net/2023/04/25/69ToCr37aHQSzAh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/posts/f5f9fa9b/" title="Docker">Docker</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/47b6ee30/" title="Cypher"><img src="https://s2.loli.net/2023/04/25/Ml2GwJrQNCthEmn.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cypher"/></a><div class="content"><a class="title" href="/posts/47b6ee30/" title="Cypher">Cypher</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c5146ddf/" title="Hanlp Tutorial"><img src="https://s2.loli.net/2023/04/25/JgKmxMGZ9tPrU3d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hanlp Tutorial"/></a><div class="content"><a class="title" href="/posts/c5146ddf/" title="Hanlp Tutorial">Hanlp Tutorial</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2d771287/" title="Kubernetes学习"><img src="https://s2.loli.net/2023/04/25/xdrsWiIHuPN8clT.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kubernetes学习"/></a><div class="content"><a class="title" href="/posts/2d771287/" title="Kubernetes学习">Kubernetes学习</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/da599ed4/" title="NLP概述"><img src="https://s2.loli.net/2023/04/25/Ml2GwJrQNCthEmn.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NLP概述"/></a><div class="content"><a class="title" href="/posts/da599ed4/" title="NLP概述">NLP概述</a><time datetime="2023-04-25T14:47:30.000Z" title="发表于 2023-04-25 22:47:30">2023-04-25</time></div></div></div></div></div></div></main><footer id="footer" style="background: -rgb(0,0,255)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By rtlin</div><div class="footer_custom_text">所有你乐于挥霍的时间，都不能算作浪费</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="null" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>