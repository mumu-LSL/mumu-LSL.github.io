<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>项目 | Lin's Blog</title><meta name="keywords" content="项目"><meta name="author" content="木木想去北海种花"><meta name="copyright" content="木木想去北海种花"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="自我介绍面试官您好，我是来自成都理工大学计算机与网络安全学院2023届毕业生罗世霖。主修专业为计算机科学与技术专业，在大学三年计算机相关的课程的学习中，系统的掌握了本专业所开设的各类课程，如计算机组成原理，操作系统，数据结构与算法，计算机网络，数据库，C++，Java程序设计等课程。在校期间，我也积极的自学和探索计算机的各个方面的技术，在此过程中学习了Linux操作系统，JavaEE，各种中间件，">
<meta property="og:type" content="article">
<meta property="og:title" content="项目">
<meta property="og:url" content="https://mumu-lsl.github.io/posts/a2c247c4/index.html">
<meta property="og:site_name" content="Lin&#39;s Blog">
<meta property="og:description" content="自我介绍面试官您好，我是来自成都理工大学计算机与网络安全学院2023届毕业生罗世霖。主修专业为计算机科学与技术专业，在大学三年计算机相关的课程的学习中，系统的掌握了本专业所开设的各类课程，如计算机组成原理，操作系统，数据结构与算法，计算机网络，数据库，C++，Java程序设计等课程。在校期间，我也积极的自学和探索计算机的各个方面的技术，在此过程中学习了Linux操作系统，JavaEE，各种中间件，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg">
<meta property="article:published_time" content="2022-09-17T06:29:58.000Z">
<meta property="article:modified_time" content="2022-09-17T06:31:05.070Z">
<meta property="article:author" content="木木想去北海种花">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mumu-lsl.github.io/posts/a2c247c4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '项目',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-17 14:31:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lin's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">项目</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-17T06:29:58.000Z" title="发表于 2022-09-17 14:29:58">2022-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-17T06:31:05.070Z" title="更新于 2022-09-17 14:31:05">2022-09-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="项目"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>面试官您好，我是来自成都理工大学计算机与网络安全学院2023届毕业生罗世霖。主修专业为计算机科学与技术专业，在大学三年计算机相关的课程的学习中，系统的掌握了本专业所开设的各类课程，如计算机组成原理，操作系统，数据结构与算法，计算机网络，数据库，C++，Java程序设计等课程。在校期间，我也<strong>积极的自学和探索计算机的各个方面的技术</strong>，在此过程中学习了Linux操作系统，JavaEE，各种中间件，NoSQL，爬虫，高性能服务器设计。在校期间，我<strong>对于Java后台开发等非常感兴趣</strong>。在实践过程中我做了一个RPC框架，一个Spark论坛社区，参考游双的书写过一个WebServer。大二的时候和身边的同学一起做过一个人事管理系统，在大三期间与同学一起做过一个数字图像相关的图像融合的项目，在此期间都担任组长。在校期间，<strong>课余方面</strong>也积极参加社团活动，参与过活动策划和组织工作，并且担任老师的助教，帮助老师写文章，运维公众号。在此过程中也广泛的扩展了自己的兴趣。最后，我在贵司投递的岗位是Java开发，这也是我的兴趣所在，我力争将自己的兴趣于自己的工作相融合，做好自己的本职工作。最后我期待能在贵公司发挥自己的特长和专业，谢谢！</p>
<h1 id="什么是-RPC-？"><a href="#什么是-RPC-？" class="headerlink" title="什么是 RPC ？"></a>什么是 RPC ？</h1><p><img src="https://uploadfiles.nowcoder.com/files/20220607/3639882_1654583266812/4e7dfea3-6814-497f-a0db-31b59f0f3c10.png" alt="img"></p>
<p>RPC (Remote Procedure Call)即<strong>远程过程调用</strong>，是分布式系统常见的一种通信方法。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。</p>
<ul>
<li>RPC就是从一台机器（客户端）上<strong>通过参数传递的方式调用</strong>另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</li>
<li>RPC会<strong>隐藏底层的通讯细节</strong>（不需要直接处理Socket通讯或Http通讯）。</li>
<li>客户端发起请求，服务器返回响应（类似于Http的工作方式）RPC在<strong>使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）</strong>。</li>
</ul>
<p><strong>最终解决的问题：让分布式或者微服务系统中不同服务之间的调用（远程调用）像本地调用一样简单！</strong>调用者感知不到远程调用的逻辑。为此rpc需要解决三个问题（实现的关键）：</p>
<ul>
<li><strong>Call ID映射</strong>。我们怎么告诉远程机器（注册中心）我们要<strong>调用哪个函数呢</strong>？</li>
<li><strong>序列化和反序列化</strong>。客户端<strong>怎么把参数值传给远程的函数呢？</strong></li>
<li><strong>数据网络传输</strong>。远程调用往往是基于网络的，客户端和服务端是通过网络连接的。<strong>所有的数据都需要通过网络传输，因此就需要有一个网络传输层。</strong></li>
</ul>
<p>一个RPC框架要包含</p>
<ul>
<li>客户端和服务端建立网络连接模块( <strong>server</strong>模块、<strong>client</strong>模块 )</li>
<li>服务端<strong>处理请求模块</strong></li>
<li><strong>协议</strong>模块</li>
<li><strong>序列化</strong>和<strong>反序列</strong>模块。</li>
</ul>
<img src="https://upload-images.jianshu.io/upload_images/23383522-f5ebdd4af38ca892.png?imageMogr2/auto-orient/strip|imageView2/2/w/1132/format/webp" alt="img" style="zoom:67%;"> 

<p><strong>一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub可以理解为存根（调用与返回）</strong>。分别说说这几个组件：</p>
<ul>
<li>客户端（Client）： 服务的调用方。</li>
<li>服务端（Server）：真正的服务提供者。</li>
<li>客户端存根：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li>
<li>服务端存根：接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li>
</ul>
<img src="https://s2.loli.net/2022/05/12/pdEfnNuIwT6rJkK.png" alt="img" style="zoom: 80%;"> 

<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>代理模式是一种设计模式，能够使得在不修改源目标的前提下，额外扩展源目标的功能。即通过访问源目标的代理类，再由代理类去访问源目标。这样一来，要扩展功能，就无需修改源目标的代码了。只需要在代理类上增加就可以了。</p>
<p>其实代理模式的核心思想就是这么简单，在java中，代理又分静态代理和动态代理2种，其中动态代理根据不同实现又区分基于接口的的动态代理和基于子类的动态代理。</p>
<p>静态代理这种模式虽然好理解，但是缺点也很明显：</p>
<ul>
<li>会存在大量的冗余的代理类，这里演示了2个接口，如果有10个接口，就必须定义10个代理类。</li>
<li>不易维护，一旦接口更改，代理类和目标类都需要更改。</li>
</ul>
<p><strong>Jdk中的动态代理</strong></p>
<p>JDK中的动态代理是通过反射类Proxy以及InvocationHandler回调接口实现的，但是JDK中所有要进行动态代理的类必须要实现一个接口，也就是说只能对该类所实现接口中定义的方法进行代理，这在实际编程中有一定的局限性，而且使用反射的效率也不高</p>
<p><strong>Cglib实现</strong></p>
<p>使用cglib是实现动态代理，不受代理类必须实现接口的限制，因为cglib底层是用ASM框架，利用ASM框架，对代理对象类生成的class文件加载进来，通过修改其字节码生成子类来处理。比使用Java反射的效率要高，cglib不能对声明final的方法进行代理，因为cglib原理是动态生成被代理类的子类</p>
<p><strong>什么时候用cglib什么时候用jdk动态代理？</strong></p>
<p>1、目标对象生成了接口 默认用JDK动态代理</p>
<p>2、如果目标对象使用了接口，可以强制使用cglib</p>
<p>3、如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代理和cglib之间转换</p>
<p><strong>JDK动态代理和cglib字节码生成的区别？</strong></p>
<ul>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>Cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法的增强，但是因为采用的是继承，所以该类或方法最好不要生成final，对于final类或方法，是无法继承的</li>
</ul>
<p> <strong>Cglib比JDK快？</strong></p>
<ul>
<li>cglib底层是ASM字节码生成框架，但是字节码技术生成代理类，在JDL1.6之前比使用java反射的效率要高</li>
<li>在jdk6之后逐步对JDK动态代理进行了优化，在调用次数比较少时效率高于cglib代理效率</li>
<li>只有在大量调用的时候cglib的效率高，但是在1.8的时候JDK的效率已高于cglib</li>
<li>Cglib不能对声明final的方法进行代理，因为cglib是动态生成代理对象，final关键字修饰的类不可变只能被引用不能被修改</li>
</ul>
<p><strong>Spring如何选择是用JDK还是cglib？</strong></p>
<ul>
<li>当bean实现接口时，会用JDK代理模式</li>
<li>当bean没有实现接口，用cglib实现</li>
<li>可以强制使用cglib（在spring配置中加入&lt;aop:aspectj-autoproxy proxyt-target-class&#x3D;”true”&#x2F;&gt;）</li>
</ul>
<p>还有： 在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理。</p>
<p>动态代理，通俗点说就是：无需声明式的创建java代理类，而是在运行过程中生成”虚拟”的代理类，被ClassLoader加载。从而避免了静态代理那样需要声明大量的代理类。JDK从1.3版本就开始支持动态代理类的创建。主要核心类只有2个：<code>java.lang.reflect.Proxy</code>和<code>java.lang.reflect.InvocationHandler</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*处理代理实例上的方法并返回实例并返回结果,我们一般在此方法中添加一些额外的逻辑</span></span><br><span class="line"><span class="comment">* @param   proxy:   the proxy instance that the method was invoked on</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @param   method the &#123;@code Method&#125; instance corresponding to</span></span><br><span class="line"><span class="comment">* the interface method invoked on the proxy instance.  The declaring</span></span><br><span class="line"><span class="comment">* class of the &#123;@code Method&#125; object will be the interface that</span></span><br><span class="line"><span class="comment">* the method was declared in, which may be a superinterface of the</span></span><br><span class="line"><span class="comment">* proxy interface that the proxy class inherits the method through.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @param   args an array of objects containing the values of the</span></span><br><span class="line"><span class="comment">* arguments passed in the method invocation on the proxy instance,</span></span><br><span class="line"><span class="comment">* or &#123;@code null&#125; if interface method takes no arguments.</span></span><br><span class="line"><span class="comment">* Arguments of primitive types are wrapped in instances of the</span></span><br><span class="line"><span class="comment">* appropriate primitive wrapper class, such as</span></span><br><span class="line"><span class="comment">* &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*   @param  loader:   the class loader to define the proxy class</span></span><br><span class="line"><span class="comment">*    @param  interfaces:  the list of interfaces for the proxy class  to implement</span></span><br><span class="line"><span class="comment">*    @param  h :  the invocation handler to dispatch method invocations to</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span> </span><br><span class="line">    </span><br><span class="line"><span class="comment">//一般步骤为先new一个被代理对象，再生成调用处理器，最后得到代理对象的实例</span></span><br><span class="line"><span class="comment">//invoke()这个方法的第一个参数proxy可以用于返回，实现连续调用的效果	</span></span><br></pre></td></tr></table></figure>

<p>JDK的动态代理使用的最多的一种代理方式。也叫做接口代理。</p>
<p>JDK动态代理说白了只是根据接口”凭空“来生成类，至于具体的执行，都被代理到了<code>InvocationHandler</code> 的实现类里。上述例子我是需要继续执行原有bean的逻辑，才将原有的bean构造进来。只要你需要，你可以构造进任何对象到这个代理实现类。也就是说，你可以传入多个对象，或者说你什么类都不代理。只是为某一个接口”凭空“的生成多个代理实例，这多个代理实例最终都会进入<code>InvocationHandler</code>的实现类来执行某一个段共同的代码。</p>
<p>基于接口的代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JDKProxy</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">//处理代理实例上的方法并返回实例并返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke执行&quot;</span>);</span><br><span class="line">        String s=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JDKProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDKProxy</span>();</span><br><span class="line">        Person personProxy=(Person)Proxy.newProxyInstance(Person.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Person.class&#125;, proxy);</span><br><span class="line">        personProxy.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="BIO与NIO"><a href="#BIO与NIO" class="headerlink" title="BIO与NIO"></a>BIO与NIO</h1><p>参考： <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/769587#slide-12">https://developer.aliyun.com/article/769587#slide-12</a></p>
<ul>
<li>BIO 适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。</li>
<li>NIO 适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比 BIO，相对来说编程比较复杂。</li>
<li>AIO 适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及 I&#x2F;O 操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。</li>
</ul>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO是传统的Java IO编程，其基本的类和接口在java.io包中<br>BIO(blocking I&#x2F;O)：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销<br>BIO方式使用于连接数目比较小且固定的架构，这种服务方式对服务器资源要求比价高，并且局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</p>
<p><img src="https://img2020.cnblogs.com/blog/1563713/202011/1563713-20201105205737333-798691609.png" alt="img"></p>
<p>可以看出BIO编程的两个问题：</p>
<ol>
<li>服务器端在监听客户端连接时(serverSocket.accept())，服务器端处于阻塞状态，不能处理其他事务</li>
<li>服务器端需要为每个客户端建立一个线程，虽然可以用线程池来优化，但在并发较大时，线程开销依旧很大</li>
<li>当连接的客户端没有发送数据时，服务器端会阻塞在read操作上，等待客户端输入，造成线程资源浪费</li>
</ol>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>从JDK1.4开始，java提供了一系列改进输入&#x2F;输出的新特性，统称为<strong>NIO</strong>，全称n为<strong>new I&#x2F;O</strong>，是同步非阻塞的，所以也有人称为<strong>non-blocking I&#x2F;O</strong>。NIO的相关类都放在java.nio包或其子包下，并对原先java.io包中许多类进行了改写。</p>
<p><img src="https://img2020.cnblogs.com/blog/1563713/202011/1563713-20201105205852291-1646956541.png" alt="img"></p>
<p><strong>NIO的三大核心</strong></p>
<ol>
<li><strong>缓冲区(Buffer)</strong></li>
</ol>
<p>NIO是面向缓冲区, 或者说是面向块编程的。在NIO的IO传输中，数据会先读入到缓冲区，当需要时再从缓冲区写出，这样减少了直接读写磁盘的次数，提高了IO传输的效率。</p>
<p>缓冲区(buffer)本质上是一个可以读写数据的内存块，即在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入和输出的数据，这部分预留的存储空间就叫缓冲区。在NIO程序中，通道channel虽然负责数据的传输，但是输入和输出的数据都必须经过缓冲区buffer。</p>
<p>Buffer的常用子类（它们之间最大区别在于底层实现数组的数据类型）：</p>
<ul>
<li>ByteBuffer：存储字节数据到缓冲区</li>
<li>CharBuffer：存储字符数据到缓冲区</li>
<li>IntBuffer：存储整型数据到缓冲区</li>
<li>ShortBuffer：存储短整型数据到缓冲区</li>
<li>LongBuffer：存储长整型数据到缓冲区</li>
<li>FloatBuffer：存储浮点型数据到缓冲区</li>
<li>DoubleBuffer：存储双精度浮点型数据到缓冲区</li>
</ul>
<ol start="2">
<li><strong>通道(Channel)</strong></li>
</ol>
<p>在NIO程序中服务器端和客户端之间的数据读写不是通过流，而是通过通道来读写的。</p>
<p>通道类似于流，都是用来读写数据的，但它们之间也是有区别的：</p>
<ul>
<li>通道是双向的，即可以读也可以写，而流是单向的，只能读或写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲区读数据，也可以把数据写入缓冲区</li>
</ul>
<p>java中channel的相关类在java.nio.channel包下。Channel是一个接口，其常用的实现类有：</p>
<ul>
<li>FileChannel：用于文件的数据读写，其真正的实现类为FileChannelImpl</li>
<li>DatagramChannel：用于UDP的数据读写，其真正的实现类为DatagramChannelImpl</li>
<li>ServerSocketChannel：用于监听TCP连接，每当有客户端连接时都会创建一个SocketChannel，功能类似ServerSocket，其真正的实现类为ServerSocketChannelImpl</li>
<li>SocketChannel：用于TCP的数据读写，功能类似节点流+Socket，其真正的实现类为SocketChannelImpl</li>
</ul>
<ol start="3">
<li><strong>选择器(Selector)</strong></li>
</ol>
<p>在NIO程序中，可以用选择器Selector实现<strong>一个选择器处理多个通道，即一个线程处理多个连接</strong>。只要把通道注册到Selector上，就可以通过Selector来监测通道，如果通道有事件发生，便获取事件然后针对每个事件进行相应的处理。这样，只有在通道(连接)有真正的读&#x2F;写事件发生时，才会进行读写操作，大大减少了系统开销，并且不必为每个连接创建单独线程，就不用去维护过多的线程。</p>
<p>如果用阻塞I&#x2F;O，需要多线程（浪费内存），如果用非阻塞I&#x2F;O，需要不断重试（耗费CPU）。Selector的出现解决了这尴尬的问题，非阻塞模式下，通过Selector，我们的线程只为已就绪的通道工作，不用盲目的重试了。比如，当所有通道都没有数据到达时，也就没有Read事件发生，我们的线程会在select()方法处被挂起，从而让出了CPU资源。</p>
<p>选择器的相关类在java.nio.channels包和其子包下，顶层类是Selector，它是一个抽象类，它的常用方法有：</p>
<p><img src="https://s2.loli.net/2022/05/14/CEvQMDTjLr4F3ho.png" alt="图片"> </p>
<p>NIO服务器端如何实现非阻塞？</p>
<p>服务器上所有Channel需要向Selector注册，而Selector则负责监视这些Socket的IO状态(观察者)，当其中任意一个或者多个Channel具有可用的IO操作时，该Selector的select()方法将会返回大于0的整数，该整数值就表示该Selector上有多少个Channel具有可用的IO操作，并提供了selectedKeys（）方法来返回这些Channel对应的SelectionKey集合(一个SelectionKey对应一个就绪的通道)。正是通过Selector，使得服务器端只需要不断地调用Selector实例的select()方法即可知道当前所有Channel是否有需要处理的IO操作。注：java NIO就是多路复用IO，jdk7之后底层是epoll模型。</p>
<h2 id="NIO与BIO的对比"><a href="#NIO与BIO的对比" class="headerlink" title="NIO与BIO的对比"></a>NIO与BIO的对比</h2><p>Linux IO模式 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003063859">https://segmentfault.com/a/1190000003063859</a></p>
<p>阻塞式IO</p>
<p><img src="https://pic1.zhimg.com/v2-7f73fdcaca316aa0f12d77b6873785e5_r.jpg?source=1940ef5c" alt="preview"></p>
<p>非阻塞IO</p>
<p><img src="https://pic1.zhimg.com/v2-51e052e2beecef41da3aed3ebc2b80bd_r.jpg?source=1940ef5c" alt="preview"></p>
<p>异步IO</p>
<p><img src="https://pica.zhimg.com/80/v2-b01988dd44a5edbe596a280d1c266033_1440w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="Reactor模型和Proactor模型"><a href="#Reactor模型和Proactor模型" class="headerlink" title="Reactor模型和Proactor模型"></a>Reactor模型和Proactor模型</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)</a></p>
<h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>常见的 Reactor 实现方案有三种。</p>
<ul>
<li><p>第一种方案单 Reactor 单进程 &#x2F; 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于CPU密集型的场景，适用于业务处理快速的场景，比如 Redis 采用的是单 Reactor 单进程的方案。</p>
</li>
<li><p>第二种方案单 Reactor 多线程，通过多线程的方式解决了方案一的缺陷，但它离高并发还差一点距离，差在只有一个 Reactor 对象来承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。</p>
</li>
<li><p>第三种方案多 Reactor 多进程 &#x2F; 线程，通过多个 Reactor 来解决了方案二的缺陷，主 Reactor 只负责监听事件，响应事件的工作交给了从 Reactor，Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案，Nginx 则采用了类似于 「多 Reactor 多进程」的方案。</p>
<img src="https://picx.zhimg.com/80/v2-4da008d8b7f55a0c18bef0e87c5c5bb1_1440w.jpg?source=1940ef5c" alt="img" style="zoom: 50%;"></li>
</ul>
<h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p>前面提到的 Reactor 是非阻塞同步网络模式，而 <strong>Proactor 是异步网络模式</strong>。真正的<strong>异步 I&#x2F;O</strong> 是「内核数据准备好」和「数据从内核态拷贝到<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%A8%E6%88%B7%E6%80%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1856426252%7D">用户态</a>」这<strong>两个过程都不用等待</strong>。</p>
<p><img src="https://picx.zhimg.com/80/v2-35bd4bdf3b12246fb005415d3a29ecc0_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」。</p>
<p>现在我们再来理解 Reactor 和 Proactor 的区别，</p>
<ul>
<li><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li>
<li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li>
</ul>
<p>不过，无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 Reactor 模式是基于「待完成」的 I&#x2F;O 事件，而 Proactor 模式则是基于「已完成」的 I&#x2F;O 事件。</p>
<h1 id="两个项目的难点"><a href="#两个项目的难点" class="headerlink" title="两个项目的难点"></a>两个项目的难点</h1><h1 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h1><h2 id="最初的实现"><a href="#最初的实现" class="headerlink" title="最初的实现"></a>最初的实现</h2><p>定义接口: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServiceRegistry</span> &#123;  </span><br><span class="line">    &lt;T&gt; <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(T service)</span>;</span><br><span class="line">    Object <span class="title function_">getService</span><span class="params">(String serviceName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用DefaultServiceRegistry 来实现这个接口，并提供服务。这里的重点是使用<code>ConcurrentHashMap</code> 来保存服务名与提供服务的对象的对应关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(T service)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> service.getClass().getCanonicalName(); <span class="comment">//获取服务的全类名</span></span><br><span class="line">        <span class="keyword">if</span>(registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(interfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.SERVICE_NOT_IMPLEMENT_ANY_INTERFACE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; i : interfaces) &#123;</span><br><span class="line">            serviceMap.put(i.getCanonicalName(), service);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;</span>, interfaces, serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">getService</span><span class="params">(String serviceName)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">service</span> <span class="operator">=</span> serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span>(service == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个请求处理线程要执行的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line">             <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream())) &#123;</span><br><span class="line">            <span class="comment">//获取请求对象</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> (RpcRequest) objectInputStream.readObject();</span><br><span class="line">            <span class="comment">//获取需要的服务名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">interfaceName</span> <span class="operator">=</span> rpcRequest.getInterfaceName();</span><br><span class="line">            <span class="comment">//获取服务</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">service</span> <span class="operator">=</span> serviceRegistry.getService(interfaceName);</span><br><span class="line">            <span class="comment">//使用动态代理来执行服务，并获取结果</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> requestHandler.handle(rpcRequest, service);</span><br><span class="line">           </span><br><span class="line">       		<span class="comment">//将结果写回并刷新缓冲区</span></span><br><span class="line">            objectOutputStream.writeObject(RpcResponse.success(result));</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="rpc-core"><a href="#rpc-core" class="headerlink" title="rpc-core"></a>rpc-core</h2><h3 id="注解类"><a href="#注解类" class="headerlink" title="注解类"></a>注解类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 个 Annotation 和 <span class="number">1</span>~n 个 ElementType 关联。ElementType.TYPE</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 个 Annotation 和 <span class="number">1</span> 个 RetentionPolicy 关联。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个服务提供类，用于远程接口的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ziyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Target</span>(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。</span></span><br><span class="line"><span class="comment"> * 这就意味着，MyAnnotation1 是来修饰&quot;类、接口（包括注释类型）或枚举声明&quot;的注解。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个注解将在服务器端启动时，将我们用注解标注过的服务自动注册。具体的逻辑就是：</p>
<p>我们使用ReflectUtil.getStackTrace() 这个方法获取主类名以及具体的路径，并获取启动类的类对象。这个类对象中包含了标注的注解信息，其中就有ServiceScan注解，然后通过ServiceScan注解的value属性 获取服务所在的基包。最后我们扫描这个基包拥有的所有类（即服务），并获取它们的类对象以及实例对象，最后将其注册到注册中心去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scanServices</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">mainClassName</span> <span class="operator">=</span> ReflectUtil.getStackTrace();</span><br><span class="line">      Class&lt;?&gt; startClass;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          startClass = Class.forName(mainClassName);</span><br><span class="line">          <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan.class)) &#123;</span><br><span class="line">              logger.error(<span class="string">&quot;启动类缺少 @ServiceScan 注解&quot;</span>);</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          logger.error(<span class="string">&quot;出现未知错误&quot;</span>);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.UNKNOWN_ERROR);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> startClass.getAnnotation(ServiceScan.class).value();</span><br><span class="line">      <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(basePackage)) &#123;</span><br><span class="line">          basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          basePackage = mainClassName.substring(<span class="number">0</span>,mainClassName.lastIndexOf(<span class="string">&quot;.&quot;</span>))+<span class="string">&quot;.&quot;</span>+basePackage;</span><br><span class="line">      &#125;</span><br><span class="line">      Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">      <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">          <span class="keyword">if</span>(clazz.isAnnotationPresent(Service.class)) &#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> clazz.getAnnotation(Service.class).name();</span><br><span class="line">              Object obj;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  obj = clazz.newInstance();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                  logger.error(<span class="string">&quot;创建 &quot;</span> + clazz + <span class="string">&quot; 时有错误发生&quot;</span>);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(serviceName)) &#123;</span><br><span class="line">                  Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                  <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                      publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  publishService(obj, serviceName);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>在传输过程中，我们可以在发送的数据上加上各种必要的数据，形成自定义的协议，而自动加上这个数据就是编码器的工作，解析数据获得原始数据就是解码器的工作。编解码器都继承了netty的编解码器的类</p>
<p>+—————+—————+—————–+————-+<br>|  Magic Number |  Package Type | Serializer Type | Data Length |<br>|    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |<br>+—————+—————+—————–+————-+<br>|                          Data Bytes                                   |<br>|                   Length: ${Data Length}                      |<br>+—————————————————————+</p>
<p>Data Length 就是实际数据的长度，设置这个字段主要防止<strong>粘包</strong></p>
<p>编解码器的实现都非常简单，主要就是按照协议的格式来进行编码s和解码，其中会涉及到netty的知识以及序列化和反序列化的知识。</p>
<p>序列化和反序列化的实现方式需要我们自己去实现</p>
<p>一个简单的例子：使用Jkson工具实现Json方式的序列化和反序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerializer</span> <span class="keyword">implements</span> <span class="title class_">CommonSerializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(JsonSerializer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Overrid</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsBytes(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;序列化时有错误发生: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> objectMapper.readValue(bytes, clazz);</span><br><span class="line">            <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">                obj = handleRequest(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;反序列化时有错误发生: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里由于使用JSON序列化和反序列化Object数组，无法保证反序列化后仍然为原实例类型</span></span><br><span class="line"><span class="comment">        需要重新判断处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">handleRequest</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> (RpcRequest) obj;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rpcRequest.getParamTypes().length; i ++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = rpcRequest.getParamTypes()[i];</span><br><span class="line">            <span class="keyword">if</span>(!clazz.isAssignableFrom(rpcRequest.getParameters()[i].getClass())) &#123;</span><br><span class="line">                <span class="type">byte</span>[] bytes = objectMapper.writeValueAsBytes(rpcRequest.getParameters()[i]);</span><br><span class="line">                rpcRequest.getParameters()[i] = objectMapper.readValue(bytes, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">&quot;JSON&quot;</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化和反序列化都比较循规蹈矩，把对象翻译成字节数组，和根据字节数组和 Class 反序列化成对象。这里有一个需要注意的点，就是在 RpcRequest 反序列化时，由于其中有一个字段是 Object 数组，在反序列化时序列化器会根据字段类型进行反序列化，而 Object 就是一个十分模糊的类型，会出现反序列化失败的现象，这时就需要 RpcRequest 中的另一个字段 ParamTypes 来获取到 Object 数组中的每个实例的实际类，辅助反序列化，这就是 handleRequest() 方法的作用。</p>
<p>上面提到的这种情况不会在其他序列化方式中出现，因为其他序列化方式是转换成字节数组，会记录对象的信息，而 JSON 方式本质上只是转换成 JSON 字符串，会丢失对象的<strong>类型信息</strong>。</p>
<h3 id="NettyServer的实现："><a href="#NettyServer的实现：" class="headerlink" title="NettyServer的实现："></a>NettyServer的实现：</h3><p>NettyRpcServerHandler业务处理器<br>业务处理器处理三类事件：</p>
<ul>
<li>异常事件：直接关闭连接</li>
<li>心跳事件：客户端会每隔5s发送一次心跳ping，如果服务端持续30s没有收到心跳消息，说明连接可能已失效，则关闭连接</li>
<li>读事件：根据RpcMessage的属性确定接收到的消息类型：<ul>
<li>若是心跳ping，则返回心跳pong</li>
<li>若是RpcRequest，则调用服务方法，返回调用结果</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">256</span>)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">CommonEncoder</span>(<span class="keyword">new</span> <span class="title class_">JsonSerializer</span>()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">CommonDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;启动服务器时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="NettyClient-的实现"><a href="#NettyClient-的实现" class="headerlink" title="NettyClient 的实现"></a>NettyClient 的实现</h3><p>客户端主要实现服务调用请求的发送和请求结果的接收</p>
<p>客户端通过Bootstrap创建，在pipeline中添加IdleStateHandler心跳处理器，编码解码器，NettyRpcClientHandler业务处理器</p>
<p>1）发送服务调用请求<br>发送服务调用请求的步骤：</p>
<ol>
<li>根据服务名获取服务提供方的地址</li>
<li>根据地址创建与服务端的连接（连接利用一个Map进行存储，如果已经创建过了则复用该连接）</li>
<li>构建RpcMessage并通过该连接发送</li>
</ol>
<p>2）请求结果的接收<br>难点：通过上述方法异步发送RpcRequest后，RpcResponse只能在NettyRpcClientHandler中通过read方法接收，那么该如何获取请求结果呢</p>
<p>解决方案：通过CompletableFuture异步获取请求</p>
<p>步骤：</p>
<ol>
<li>为每个请求创建一个CompletableFuture<RpcResponse></RpcResponse></li>
<li>用一个ConcurrentHashMap保存已发送且未收到回复的请求（key为requestId，value为该请求的CompletableFuture<RpcResponse>）</RpcResponse></li>
<li>通过上述发送请求时，在该Map中存入该请求的CompletableFuture<RpcResponse>，且方法返回该Future<br>NettyRpcClientHandler收到服务器返回的调用结果后，从Map中移除该CompletableFuture<RpcResponse>，并为该Future设置好调用结果</RpcResponse></RpcResponse></li>
<li>这样调用方就可以通过CompletableFuture.get()获取到调用结果了（如果未设置结果则一直阻塞）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;RpcResponse&gt; <span class="title function_">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="literal">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//利用服务发现，在nacos注册中心找到可用的服务地址，并将请求发送到这个地址去请求服务。</span></span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span> (!channel.isActive()) &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">&quot;客户端发送消息: %s&quot;</span>, rpcRequest.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future1.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">                    logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, future1.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            unprocessedRequests.remove(rpcRequest.getRequestId());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>channel 将 RpcRequest 对象写出，并且等待服务端返回的结果。注意这里的发送是非阻塞的，所以发送后会立刻返回，而无法得到结果。这里通过 <code>AttributeKey</code> 的方式阻塞获得返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line"><span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> channel.attr(key).get();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这种方式获得全局可见的返回结果，在获得返回结果 RpcResponse 后，将这个对象以 key 为 rpcResponse 放入 ChannelHandlerContext 中，这里就可以立刻获得结果并返回，我们会在 <code>NettyClientHandler</code> 中看到放入的过程。</p>
<h3 id="NettyServerHandler-和-NettyClientHandler"><a href="#NettyServerHandler-和-NettyClientHandler" class="headerlink" title="NettyServerHandler 和 NettyClientHandler"></a>NettyServerHandler 和 NettyClientHandler</h3><p>NettyServerHandler 和 NettyClientHandler 都分别位于服务器端和客户端责任链的尾部，直接和 RpcServer 对象或 RpcClient 对象打交道，而无需关心字节序列的情况。</p>
<ul>
<li>NettyServerhandler 用于接收 RpcRequest，并且执行调用，将调用结果返回封装成 RpcResponse 发送出去。</li>
<li>NettyClientHandler用于接受响应包，并将响应包向上传递。</li>
</ul>
<h3 id="kryo序列化方法"><a href="#kryo序列化方法" class="headerlink" title="kryo序列化方法"></a>kryo序列化方法</h3><p>我们将kryo对象放在ThreadLocal对象中，一个线程一个kryo。</p>
<p>序列化时：先创建一个 Output 对象（Kryo 框架的概念），接着使用 writeObject 方法将对象写入 Output 中，最后调用 Output 对象的 toByte() 方法即可获得对象的字节数组</p>
<p>反序列化时：是从 Input 对象中直接 readObject，这里只需要传入对象的类型，而不需要具体传入每一个属性的类型信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">CommonSerializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(KryoSerializer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        kryo.setReferences(<span class="literal">true</span>);</span><br><span class="line">        kryo.setRegistrationRequired(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">             <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream))&#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;序列化时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;序列化时有错误发生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;反序列化时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;反序列化时有错误发生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">&quot;KRYO&quot;</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="几种序列化方式的优劣"><a href="#几种序列化方式的优劣" class="headerlink" title="几种序列化方式的优劣"></a>几种序列化方式的优劣</h3><p>实现了 JSON、Kryo、和 <a href>Proto</a>buf 的序列化。</p>
<p>JSON 是一种轻量级的<a href>数据</a>交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的<a href>数据</a>对象，类似 xml，Json 比 xml更小、更快更容易解析。JSON 由于采用字符方式存储，占用相对于字节方式较大，并且序列化后类的信息会丢失，可能导致反序列化失败。</p>
<p>剩下的都是基于字节的序列化。</p>
<p>Kryo 是一个快速高效的 Java 序列化框架，旨在提供快速、高效和易用的 API。无论文件、<a href>数据</a>库或网络<a href>数据</a> Kryo 都可以随时完成序列化。 <strong>Kryo 还可以执行自动深拷贝、浅拷贝</strong>。这是对象到对象的直接拷贝，而不是对象-&gt;字节-&gt;对象的拷贝。kryo 速度较快，序列化后体积较小，<strong>但是跨语言支持较复杂。</strong></p>
<p>protobuf（Protocol Buffers）是由 Google 发布的<a href>数据</a>交换格式，提供跨语言、跨平台的序列化和反序列化实现，底层由 C++ 实现，其他平台使用时必须使用 protocol compiler 进行预编译生成 protoc 二进制文件。性能主要消耗在文件的预编译上。序列化反序列化性能较高，平台无关。</p>
<p><strong>jdk 自带对象序列化类</strong></p>
<ul>
<li>1.无法跨语言。这应该是java序列化最致命的问题了。由于java序列化是java内部私有的协议，其他语言不支持，导致别的语言无法反序列化，这严重阻碍了它的应用。</li>
<li>2.序列后的码流太大，java序列化的大小是二进制编码的5倍多！</li>
<li>3.序列化性能太低。java序列化的性能只有二进制编码的6.17倍，可见java序列化性能实在太差了。</li>
</ul>
<p><strong>Thrift 方式</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>序列化和RPC支持一站式解决，比pb更方便 。</li>
<li>跨语言，IDL接口定义语言，自动生成多语言文件 。</li>
<li>省流量，体积较小 。</li>
<li>包含完整的客户端&#x2F;服务端堆栈，可快速实现RPC 。</li>
<li>为服务端提供了多种工作模式，如线程池模型、非阻塞模型。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>不支持双通道 。</li>
<li>rpc方法非线程安全，服务器容易被挂死，需要串行化。</li>
<li>默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li>
<li>开发环境、编译较麻烦。</li>
</ol>
<h3 id="使用Nacos作为服务器注册与发现"><a href="#使用Nacos作为服务器注册与发现" class="headerlink" title="使用Nacos作为服务器注册与发现"></a>使用Nacos作为服务器注册与发现</h3><h1 id="几种注册中心的对比"><a href="#几种注册中心的对比" class="headerlink" title="几种注册中心的对比"></a>几种注册中心的对比</h1><p>我们之前的注册与发现是用一个ConcurrentHashMap来进行存储的。这存在一个隐患，当我们将服务端地址固化在代码中，对于客户端来说，它只会去寻找一个服务提供者，但如果这个提供者挂掉了或者换了地址，那就没有办法了。</p>
<p>在分布式架构中，有一个重要的组件，就是服务注册中心，它用于保存多个服务提供者的信息，每个服务提供者在启动时都需要向注册中心注册自己所拥有的服务。这样客户端在发起 RPC 时，就可以直接去向注册中心请求服务提供者的信息，如果拿来的这个挂了，还可以重新请求，并且在这种情况下可以很方便地实现负载均衡。</p>
<p>在最初的实现中，我们使用了本地保存服务的类称为 <code>ServiceRegistry</code>，现在更改为 <code>ServiceProvider</code>，而 <code>ServiceRegistry</code> 作为远程注册表（Nacos）使用，对应的类名也有修改。我们定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServiceRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span>;</span><br><span class="line">    InetSocketAddress <span class="title function_">lookupService</span><span class="params">(String serviceName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法很好理解，register 方法将服务的名称和地址注册进服务注册中心，lookupService 方法则是根据服务名称从注册中心获取到一个服务提供者的地址。</p>
<p>我们让NacosServiceRegistry实现这个接口,以供服务器调用，注册服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosServiceRegistry</span> <span class="keyword">implements</span> <span class="title class_">ServiceRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(NacosServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_ADDR</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1:8848&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            namingService = NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接到Nacos时有错误发生: &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            namingService.registerInstance(serviceName, inetSocketAddress.getHostName(), inetSocketAddress.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;注册服务时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InetSocketAddress <span class="title function_">lookupService</span><span class="params">(String serviceName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = namingService.getAllInstances(serviceName);</span><br><span class="line">            <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取服务时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自动注销服务和负载均衡策略"><a href="#自动注销服务和负载均衡策略" class="headerlink" title="自动注销服务和负载均衡策略"></a>自动注销服务和负载均衡策略</h3><h4 id="自动注销服务"><a href="#自动注销服务" class="headerlink" title="自动注销服务"></a>自动注销服务</h4><p>如果你启动完成服务端后把服务端给关闭了，并不会自动地注销 Nacos 中对应的服务信息，这样就导致了当客户端再次向 Nacos 请求服务时，会获取到已经关闭的服务端信息，最终就有可能因为连接不到服务器而调用失败。</p>
<p>那么我们就需要一种办法，在服务端关闭之前自动向 Nacos 注销服务。但是有一个问题，我们不知道什么时候服务器会关闭，也就不知道这个方法调用的时机，就没有办法手工去调用。这时，我们就需要钩子。</p>
<p>钩子是什么呢？是在某些事件发生后自动去调用的方法。那么我们只需要把注销服务的方法写到关闭系统的钩子方法里就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//钩子函数    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> address.getHostName();</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;注销服务 &#123;&#125; 失败&quot;</span>, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用了单例模式创建其对象，在 addClearAllHook 中，Runtime 对象是 JVM 虚拟机的运行时环境，调用其<code>addShutdownHook</code>方法增加一个钩子函数，创建一个新线程调用 clearRegistry 方法完成注销工作。这个钩子函数会在 JVM 关闭之前被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShutdownHook</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ShutdownHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> ThreadPoolFactory.createDefaultThreadPool(<span class="string">&quot;shutdown-hook&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ShutdownHook</span> <span class="variable">shutdownHook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShutdownHook</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title function_">getShutdownHook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addClearAllHook</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;关闭后将自动注销所有服务&quot;</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><p>一个客户端的负载均衡器， 使用自己定义的负载均衡器（随机算法，轮转算法），当我们在客户端需要某个服务的时候，就利用服务发现机制，以及负载均衡算法得到一个适合的服务地址，然后向对应地址的服务器发起请求。</p>
<h2 id="rpc-client-rpc-server"><a href="#rpc-client-rpc-server" class="headerlink" title="rpc-client,rpc-server"></a>rpc-client,rpc-server</h2><p>保证通用性，我们定义两个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RpcClient</span> &#123;</span><br><span class="line">    Object <span class="title function_">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158516573">一、Netty简介与IO模型 - 知乎 (zhihu.com)</a></p>
<h2 id="RPC调用过程"><a href="#RPC调用过程" class="headerlink" title="RPC调用过程"></a>RPC调用过程</h2><ol>
<li><p>首先服务器端启动，通过我们自定义的注解将服务地址等信息注册到注册中心，客户端要发起请求，它首先会创建一个请求的实例，客户端组装的请求实例中包含这样几个属性，调用接口名称，方法名称，方法参数，参数类型，是否心跳包。</p>
</li>
<li><p>它首先会来到注册中心，根据请求实例对象，获取所有对应的服务实例信息，然后通过本地的负载均衡算法选择一个合适的服务器来发起请求。</p>
</li>
<li><p>在发起请求之前，客户端通过netty来与服务器端建立连接（通过异步的方式），然后得到相应的channel。之后这个客户端与服务器的交互都是通过这个channel来实现。</p>
</li>
<li><p>得到channel之后，客户端在发起请求，这个请求首先经过客户端的netty的出站处理器的处理。在客户端的出栈处理器里包含编码器（编码器中进行序列化），空闲时处理器。经过了出栈处理器的处理后。请求会到达服务器端。</p>
</li>
<li><p>请求到达服务器端，服务器端其实也有一个被注册到工作线程组中某个事件循环的selector的channel。它用于与客户端的相应的channel通信。channel事件消息在ChannelPipeline中流动和传播，相应的事件能够被ChannelHandler拦截处理、传递、忽略或者终止 。 客户端发起的请求报文会经过该channel入栈处理器的处理。主要是在解码器中进行解码和反序列化。</p>
</li>
<li><p>解码器将请求报文解析成一个request类，它会被channelPipeline的末端NettyServerHandler处理。在这个处理器中调用请求的方法，我们在服务器端会将所有的服务和它的全类名存入到一个Map的集合中，在处理器中我们通过全类名得到服务实例对象，然后通过实例对象的Class对象获取方法的实例，最后通过调用method.invoke方法来得到最终的结果。</p>
</li>
<li><p>我们将结果封装为一个response对象，通过ChannelHandlerContext对象将响应包写回发送给客户端，当然这个过程也要经过服务器端的出站处理器的处理，主要是在编码器中进行编码和序列化。</p>
</li>
</ol>
<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangwei19871103/article/details/104011694">(229条消息) 吃透Netty源码系列一之NioEventLoopGroup_王伟王胖胖的博客-CSDN博客</a></p>
<p><a href>Netty</a> 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。<a href>Netty</a> 基于 NIO 的，封装了 JDK 的 NIO，让我们使用起来更加方法灵活。</p>
<p>特点和优势：</p>
<ul>
<li>使用简单：封装了 NIO 的很多细节，使用更简单。 </li>
<li>功能强大：预置了多种编解码功能，支持多种主流协议。 </li>
<li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。 </li>
<li>性能高：通过与其他业界主流的 NIO 框架对比，<a href>Netty</a> 的综合性能最优。</li>
</ul>
<h3 id="为什么-Netty-性能高"><a href="#为什么-Netty-性能高" class="headerlink" title="为什么 Netty 性能高"></a>为什么 <a href>Netty</a> 性能高</h3><ul>
<li>IO 线程模型：同步非阻塞，用最少的资源做更多的事。 </li>
<li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。 </li>
<li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。 </li>
<li>串行化处理读写：避免使用锁带来的性能开销。 </li>
<li>高性能序列化协议：支持 protobuf 等高性能序列化协议。</li>
</ul>
<p>Netty是一个NIO框架，它将IO通道的建立、可读、可写等状态变化，抽象成事件，以责任链的方式进行传递，可以在处理链上插入自定义的Handler，对感兴趣的事件进行监听和处理。Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端&#x2F;服务器框架。</p>
<p>Netty 推荐使用<strong>主从Reactor模型</strong>，Netty 主线程组BossGroup用于客户端的监听，并将监听到的客户端Channel注册到从线程组WorkGroup上的一个NIOEventLoop的Selector上，这个NIOEventLoop主要用于和客户端数据的 Read &#x2F; Write，客户端和服务端会在数据传输的管道ChannelPipeline中调用InboundHandler&#x2F;OutboundHandler对数据进行处理。</p>
<p>在netty中I&#x2F;O操作都是异步执行，所以任何的I&#x2F;O调用都将立即返回。netty为我们提供了一个ChannelFuture实例，这个实例将会返回关于I&#x2F;O操作结果或者状态。<strong>我们可以通过 addListener()为ChannelFuture添加监听器</strong>，这样当相关的操作执行结束之后就会发送消息给监听器。</p>
<ul>
<li>Netty 是由 JBOSS 提供的一个 Java 开源框架， 现为 Github 上的独立项目。</li>
<li>Netty 是一个异步的、 基于事件驱动的网络应用框架， 用以快速开发高性能、 高可靠性的网络 IO 程序。</li>
<li>Netty 本质是一个 NIO 框架， 适用于服务器通讯相关的多种应用场景。</li>
</ul>
<p><img src="https://s2.loli.net/2022/05/14/VnOqH4UGvl1JeB2.png" alt="image.png">  </p>
<p><img src="https://s2.loli.net/2022/08/17/2StsFBWNvxCbX7z.png" alt="在这里插入图片描述"></p>
<p>Netty pipeline 分析：</p>
<p>参考： <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6efa9c5fa702">https://www.jianshu.com/p/6efa9c5fa702</a></p>
<h3 id="说下-Netty-零拷贝"><a href="#说下-Netty-零拷贝" class="headerlink" title="说下 Netty 零拷贝"></a>说下 <a href>Netty</a> 零拷贝</h3><p><a href>Netty</a> 的零拷贝主要包含三个方面：</p>
<ul>
<li><a href>Netty</a> 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，<strong>使用堆外直接内存进行 Socket 读写</strong>，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 </li>
<li><a href>Netty</a> 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。 </li>
<li><a href>Netty</a> 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的<a href>数据</a>发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</li>
</ul>
<h3 id="Netty-中责任链"><a href="#Netty-中责任链" class="headerlink" title="Netty 中责任链"></a><a href>Netty</a> 中责任链</h3><p>首先说明责任链模式：</p>
<p>适用场景:</p>
<ul>
<li>对于一个请求来说,如果有个对象都有机会处理它,而且不明确到底是哪个对象会处理请求时,我们可以考虑使用责任链模式实现它,让请求从链的头部往后移动,直到链上的一个节点成功处理了它为止</li>
</ul>
<p>优点:</p>
<ul>
<li>发送者不需要知道自己发送的这个请求到底会被哪个对象处理掉,实现了发送者和接受者的解耦 </li>
<li>简化了发送者对象的设计 </li>
<li>可以动态的添加节点和删除节点</li>
</ul>
<p>缺点:</p>
<ul>
<li>所有的请求都从链的头部开始遍历,对性能有损耗 </li>
<li>极差的情况,不保证请求一定会被处理</li>
</ul>
<p><a href>Netty</a>的责任链：</p>
<p>netty 的 pipeline 设计,就采用了责任链设计模式, 底层采用双向<a href>链表</a>的数据结构, 将链上的各个处理器串联起来</p>
<p>客户端每一个请求的到来，netty 都认为，pipeline 中的所有的处理器都有机会处理它，因此，对于入栈的请求，全部从头节点开始往后传播，一直传播到尾节点（来到尾节点的 msg 会被释放掉）。</p>
<p>责任终止机制</p>
<ul>
<li>在pipeline中的任意一个节点，只要我们不手动的往下传播下去，这个事件就会终止传播在当前节点 </li>
<li>对于入站<a href>数据</a>，默认会传递到尾节点，进行回收，如果我们不进行下一步传播，事件就会终止在当前节点</li>
</ul>
<h3 id="简单说下-Netty-中的重要组件"><a href="#简单说下-Netty-中的重要组件" class="headerlink" title="简单说下 Netty 中的重要组件"></a>简单说下 <a href>Netty</a> 中的重要组件</h3><ul>
<li>Channel：<a href>Netty</a> 网络操作抽象类，它除了包括基本的 I&#x2F;O 操作，如 bind、connect、read、write 等。 </li>
<li>EventLoop：主要是配合 Channel 处理 I&#x2F;O 操作，用来处理连接的生命周期中所发生的事情。 </li>
<li>ChannelFuture：<a href>Netty</a> 框架中所有的 I&#x2F;O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。 </li>
<li>ChannelHandler：充当了所有处理入站和出站<a href>数据</a>的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、<a href>数据</a>接收、异常、<a href>数据</a>转换等。 </li>
<li>ChannelPipeline：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。</li>
</ul>
<h3 id="netty粘包和拆包问题"><a href="#netty粘包和拆包问题" class="headerlink" title="netty粘包和拆包问题"></a>netty粘包和拆包问题</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rickiyang/p/12904552.html">Netty 中的粘包和拆包 - rickiyang - 博客园 (cnblogs.com)</a></p>
<p>在RPC框架中，粘包和拆包问题是必须解决一个问题，因为RPC框架中，各个微服务相互之间都是维系了一个TCP长连接，比如dubbo就是一个全双工的长连接。由于微服务往对方发送信息的时候，所有的请求都是使用的同一个连接，这样就会产生粘包和拆包的问题</p>
<p><strong>出现粘包、拆包现象的根本原因</strong></p>
<p>1、客户端要发送的数据小于TCP发送缓冲区的大小，TCP为了提升效率，将多个写入缓冲区的数据包一次发送出去，多个数据包粘在一起，造成粘包；<br>2、服务端的应用层没有及时处理接收缓冲区中的数据，再次进行读取时出现粘包问题；<br>3、数据发送过快，数据包堆积导致缓冲区积压多个数据后才一次性发送出去；<br>4、拆包一般由于一次发送的数据包太大，超过MSS的大小，那么这个数据包就会被拆成多个TCP报文分开进行传输。</p>
<h4 id="1-定长协议"><a href="#1-定长协议" class="headerlink" title="1. 定长协议"></a>1. 定长协议</h4><p>指定一个报文具有固定长度。比如约定一个报文的长度是 5 字节，那么：</p>
<p>报文：1234，只有4字节，但是还差一个怎么办呢，不足部分用空格补齐。就变为：1234 。</p>
<p>如果不补齐空格，那么就会读到下一个报文的字节来填充上一个报文直到补齐为止，这样粘包了。</p>
<p>定长协议的优点是使用简单，缺点很明显：浪费带宽。</p>
<p>Netty 中提供了 <code>FixedLengthFrameDecoder</code> ，支持把固定的长度的字节数当做一个完整的消息进行解码。</p>
<h4 id="2-特殊字符分割协议"><a href="#2-特殊字符分割协议" class="headerlink" title="2. 特殊字符分割协议"></a>2. 特殊字符分割协议</h4><p>很好理解，在每一个你认为是一个完整的包的尾部添加指定的特殊字符，比如：\n，\r等等。</p>
<p>需要注意的是：约定的特殊字符要保证唯一性，不能出现在报文的正文中，否则就将正文一分为二了。</p>
<p>Netty 中提供了 <code>DelimiterBasedFrameDecoder</code> 根据特殊字符进行解码，<code>LineBasedFrameDecoder</code>默认以换行符作为分隔符。</p>
<h4 id="3-变长协议"><a href="#3-变长协议" class="headerlink" title="3. 变长协议"></a>3. 变长协议</h4><p>变长协议的核心就是：<strong>将消息分为消息头和消息体，消息头中标识当前完整的消息体长度。</strong></p>
<ol>
<li>发送方在发送数据之前先获取数据的二进制字节大小，然后在消息体前面添加消息大小；</li>
<li>接收方在解析消息时先获取消息大小，之后必须读到该大小的字节数才认为是完整的消息。</li>
</ol>
<p>Netty 中提供了 <code>LengthFieldBasedFrameDecoder</code> ，通过<code>LengthFieldPrepender</code> 来给实际的消息体添加 length 字段。</p>
<h3 id="如何解决-TCP-的粘包拆包问题"><a href="#如何解决-TCP-的粘包拆包问题" class="headerlink" title="如何解决 TCP 的粘包拆包问题"></a>如何解决 TCP 的粘包拆包问题</h3><p>TCP 是以流的方式来处理<a href>数据</a>，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的<a href>数据</a>包发送。</p>
<p>TCP 粘包&#x2F;分包的原因：应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入<a href>数据</a>小于套接字缓冲区大小，网卡将应用多次写入的<a href>数据</a>发送到网络上，这将会发生粘包现象；</p>
<p><a href>Netty</a> 自带解决方式：</p>
<ul>
<li>消息定长：FixedLengthFrameDecoder 类</li>
<li>包尾增加特殊字符分割：<ul>
<li>行分隔符类：LineBasedFrameDecoder </li>
<li>自定义分隔符类 ：DelimiterBasedFrameDecoder</li>
</ul>
</li>
<li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li>
</ul>
<p>框架解决方式：</p>
<p><strong>自定义协议，其中有字段标明包长度。</strong></p>
<h3 id="netty心跳机制"><a href="#netty心跳机制" class="headerlink" title="netty心跳机制"></a>netty心跳机制</h3><p>在RpcRequest中，我们增加了一个属性<code>heartBeat</code> ,使用这个属性在NettyClientHandler中我们定义了一个触发器，这个触发器会在ChannelProvider类的get方法中，我们绑定了这样一个处理器：<code>addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS))</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">               <span class="comment">/*自定义序列化编解码器*/</span></span><br><span class="line">               <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">               ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">CommonEncoder</span>(serializer))</span><br><span class="line">                       .addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                       .addLast(<span class="keyword">new</span> <span class="title class_">CommonDecoder</span>())</span><br><span class="line">                       .addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<p>IdleStateHandler 是实现心跳的关键, 它会根据不同的 IO idle 类型来产生不同的 IdleStateEvent 事件,而这个事件的捕获, 其实就是在 <strong>userEventTriggered</strong> 方法中实现的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当出现空闲时间的触发器</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">           <span class="type">IdleState</span> <span class="variable">state</span> <span class="operator">=</span> ((IdleStateEvent) evt).state();</span><br><span class="line">           <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;发送心跳包 [&#123;&#125;]&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">               <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">               <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequest</span>();</span><br><span class="line">               rpcRequest.setHeartBeat(<span class="literal">true</span>);</span><br><span class="line">               channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当IdleStateHandler产生这样一个事件时，上述方法会创建一个RpcRequest对象，并将它的HearBeat属性置位true，并使用<code>channel.writeAndFlush（）</code>方法发送出去</p>
<p>在服务端，当接收到一个请求时，它会首先判断是否是心跳包，如果是心跳包就直接返回，如果不是，则调用对应的服务</p>
<h3 id="Netty-是如何保持长连接的"><a href="#Netty-是如何保持长连接的" class="headerlink" title="Netty 是如何保持长连接的"></a><a href>Netty</a> 是如何保持长连接的</h3><p>首先 TCP 协议的实现中也提供了 <a href>keep</a>Alive 报文用来探测对端是否可用。TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。</p>
<p><code>ChannelOption.SO_KEEPALIVE, true</code> 表示打开 TCP 的 <a href>keep</a>Alive 设置。</p>
<p>TCP 心跳的问题：</p>
<p>考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态一直向当前服务器发送些必然会失败的请求。</p>
<p><a href>Netty</a> 中提供了 <code>IdleStateHandler</code> 类专门用于处理心跳。</p>
<p><code>IdleStateHandler</code> 的构造函数如下：</p>
<p><a href="#">复制代码</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">IdleStateHandler</span><span class="params">(<span class="type">long</span> readerIdleTime, <span class="type">long</span> writerIdleTime, </span></span><br><span class="line"><span class="params">                        <span class="type">long</span> allIdleTime,TimeUnit unit)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数是隔多久检查一下读事件是否发生，如果 <code>channelRead()</code> 方法超过 readerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p>
<p>第二个参数是隔多久检查一下写事件是否发生，writerIdleTime 写空闲超时时间设定，如果 <code>write()</code> 方法超过 writerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p>
<p>第三个参数是全能型参数，隔多久检查读写事件；</p>
<p>第四个参数表示当前的时间单位。</p>
<p>所以这里可以分别控制读，写，读写超时的时间，单位为秒，如果是0表示不检测，所以如果全是0，则相当于没添加这个 IdleStateHandler，连接是个普通的短连接。</p>
<h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/120814088">(229条消息) 一致性哈希算法原理详解_张维鹏的博客-CSDN博客_一致性哈希</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40378034/article/details/117870061">(229条消息) 一致性哈希算法详解_邋遢的流浪剑客的博客-CSDN博客_一致性哈希算法</a></p>
<p>是一种特殊的哈希算法，目的是解决分布式缓存的问题。 在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/5981869">哈希表</a>( Distributed Hash Table，DHT) 中存在的动态伸缩等问题 。</p>
<p>在分布式系统中应用非常广泛。一致性哈希是一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/4960188">哈希算法</a>，简单地说在移除或者添加一个服务器时，此算法能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系，尽可能满足单调性的要求。在普通分布式集群中，服务请求与处理请求服务器之间可以一一对应，也就是说固定服务请求与处理服务器之间的映射关系，某个请求由固定的服务器去处理。这种方式无法对整个系统进行负载均衡，可能会造成某些服务器过于繁忙以至于无法处理新来的请求。而另一些服务器则过于空闲，整体系统的资源利用率低，并且当分布式集群中的某个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>宕机，会直接导致某些服务请求无法处理 。</p>
<p>一致性哈希算法将整个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%80%BC/5896926">哈希值</a>空间映射成一个虚拟的圆环，整个哈希空间的取值范围为0<del>232-1。整个空间按顺时针方向组织。0</del>232-1在零点中方向重合。接下来使用如下算法对服务请求进行映射，将服务请求使用哈希算法算出对应的hash值，然后根据hash值的位置沿圆环顺时针查找，第一台遇到的服务器就是所对应的处理请求服务器。当增加一台新的服务器，受影响的数据仅仅是新添加的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性</p>
<p>一致性哈希算法是在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/4960188">哈希算法</a>基础上提出的，在动态变化的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232">分布式</a>环境中，哈希算法应该满足的几个条件:平衡性、单调性和分散性 </p>
<ol>
<li><p>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p>
</li>
<li><p>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</p>
</li>
<li><p>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p>
</li>
</ol>
<h3 id="数据倾斜问题"><a href="#数据倾斜问题" class="headerlink" title="数据倾斜问题"></a>数据倾斜问题</h3><p>在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成数据倾斜（被缓存的对象大部分缓存在某一台服务器上）问题，如图特例</p>
<img src="https://img-blog.csdnimg.cn/3bcc11c6a1ba4b619e41eb2ec056ff88.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWF4d2VsbC1tYQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom: 67%;">

<p>这时我们发现有大量数据集中在节点A上，而节点B只有少量数据。在极端情况下，假如A节点出现故障，存储在A上的数据要全部转移到B上，大量的数据导可能会导致节点B的崩溃，之后A和B上所有的数据向节点C迁移，导致节点C也崩溃，由此导致整个集群宕机。这种情况被称为<strong>雪崩效应</strong>。为了解决数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体操作可以为服务器IP或主机名后加入编号来实现数据定位算法不变，只需要增加一步：虚拟节点到实际点的映射。所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p>
<h2 id="服务之间的调用为啥不直接用-HTTP-而用-RPC？"><a href="#服务之间的调用为啥不直接用-HTTP-而用-RPC？" class="headerlink" title="服务之间的调用为啥不直接用 HTTP 而用 RPC？"></a>服务之间的调用为啥不直接用 HTTP 而用 RPC？</h2><p>RPC 只是一种概念、一种设计，就是为了解决 <strong>不同服务之间的调用问题</strong>, 它一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。但是，HTTP 是一种协议，RPC框架可以使用 HTTP协议作为传输协议或者直接使用TCP作为传输协议，使用不同的协议一般也是为了适应不同的场景。</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 <strong>IP 地址和端口</strong> 。这个找到服务对应的 IP 端口的过程，其实就是 <strong>服务发现</strong>。</p>
<p>在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong> 去解析得到它背后的 IP 地址，默认 <strong>80 端口</strong>。</p>
<p>而 <strong>RPC</strong> 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 <strong>Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 <strong>CoreDNS</strong>。</p>
<p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p>
<h3 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h3><p>以主流的 <strong>HTTP1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p>
<p>而 <strong>RPC</strong> 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 <strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/72fcad064c9e4103a11f1a2d579f79b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="connection_pool"></p>
<p>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。</p>
<p>可以看出这一块两者也没太大区别，所以也不是关键。</p>
<h3 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h3><p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p>
<p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p>
<p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p>
<p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/d501dfc6f764430188ce61fda0f3e5d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="序列化和反序列化"></p>
<p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p>
<p>我们可以随便截个图直观看下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/04e8a79ddb7247759df23f1132c01655~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="HTTP报文"></p>
<p>可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 <code>Content-Type</code>，就不需要每次都真的把 <code>Content-Type</code> 这个字段都传过来，类似的情况其实在 Body 的 JSON 结构里也特别明显。</p>
<p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/284c26bb7f2848889d1d9b95cf49decb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="HTTP原理"></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/edb050d383c644e895e505253f1c4d90~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="RPC原理"></p>
<p>当然上面说的 HTTP，其实 <strong>特指的是现在主流使用的 HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以 <strong>性能可能比很多 RPC 协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息， RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></li>
</ul>
<ul>
<li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 <strong>消息边界</strong> 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li>
<li>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。</strong> 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li>
<li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li>
<li><strong>HTTP2.0</strong> 在 <strong>HTTP1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li>
</ul>
<h1 id="Community-项目"><a href="#Community-项目" class="headerlink" title="Community 项目"></a>Community 项目</h1><p><img src="https://s2.loli.net/2022/07/30/JlBNuHkVbvRomYW.png" alt="img"></p>
<p> 整个技术是构建在SpringBoot上的，其他技术是依托于SpringBoot之上的。SpringBoot只是起到辅助的作用，降低其他技术的使用难度。整个技术的核心是Spring框架，在Spring之上使用了SpringMvc（解决了前后端请求处理交互的问题）、Spring Mybatis（可以访问数据库）、Spring Security（用于管理项目中的登录权限等）。SpringMvc、Spring Mybatis、Spring Security构成了项目的基石，项目中几乎所有请求是由他们完成的。 </p>
<h2 id="注册和登录模块"><a href="#注册和登录模块" class="headerlink" title="注册和登录模块"></a>注册和登录模块</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p><strong>流程</strong></p>
<ul>
<li>点击注册，根据 LoginController 层的 &#x2F;register（get）返回注册页面。</li>
</ul>
<ul>
<li>输入账户，密码，邮箱，点击注册按钮。根据 &#x2F;register（post）传入User。调用 userService.register 方法。</li>
<li>userService.register 方法首先根据用户名和邮箱查询数据库看是否已经存在，如果存在，返回错误信息。如果不存在，对User加入 Salt 属性，即五位随机字符串，为了和密码拼接后进行md5加密。将加密后的密码存入数据库。分别设置Type，Status为0。设置随机字符串激活码。设置用户头像和创建时间。将User插入数据库。</li>
<li>使用mailClient发送激活邮件。将可能带有错误信息的Map返回。</li>
<li>LoginController 层得到 Map 判断是否为空，为空则注册成功，返回 &#x2F;site&#x2F;operate-result 页面。否则返回 &#x2F;site&#x2F;register 页面，并将错误信息加入model中。</li>
</ul>
<h3 id="激活账号"><a href="#激活账号" class="headerlink" title="激活账号"></a>激活账号</h3><p>首先在CommunityConstant工具类中设置三个常量表示激活状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//激活成功</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ACTIVATION_SUCCESS</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重复激活</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ACTIVATION_REPEAT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//激活失败</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ACTIVATION_FAILURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>在邮箱中点击激活链接，调用 LoginController 层的 &#x2F;activation&#x2F;{userId}&#x2F;{code} 。调用userService.activation(userId, code)方法。首先判断 User 中的status是否已经等于1，已经等于1返回 重复激活 信息。然后判断 User 中的激活码是否与code相等，等则设置status为1，返回激活成功。不等返回激活失败。<br>LoginController 层获取 int 返回值，判断0 1 2 在model中加入相应信息，返回&#x2F;site&#x2F;operate-result 页面。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>分为 生成验证码， 登录，显示登录信息， 账号设置（修改头像），账号设置（修改密码），检查登录状态，退出登录。</p>
<ul>
<li>在登录页面输入用户名，密码，验证码和是否勾选“记住我”。将对应的username，password，code，rememberme通过 “&#x2F;login” 传入 login 方法。</li>
</ul>
<ul>
<li>login方法在参数中使用 @CookieValue 注解从cookie中取出Redis中验证码文本的key，判断一下key是否为空，不为空则取出Redis中的验证码文本判断是否和code相等，不等返回Map。然后根据remember选取登录凭证超时时间。然后将username，password 和超时时间 传入给userService.login 方法。</li>
<li>userService.login 方法拿到 三个值先判空，空则返回Map。然后根据username查询数据库看账号是否存在。然后查询status看账户是否已经激活。最后验证密码（调取salt和password拼接后使用md5加密再和数据库中密码比对）。然后生成登录凭证，见LoginTicket，将登陆凭证放入Redis，key为随机字符串Ticket字段。将凭证放入Map并返回给 LoginController 层。</li>
<li>LoginController 层拿到Map。查看其中是否有凭证，有将凭证放入cookie返回给浏览器，重定向转入index。无则将Map中报错信息加入model，转入login。</li>
</ul>
<h3 id="显示登录信息"><a href="#显示登录信息" class="headerlink" title="显示登录信息"></a>显示登录信息</h3><p>前提知识：拦截器的 preHandle 方法在 Controller 层之前执行。postHandle 在Controller之后执行。afterCompletion 在TemplateEngine之后执行。使用配置类 WebMvcConfig 将拦截器注册，即可自动拦截。</p>
<ul>
<li>在 LoginTicketInterceptor 的 preHandle 方法中使用工具类CookieUtil 获取登录凭证。然后使用 userService.findLoginTicket 方法查询凭证，并检验凭证是否有效。 如果有效，根据凭证中的userId 查询到 User 对象。然后将 User 对象利用工具类 hostHolder 存入到 ThreadLocal中。</li>
<li>在 postHandle 中取出 User 放入 modelAndView。</li>
<li>在最后的 afterCompletion 中将 User 释放。</li>
<li>使用配置类 WebMvcConfig 将拦截器注册，即可自动拦截。</li>
<li>在index.html 中判断 model 中是否有 User，有则隐藏注册登录。无则隐藏消息和个人信息。</li>
</ul>
<h2 id="帖子模块（核心）"><a href="#帖子模块（核心）" class="headerlink" title="帖子模块（核心）"></a>帖子模块（核心）</h2><blockquote>
<p>分为 过滤敏感词，发布帖子，帖子详情，显示评论，添加评论，私信列表，发送私信。</p>
<p>基于SpringMvc实现的首页、帖子、评论、私信的功能，异常和日志使用到了通用的技术。重点关注敏感词是怎么实现的（前缀树算法），事务也需要重点关注（什么是事务、事物的隔离级别，怎么去管理事务的）。整个模块还用到了Advice（控制器的通知，统一处理了异常）、AOP（统一记录了日志，事实上其他的很多功能（比如事务）都应用到了AOP）、Transaction（重点）。</p>
</blockquote>
<h3 id="发布帖子"><a href="#发布帖子" class="headerlink" title="发布帖子"></a>发布帖子</h3><p>使用 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Ajax&spm=1001.2101.3001.7020">Ajax</a> 在 index 页面发送异步请求（局部刷新）。在 Controller 层返回 Json 数据显示。</p>
<ul>
<li>前提用户已经登录，否则不显示 “我要发布” 按钮。（通过hostHolder中的 loginUser 是否为空判断）</li>
<li>在首页点击 “我要发布”，填写标题和正文，映射到DiscussPostController（&#x2F;discuss）层的 &#x2F;add 路径。新建 DiscussPost 类，通过 hostHolder 的 User 设置 id，设置 title，content，createTime。其余默认为0。使用 discussPostService.addDiscussPost(post) 方法将其插入数据库。</li>
<li>discussPostService.addDiscussPost 方法将post 中的 title，content 转义HTML标记和过滤敏感词。然后调用 discussPostMapper.insertDiscussPost(post) 存入数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转义HTML标记</span></span><br><span class="line">      post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));</span><br><span class="line">      post.setContent(HtmlUtils.htmlEscape(post.getContent()));</span><br><span class="line">      <span class="comment">// 过滤敏感词</span></span><br><span class="line">      post.setTitle(sensitiveFilter.filter(post.getTitle()));</span><br><span class="line">      post.setContent(sensitiveFilter.filter(post.getContent()));</span><br></pre></td></tr></table></figure>

<ul>
<li>触发发帖事件，构造 Topic 为 TOPIC_PUBLISH 的 Event，需要设置userId，EntityType，EntityId。然后使用 eventProducer.fireEvent 开始生产。（更新Elasticsearch 服务器中的帖子）<br>返回发布成功 Json 信息，异步显示，并刷新网页。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	$(<span class="string">&quot;#publishBtn&quot;</span>).<span class="title function_">click</span>(publish);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">publish</span>(<span class="params"></span>) &#123;</span><br><span class="line">	$(<span class="string">&quot;#publishModal&quot;</span>).<span class="title function_">modal</span>(<span class="string">&quot;hide&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取标题和内容</span></span><br><span class="line">	<span class="keyword">var</span> title = $(<span class="string">&quot;#recipient-name&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">	<span class="keyword">var</span> content = $(<span class="string">&quot;#message-text&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">	<span class="comment">// 发送异步请求(POST)</span></span><br><span class="line">	$.<span class="title function_">post</span>(</span><br><span class="line">	    <span class="variable constant_">CONTEXT_PATH</span> + <span class="string">&quot;/discuss/add&quot;</span>,</span><br><span class="line">	    &#123;<span class="string">&quot;title&quot;</span>:title,<span class="string">&quot;content&quot;</span>:content&#125;,</span><br><span class="line">	    <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">	        data = $.<span class="title function_">parseJSON</span>(data);</span><br><span class="line">	        <span class="comment">// 在提示框中显示返回消息</span></span><br><span class="line">	        $(<span class="string">&quot;#hintBody&quot;</span>).<span class="title function_">text</span>(data.<span class="property">msg</span>);</span><br><span class="line">	        <span class="comment">// 显示提示框</span></span><br><span class="line">            $(<span class="string">&quot;#hintModal&quot;</span>).<span class="title function_">modal</span>(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">            <span class="comment">// 2秒后,自动隐藏提示框</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                $(<span class="string">&quot;#hintModal&quot;</span>).<span class="title function_">modal</span>(<span class="string">&quot;hide&quot;</span>);</span><br><span class="line">                <span class="comment">// 刷新页面</span></span><br><span class="line">                <span class="keyword">if</span>(data.<span class="property">code</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">2000</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="帖子详情"><a href="#帖子详情" class="headerlink" title="帖子详情"></a>帖子详情</h3><ul>
<li>在 index 页面点击帖子，映射到DiscussPostController（&#x2F;discuss）层的 &#x2F;detail&#x2F;{discussPostId} 路径，并将帖子的 id 传入。</li>
<li>根据 id 利用 discussPostService.findDiscussPostById 方法查出 post。 根据 post.getUserId() 利用 userService.findUserById 方法查出 User。将 post，user 加入model。</li>
<li>新增：将点赞数量和状态查询处理加入model。</li>
<li>返回 &#x2F;site&#x2F;discuss-detail 页面。在 &#x2F;site&#x2F;discuss-detail 页面显示帖子和发布帖子的用户信息。</li>
</ul>
<h3 id="显示评论"><a href="#显示评论" class="headerlink" title="显示评论"></a>显示评论</h3><p>帖子详情后显示帖子的评论。<strong>同样在 DiscussPostController（&#x2F;discuss）层的 &#x2F;detail&#x2F;{discussPostId} 映射中</strong>。我们将 comment 表中的 entity_type 属性在 CommunityConstant 工具类中设置了两个常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实体类型: 帖子</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ENTITY_TYPE_POST</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实体类型: 评论</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ENTITY_TYPE_COMMENT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先设置评论分页信息。</li>
<li>根据该帖子的 id 和类型利用 commentService.findCommentsByEntity 方法查询所有评论。将该评论和该评论的作者（通过 comment 中的 userId 获取），点赞数量和该用户的点赞状态加入到Map中，<strong>同时还在该Map中嵌套插入一个包括该评论的所有回复，回复作者和回复目标（target），点赞数量和该用户的点赞状态的Map</strong>。再将回复数量插入Map。最后将每个评论的Map插入List，传入Model。</li>
<li>最后返回 &#x2F;site&#x2F;discuss-detail 页面。在页面中展示，其中分页模块复用 index::pagination。</li>
</ul>
<h3 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h3><p>添加评论有三种方式：① 回帖，② 回复评论，③ 回复某人的评论。</p>
<ul>
<li>① 在 discuss-detail 页面点击最下方的回帖，映射到 CommentController 层的 &#x2F;add&#x2F;{discussPostId}。传入了 entityType &#x3D; 1 和 entityId &#x3D; post.id 。</li>
<li>② 在评论下方回复，与①映射相同，传入entityType &#x3D; 2 和 entityId &#x3D; comment.id。</li>
<li>③ 对某人的评论回复，与①映射相同，传入entityType &#x3D; 2 和 entityId &#x3D; comment.id 和 targetId。</li>
<li>对传入的 comment 进一步设置userId，Status，CreateTime。然后调<code>commentService.addComment(comment) </code>方法插入数据库。</li>
<li>commentService.addComment 使用了事务注解。该方法对 comment 的 content 进行转义HTML标记和过滤敏感词。然后使用 commentMapper.insertComment 插入评论。然后通过更新帖子评论数量</li>
<li>触发 Topic 为 TOPIC_COMMENT 的事件: <strong>构建Event，设置当前登录用户id，被评论对象的type，被评论对象的id，被评论对象所在的帖子id</strong>（因为被评论的对象可能是帖子或者回复），被评论对象的用户id。然后调用 eventProducer 将 Event 发布到指定 Topic。</li>
<li>然后判断一下评论的是不是帖子，如果是则触发发帖事件。构造 Topic 为 TOPIC_PUBLISH 的 Event，需要设置userId，EntityType，EntityId。然后使用 eventProducer.fireEvent 开始生产。（更新Elasticsearch 服务器中的帖子）</li>
<li>计算帖子分数，将其加入缓存队列</li>
<li>重定向 return “redirect:&#x2F;discuss&#x2F;detail&#x2F;” + discussPostId。 刷新帖子详情页面。</li>
</ul>
<h3 id="私信列表"><a href="#私信列表" class="headerlink" title="私信列表"></a>私信列表</h3><p>两部分：① 点击消息进入会话列表，②点击某个会话进入私信详情页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">target</span> <span class="operator">=</span> userService.findUserByName(toName);</span><br><span class="line">       <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">1</span>, <span class="string">&quot;目标用户不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">       message.setFromId(hostHolder.getUser().getId());</span><br><span class="line">       message.setToId(target.getId());</span><br><span class="line">       <span class="keyword">if</span> (message.getFromId() &lt; message.getToId()) &#123;</span><br><span class="line">           message.setConversationId(message.getFromId() + <span class="string">&quot;_&quot;</span> + message.getToId());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           message.setConversationId(message.getToId() + <span class="string">&quot;_&quot;</span> + message.getFromId());</span><br><span class="line">       &#125;</span><br><span class="line">       message.setContent(content);</span><br><span class="line">       message.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">       messageService.addMessage(message);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h3 id="发送私信"><a href="#发送私信" class="headerlink" title="发送私信"></a>发送私信</h3><p>分为两部分：<br>一、① 在消息页面发私信 ，② 在与某人会话中给TA发私信。<br>二、将未读消息转为已读。（其实应该放置在 1.6 私信列表 ）</p>
<ul>
<li>在弹出框中填写发送对象和内容，点击发送。利用 letter.js 发送ajax异步请求。映射到 MessageController 层的 &#x2F;letter&#x2F;send 下。构造 message 对象，包括通过发送对象名称查询对象id，拼接 ConversationId。最后将 message 传递给 messageService.addMessage 方法。</li>
<li>messageService.addMessage 方法将message 中的 content 进行转义HTML标记和过滤敏感词。然后插入数据库。MessageController 层中如果发送对象为空，返回 json 错误信息。否则返回 code&#x3D;0。</li>
<li>letter.js 接受到返回数据，显示信息并重新加载当前页面。②与① 功能实现都是调用的 letter.js。只不过在 ② 中弹出框中自动填入了发送对象名称。</li>
<li>接受私信的用户在打开私信详情页面时，未读消息就应该变成已读。在 MessageController 层的 &#x2F;letter&#x2F;detail&#x2F;{conversationId} 路径下实现该功能。将私信列表传给 getLetterIds 函数，获得 id 列表。使用 messageService.readMessage 方法将 id 列表代表的 message 的 status 改为1。</li>
</ul>
<h2 id="统一处理异常和日志"><a href="#统一处理异常和日志" class="headerlink" title="统一处理异常和日志"></a>统一处理异常和日志</h2><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><ol>
<li>将 error 文件夹放在 resources 的 templates 路径下，其中包括 404 和 500.html 页面。</li>
<li>在 ExceptionAdvice 类中使用 @ControllerAdvice 注解对 Controller 中的异常进行统一处理。其中使用 ExceptionHandler 注解定义异常处理函数。</li>
<li>发生异常使用日志记录。并且判断请求是同步请求还是异步请求，同步请求重定向 error 文件夹。异步请求返回 Json 字符串。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(annotations = Controller.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ExceptionAdvice.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;Exception.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleException</span><span class="params">(Exception e, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;服务器发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement element : e.getStackTrace()) &#123;</span><br><span class="line">            logger.error(element.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">xRequestedWith</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;x-requested-with&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith)) &#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/plain;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            writer.write(CommunityUtil.getJSONString(<span class="number">1</span>, <span class="string">&quot;服务器异常!&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.sendRedirect(request.getContextPath() + <span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="处理日志"><a href="#处理日志" class="headerlink" title="处理日志"></a>处理日志</h3><ol>
<li>使用AOP思想，将处理日志的代码写在 ServiceLogAspect 中。</li>
<li>ServiceLogAspect 中首先使用 @Pointcut 定义哪些地方可以被织入。</li>
<li>利用 @Before 在连接点方法执行前执行逻辑，打印：用户[1.2.3.4],在[xxx],访问了com.nowcoder.community.service.xxx()。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceLogAspect</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ServiceLogAspect.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义哪些地方可以被织入。</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.nowcoder.community.service.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在连接点方法前执行。</span></span><br><span class="line"><span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印：用户[1.2.3.4],在[xxx],访问了[com.nowcoder.community.service.xxx()].</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 RequestContextHolder 获得 request。</span></span><br><span class="line">    <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">    <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteHost();</span><br><span class="line">    <span class="type">String</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用joinPoint参数获得类名和方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> + joinPoint.getSignature().getName();</span><br><span class="line">    logger.info(String.format(<span class="string">&quot;用户[%s],在[%s],访问了[%s].&quot;</span>, ip, now, target));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="性能模块-点赞关注"><a href="#性能模块-点赞关注" class="headerlink" title="性能模块(点赞关注)"></a>性能模块(点赞关注)</h2><blockquote>
<p>一些高频访问的功能（点赞、关注、统计、缓存）需要redis，redis不止能应用于这些功能还应用于统计网站的UV，活跃用户等使用了redis的两种特殊的数据类型，还使用redis用作缓存提高了性能。</p>
</blockquote>
<h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><ul>
<li>在帖子详情页面对帖子内容点赞，按钮通过 discuss.js 将 entityType&#x3D;0 ， 帖子id：entityId 和 entityUserId 通过 &#x2F;like 映射传递给 LikeController 层中的 like 方法。</li>
<li>like 方法通过调用 likeService 层的 like 进行点赞功能，然后再依次调用 findEntityLikeCount，findEntityLikeStatus 方法查询该帖子的点赞数量，查询当前登录用户的点赞状态。</li>
<li>likeService 层的 like 方法首先判断是否已经点过赞了，如果没有，就在Redis中该帖子key对应的set中加入点赞者的userId，并且对该帖子用户的赞的总数加一。如果已经赞过则移除UserId，并且对该帖子用户的赞的总数减一。（此处使用了事务，因为需要同时进行两个业务）</li>
<li>触发 Topic 为 TOPIC_LIKE 的事件: 构建Event，设置当前登录用户id，被点赞对象的type，被点赞对象的id，被点赞对象所在的帖子id（因为被点赞的对象可能是帖子或者回复），被点赞对象的用户id。然后调用 eventProducer 将 Event 发布到指定 Topic。</li>
<li>将点赞的数量和状态装入map，通过json字符串返回。在浏览器中显示。</li>
<li>在帖子详情页面对回复点赞，按钮通过 discuss.js 将 entityType&#x3D;1 和 回复id：entityId 和 entityUserId 通过 &#x2F;like 映射传递给 LikeController 层中的 like 方法。</li>
</ul>
<h3 id="收到的赞"><a href="#收到的赞" class="headerlink" title="收到的赞"></a>收到的赞</h3><ul>
<li>点击个人主页或者点击其他用户头像进入他人个人主页，映射到 UserController层（&#x2F;user）的 &#x2F;profile&#x2F;{userId} 。首先判断该用户存不存在。</li>
<li>然后根据该用户的 id 调用 likeService.findUserLikeCount 方法返回点赞数量。findUserLikeCount 方法首先根据userId 调用 getUserLikeKey 方法，返回该用户的赞总数的key。然后使用 redisTemplate 查询key对应的值返回给点赞数量。</li>
<li>将点赞数量加入model中返回浏览器显示。</li>
</ul>
<h3 id="关注和粉丝"><a href="#关注和粉丝" class="headerlink" title="关注和粉丝"></a>关注和粉丝</h3><ol>
<li>在他人个人主页点击关注，根据 profile.js 异步请求映射到 FollowController 层的 &#x2F;follow。传入entityType 和 entityId。然后调用 followService.follow 方法进行关注。</li>
<li>followService.follow 方法首先根据 userId, entityType, entityId 获取到前提中的两个key，开启事务，对当前登录用户的关注的key对应的 ZSet 加入 entityId。被关注用户的粉丝的key对应的 ZSet 加入 userId（Redis存的是有序Set，score采用当前时间插入）。</li>
<li>触发 Topic 为 TOPIC_FOLLOW 的事件: 构建Event，设置当前登录用户id，被关注对象的type，被关注对象的id，被关注对象的用户id（与被关注对象的id相同）。然后调用 eventProducer 将 Event 发布到指定 Topic。</li>
<li>返回关注成功Json。</li>
<li>此时按钮显示已关注，若再次点击则映射到 &#x2F;unfollow。调用 followService.unfollow 方法取消关注。与第2步骤逻辑基本相同，分别减一。</li>
</ol>
<h3 id="显示关注和粉丝数量"><a href="#显示关注和粉丝数量" class="headerlink" title="显示关注和粉丝数量"></a>显示关注和粉丝数量</h3><ol>
<li>在个人主页显示关注和粉丝的个数，与 1.3 相同，点击个人主页或者点击其他用户头像进入他人个人主页，映射到 UserController层（&#x2F;user）的 &#x2F;profile&#x2F;{userId} 。首先判断该用户存不存在。</li>
<li>根据 followService 层的 findFolloweeCount 和 findFollowerCount 方法查询该用户的关注数量和粉丝数量。</li>
<li>同时通过 hasFollowed 方法查询当前登录用户是否已经关注该用户。</li>
<li>将各个参数加入model，返回给 &#x2F;site&#x2F;profile。</li>
</ol>
<h3 id="显示关注和粉丝列表"><a href="#显示关注和粉丝列表" class="headerlink" title="显示关注和粉丝列表"></a>显示关注和粉丝列表</h3><ol>
<li>在个人主页点击关注xx人，映射到 FollowController 层的 &#x2F;followees&#x2F;{userId}。首先根据 userId判断该用户是否存在。然后设置分页信息。通过 followService.findFollowees 方法返回该用户的关注列表。</li>
<li>findFollowees 方法根据 userId 查询关注者id列表。根据id列表生成一个map列表。map列表中装入id对应的User和关注时间。返回给Controller。</li>
<li>Controller接收到列表，然后再判断一下当前登录用户对该列表中的用户是否已经关注，将该字段放入map列表中。返回给 &#x2F;site&#x2F;followee 显示。</li>
<li>点击粉丝xx人，映射到 &#x2F;followers&#x2F;{userId}。逻辑与上面基本一致，就是查询的key不同。返回给 &#x2F;site&#x2F;follower显示。</li>
</ol>
<h3 id="优化登陆"><a href="#优化登陆" class="headerlink" title="优化登陆"></a>优化登陆</h3><p><img src="https://s2.loli.net/2022/07/30/phqPlUvoIkzW8cr.png" alt="在这里插入图片描述"></p>
<h2 id="通知模块"><a href="#通知模块" class="headerlink" title="通知模块"></a>通知模块</h2><p>​    应用了消息队列的Kakfa，框架的使用非常简单，重点去了解Kafka的生产消费模式。重点回顾生产消费模型，了解能够解决哪些问题。</p>
<p><img src="https://s2.loli.net/2022/07/30/O4a6Ut9NXnklHgy.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String topic; <span class="comment">// 存放消息空间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> userId; <span class="comment">// 触发事件用户id</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> entityType; <span class="comment">// 事件目标类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> entityId; <span class="comment">// 事件目标id</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> entityUserId ;<span class="comment">// 事件目标所有者id</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 其他</span></span><br></pre></td></tr></table></figure>

<p>在 event 文件夹下构建 EventConsumer 类，监听三种类型topic，即：评论，点赞，关注。根据收到的 event 构建 message 对象，使用 messageService 插入数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventConsumer</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(EventConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleCommentMessage</span><span class="params">(ConsumerRecord record)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (record == <span class="literal">null</span> || record.value() == <span class="literal">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;消息的内容为空!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="literal">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;消息格式错误!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送站内通知</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        <span class="comment">// 系统发送 设为 1</span></span><br><span class="line">        message.setFromId(SYSTEM_USER_ID);</span><br><span class="line">        message.setToId(event.getEntityUserId());</span><br><span class="line">        <span class="comment">// ConversationId 设为 topic。</span></span><br><span class="line">        message.setConversationId(event.getTopic());</span><br><span class="line">        message.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// message 的 content </span></span><br><span class="line">        Map&lt;String, Object&gt; content = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        content.put(<span class="string">&quot;userId&quot;</span>, event.getUserId());</span><br><span class="line">        content.put(<span class="string">&quot;entityType&quot;</span>, event.getEntityType());</span><br><span class="line">        content.put(<span class="string">&quot;entityId&quot;</span>, event.getEntityId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!event.getData().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) &#123;</span><br><span class="line">                content.put(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存为 json 字符串</span></span><br><span class="line">        message.setContent(JSONObject.toJSONString(content));</span><br><span class="line">        messageService.addMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<strong>评论，点赞，关注</strong>时加入触发事件代码。在 帖子模块（核心）1.5小节：CommentController，点赞关注模块（引入Redis）1.2小节：LikeController，点赞关注模块（引入Redis）1.4.1小节：FollowController中加入相应代码，即构建event并且调用 eventProducer 发布事件。</p>
<h3 id="显示系统通知"><a href="#显示系统通知" class="headerlink" title="显示系统通知"></a>显示系统通知</h3><p><strong>点击系统通知</strong></p>
<ul>
<li>点击消息内的系统通知，映射到 MessageController 中的 &#x2F;notice&#x2F;list。会分别显示评论，赞，关注三类通知的一个最新消息。</li>
<li>以评论为例：会调用 messageService.findLatestNotice 方法查询到最近的评论通知，将 message 中的 content 反html转义后从json转为map对象，然后将各种信息传入返回给浏览器的map，同时在该map中装入评论通知总数和未读评论通知数。然后将map装入model返回给浏览器。</li>
<li>赞和关注模块同样如上。最后再将所有的未读数量查询出，装入model。</li>
</ul>
<p><strong>系统通知详情页面</strong></p>
<ul>
<li>点击评论，赞，关注三类通知的某一类通知，会映射到 MessageController 层的 &#x2F;notice&#x2F;detail&#x2F;{topic}。设置分页信息。通过 messageService.findNotices 方法查询通知列表。</li>
<li>将列表中每个message装入map，并且将每个message中的content反转义并且从json转换为map，将该map中的信息装入返回给浏览器的map。将每个map装入list，将list装入model。</li>
<li>使用 messageService.readMessage 方法将列表中的 message 设置为已读。</li>
<li>返回 &#x2F;site&#x2F;notice-detail。</li>
<li>最后使用 MessageInterceptor 拦截器查询出私信未读数量和系统通知未读数量，将其加和放入modelAndView，在顶部栏的消息上显示总的未读数量。</li>
</ul>
<h3 id="为什么Kafka而不是RabbitMq？"><a href="#为什么Kafka而不是RabbitMq？" class="headerlink" title="为什么Kafka而不是RabbitMq？"></a>为什么Kafka而不是RabbitMq？</h3><p>Kafka主要为高吞吐量的订阅发布系统而设计，主要追求速度与持久化。kafka中的消息由键、值、时间戳组成，kafka不记录每个消息被谁使用，只通过偏移量记录哪些消息是未读的，kafka中可以指定消费组来实现订阅发布的功能。</p>
<p><strong>Kafka：</strong></p>
<ol>
<li><p>从A系统到B系统的消息<strong>没有复杂的传递规则</strong>，并且具有较高的吞吐量要求。</p>
</li>
<li><p><strong>需要访问消息的历史记录的场景</strong>，因为kafak是持久化消息的，所以可以通过偏移量访问到那些已经被消费的消息（前提是磁盘空间足够，kafka没有将日志文件删除）</p>
</li>
<li><p>流处理的场景。处理源源不断的流式消息，比较典型的是日志的例子，将系统中源源不断生成的日志发送到kafka中。</p>
</li>
</ol>
<p><strong>rabbitmq：</strong></p>
<ol>
<li><p>需要对消息进行更加细粒度的控制，包括一些可靠性方面的特性，比如死信队列。</p>
</li>
<li><p>需要多种消费模式（点对点，广播，订阅发布等）</p>
</li>
<li><p>消息需要通过复杂的路由到消费者。</p>
</li>
</ol>
<h4 id="基于拉（Pull）的方法"><a href="#基于拉（Pull）的方法" class="headerlink" title="基于拉（Pull）的方法"></a>基于拉（Pull）的方法</h4><p>Kafka 使用拉模型，在该模型中，消费者从特定的偏移量开始批量地请求消息。Apache Kafka 还支持长轮询，当通过偏移量不再获取到消息时，长轮询会停止紧凑的轮询请求。由于分区（partitions）的存在，Apache Kafka 使用拉取模型是合理的。Kafka 可以在没有消费者相互竞争的情况下提供消息排序。这种方法让用户可以利用消息批处理来实现高效的消息传递，获取更高的吞吐量。</p>
<h4 id="基于推（Push）的方法"><a href="#基于推（Push）的方法" class="headerlink" title="基于推（Push）的方法"></a>基于推（Push）的方法</h4><p>RabbitMQ 将消息推送给消费者，这个过程包括预读取限制的配置，该配置对于防止消费者被多个消息淹没至关重要。它们对于低延迟的消息传递也很有用。推送方法的目的是快速而独立地分发各个消息，在这个过程中保证所有的分发是均匀地并行进行的，并使消息能够按照到达的顺序获得处理。</p>
<p>具体的比较</p>
<ol>
<li>Push模式</li>
</ol>
<p>推模式是服务器端根据用户需要，由目的、按时将用户感兴趣的信息主动发送到用户的客户端</p>
<p>Push模式的主要优点是</p>
<ul>
<li>对用户要求低，方便用户获取需要的信息</li>
<li>及时性好，服务器端即使地向客户端推送更行的动态信息</li>
</ul>
<p>Push模式的缺点</p>
<ul>
<li>不能确保发送成功。Push模式采用广播方式，只有服务器端和客户端在同一个频道上，推模式才有效，用户才能接收到信息</li>
<li>没有信息状态跟踪。Push模式采用开环控制技术，一个信息推送后的状态，比如客户端是否接收等，无从得知</li>
<li>针对性较差。推送的信息可能并不能满足客户端的个性化需求。</li>
</ul>
<ol start="2">
<li>Pull模式</li>
</ol>
<p>拉模式是客户端主动从服务器端获取信息</p>
<p>拉模式的主要优点是</p>
<ul>
<li>针对性强，能满足客户端的个性化需求</li>
<li>信息传输量较小，网络中传输的知识客户端的请求和服务器端对该请求的响应</li>
<li>服务器端的任务轻。服务器端只是被动接收查询，对客户端的查询请求做出响应</li>
</ul>
<p>拉模式的缺点</p>
<ul>
<li>实时较差，针对于服务器端实时更新的信息，客户端难以获取实时信息</li>
<li>对于客户端用户的要求较高，需要对服务器端具有一定的了解。</li>
</ul>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>​    全文搜索：针对帖子能够进行全文搜索，使用了Elasticsearch，使用起来也是非常简单，重点了解其数据结构，其存数据的方式与数据库不同，关注其索引的结构（找一找相关的文章）</p>
<p> <strong>搜索功能</strong></p>
<ul>
<li>在搜索框搜索关键字，映射到 SearchController 层的 &#x2F;search。调用 elasticsearchService.searchDiscussPost 方法，传入关键词和分页信息。</li>
<li>searchDiscussPost 方法构造一个 searchQuery 来实现标题和内容的多匹配查询，同时根据置顶等条件设置倒序。然后调用 elasticTemplate.queryForPage 的方法来进行查询，并且将匹配到的字段进行标红。然后将命中的帖子列表返回。</li>
<li>然后根据帖子列表聚合数据，将每个帖子的用户和点赞数量也放入其中。设置分页信息。</li>
<li>返回 &#x2F;site&#x2F;search。</li>
</ul>
<p> <strong>更新Elasticsearch 服务器中的帖子</strong></p>
<ul>
<li>发布帖子，增加评论时要将帖子异步提交到 Elasticsearch 服务器。利用kafka实现。</li>
<li>在<code> DiscussPostController</code> 层的 &#x2F;add 映射下，触发发帖事件，构造 Topic 为 TOPIC_PUBLISH 的 Event，需要设置<code>userId，EntityType，EntityId</code>。然后使用 eventProducer.fireEvent 开始生产。见 帖子模块（核心）1.2小节。</li>
<li>在 CommentController 层的 &#x2F;add&#x2F;{discussPostId} 映射下，判断一下评论的是不是帖子，如果是则触发发帖事件。同上。见 帖子模块（核心）1.5小节。</li>
<li>在 EventConsumer 中构建消费发帖事件，监听的 Topic 为 TOPIC_PUBLISH。判断消息是否为空，不为空将消息转为 Event，然后根据 Event 的 EntityId 获取到帖子，然后调用 discussRepository.save 方法将帖子插入到<code>Elasticsearch </code>服务器中。</li>
</ul>
<h2 id="权限模块"><a href="#权限模块" class="headerlink" title="权限模块"></a>权限模块</h2><p>应用了Spring Email和SpringMvc中的Interceptor（拦截器），其中拦截器能拦截所有请求，能解决通用的问题，涉及的面比较广、影响的请求比较多要重点关注。权限模块主要开发了注册、登录、退出、状态（在每个页面上怎么去显示登录用户的头像、用户名等）、设置（用户头像、修改密码等）、授权（不同类型的用户访问不同的功能，使用Security实现的）、会话管理（重点需要了解Cookie、session、项目中为什么不用session(主要是考虑分布式部署Session的问题)、不用session是如何解决的问题（ 把数据存在Redis中，使用了ThreadLocal ）等功能。</p>
<p><img src="https://s2.loli.net/2022/07/31/RJTyh8iLBZKXfEm.png" alt="权限控制"></p>
<p>user 表中的 type：‘0-普通用户; 1-超级管理员; 2-版主;’。</p>
<ul>
<li>引入 spring-boot-starter-security 依赖。</li>
<li>在 WebMvcConfig 中将 LoginRequiredInterceptor 拦截器废弃。</li>
<li>在 CommunityConstant 中设置：普通用户，管理员和版主的权限常量。</li>
<li><strong>在LoginTicketInterceptor 拦截器中进行认证，如果登录凭证有效，就构建 UsernamePasswordAuthenticationToken 认证并放入 SecurityContext 中，以便于Security进行授权。在用户退出登录时，清空 SecurityContext 内容。</strong></li>
<li>新建 SecurityConfig 配置进行授权，对特定的映射路径进行权限设置。分别设置没有登录和权限不足时的反馈行为。</li>
</ul>
<p><strong>配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 授权</span></span><br><span class="line">       http.authorizeRequests()</span><br><span class="line">               .antMatchers(</span><br><span class="line">                       <span class="string">&quot;/user/setting&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/user/upload&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/user/updatePassword&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/discuss/add&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/comment/add/**&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/letter/**&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/notice/**&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/like&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/follow&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/unfollow&quot;</span></span><br><span class="line">               )</span><br><span class="line">               .hasAnyAuthority(</span><br><span class="line">                       AUTHORITY_USER,</span><br><span class="line">                       AUTHORITY_ADMIN,</span><br><span class="line">                       AUTHORITY_MODERATOR</span><br><span class="line">               )</span><br><span class="line">               .antMatchers(</span><br><span class="line">                       <span class="string">&quot;/discuss/top&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/discuss/wonderful&quot;</span></span><br><span class="line">               )</span><br><span class="line">               .hasAnyAuthority(</span><br><span class="line">                       AUTHORITY_MODERATOR</span><br><span class="line">               )</span><br><span class="line">               .antMatchers(</span><br><span class="line">                       <span class="string">&quot;/discuss/delete&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/data/**&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/actuator/**&quot;</span></span><br><span class="line">               )</span><br><span class="line">               .hasAnyAuthority(</span><br><span class="line">                       AUTHORITY_ADMIN</span><br><span class="line">               )</span><br><span class="line">               <span class="comment">// 除了上面那些以外的任何请求，都允许</span></span><br><span class="line">               .anyRequest().permitAll()</span><br><span class="line">               <span class="comment">// 这里可以关闭csrf验证，默认是开启的，如果启用则需要在模板页面和模板js文件引用CSRF令牌，否则权限认证不通过。</span></span><br><span class="line">               .and().csrf().disable();</span><br></pre></td></tr></table></figure>



<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p>​    排行榜、上传、服务器缓存、线程池、缓存等。使用Quartz定时任务，重点关注Caffeine怎么提高了应用的性能，还要了解其局限性。还要重点关注线程池、缓存这两个话题。</p>
<h3 id="置顶，加精和删除"><a href="#置顶，加精和删除" class="headerlink" title="置顶，加精和删除"></a><strong>置顶，加精和删除</strong></h3><p>注：其中 discuss_post 表中的帖子的属性 type：‘0-普通; 1-置顶;’，status：‘0-正常; 1-精华; 2-拉黑;’</p>
<ul>
<li>点击置顶，加精和删除按钮，通过js分别映射到 DiscussPostController 层的 &#x2F;top，&#x2F;wonderful 和 &#x2F;delete。</li>
<li>置顶和加精分别将 discuss_post 表中的帖子的属性 type 变为1，status变为1。然后触发发帖事件。删除将 status变为2，然后触发删帖事件（Toplic 为 TOPIC_DELETE），删除后在 js 中返回 index 首页。</li>
<li>发帖事件将更新后的帖子上传到 elasticsearch 服务器中。新增删帖事件，将帖子从 elasticsearch 服务器中删除。</li>
<li>在 SecurityConfig 中设置权限，版主可以进行置顶和加精。管理员可以进行删除。</li>
<li>利用 thymeleaf-security 在html中将按钮根据权限进行隐藏。</li>
</ul>
<h3 id="网站数据统计"><a href="#网站数据统计" class="headerlink" title="网站数据统计"></a>网站数据统计</h3><ul>
<li><p>HyperLogLog - 采用一种基数算法，用于完成独立总数的统计。 占据空间小，无论统计多少个数据，只占12K的内存空间。 - 不精确的统计算法，标准误差为 0.81% 。</p>
</li>
<li><p>Bitmap - 不是一种独立的数据结构，实际上就是字符串。 - 支持按位存取数据，可以将其看成是byte数组。 - 适合存储索大量的连续的数据的布尔值</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/31/owj1m7BK8eyDzlx.png" alt="在这里插入图片描述"></p>
<p>首先UV和DAU通过Redis存储。根据今日日期定义单日UV和单日DAU的key，类似于 uv:20220516。通过起始日期和终止日期定义区间UV和区间DAU的key，类似于 uv:20220516:20220517。</p>
<ol>
<li>新增 DataInterceptor 拦截器，发送请求时，通过ip新增单日UV，通过UserId新增单日DAU。<br>在网址上直接输入 <a target="_blank" rel="noopener" href="http://localhost:8080/community/data">http://localhost:8080/community/data</a> 映射到 DataController 层的 &#x2F;data。返回统计页面。</li>
<li>在网站UV上选好日期，点击开始统计。映射到 &#x2F;data&#x2F;uv 路径。通过 dataService.calculateUV 方法查询UV数量。</li>
<li>calculateUV 方法将区间中每个日期UV的key放入List，然后使用 opsForHyperLogLog().union 进行合并，将值赋给区间UV的key。返回区间UV的数量。DataController 层将数量返回给浏览器。</li>
<li>在活跃用户上，点击开始统计，映射到 &#x2F;data&#x2F;dau 路径。通过 dataService.calculateDAU 方法查询DAU数量。</li>
<li>calculateDAU 方法将区间中每个日期DAU的key放入List。然后进行or运算，将值赋给区间DAU的key，返回数量。DataController 层将数量返回给浏览器。</li>
<li>在 SecurityConfig 中配置只有管理员才能访问该路径。</li>
</ol>
<h3 id="热帖排行"><a href="#热帖排行" class="headerlink" title="热帖排行"></a>热帖排行</h3><ul>
<li>引入分布式定时任务Quartz，添加起步依赖，在application.properties中配置。</li>
<li>当发帖子，对帖子进行点赞，评论和加精时，将帖子 id 放入Redis的set中。</li>
<li>在 PostScoreRefreshJob 中设置定时任务，将需要计算分数的帖子id的从Redis的set中取出。将每个帖子的分数算出，将分数更新到数据库中。将帖子更新到elasticsearch中。</li>
</ul>
<blockquote>
<p>score &#x3D; log（精华分+评论数 * 10+点赞数 * 2）+（发布时间 - 起始时间 ）</p>
</blockquote>
<ul>
<li>在 QuartzConfig 对定时任务进行配置，设置 JobDetail 和 SimpleTrigger。其中设置了定时执行的时间。这样配置好后，Quartz就能自动的执行定时任务。</li>
<li>重构查询帖子函数，加入 orderMode 变量，orderMode&#x3D;0时按照时间倒叙，orderMode&#x3D;1时加入分数倒叙。</li>
<li>其中包括重构service和dao层。在首页点击 “最热” 时，传入orderMode&#x3D;1。查询出按照分数排名的帖子列表。</li>
</ul>
<h3 id="生成长图"><a href="#生成长图" class="headerlink" title="生成长图"></a>生成长图</h3><ol>
<li>安装wk，在application.properties中配置wk的命令位置和存储位置。</li>
<li>在WkConfig配置中创建WK图片目录。</li>
<li>在CommunityConstant设置topic常量，通过路径访问ShareController中 &#x2F;share。触发分享事件。路径：<a target="_blank" rel="noopener" href="http://localhost:8080/community/share?htmlUrl=https://www.baidu.com/">http://localhost:8080/community/share?htmlUrl=https://www.baidu.com/</a></li>
<li>EventConsumer中设置消费分享事件。通过 Runtime.getRuntime().exec(cmd) 命令生成长图并存入存储路径。</li>
<li>同时将生成一个网址返回给浏览器，访问该网址可以浏览到图片。</li>
</ol>
<h3 id="优化网站性能"><a href="#优化网站性能" class="headerlink" title="优化网站性能"></a>优化网站性能</h3><p><img src="https://s2.loli.net/2022/07/31/TAZptxgEWQbDzRq.png" alt="在这里插入图片描述"></p>
<p><img src="https://s2.loli.net/2022/07/31/ZV8xtM26nsA3FBh.png" alt="  架构图："></p>
<ol>
<li><p>对热帖列表进行缓存，因为它可以很长时间保持不变。在此项目中，仅使用了Caffeine做本地缓存，没有使用二级缓存。</p>
</li>
<li><p>引入Caffeine依赖，在application.properties中配置缓存最大数量和失效时间。</p>
</li>
<li><p>在 DiscussPostService 中设置帖子列表缓存和帖子总数缓存变量。使用 @PostConstruct 注解在Service注入前对两个缓存变量进行初始化。</p>
</li>
<li><p>findDiscussPosts 和 findDiscussPostRows 方法查询数据库前，先在本地缓存中查询帖子列表和帖子总数。第一次查没有的话，Caffeine会先查询数据库然后写入本地缓存中然后返回。以后再查就可以在本地缓存中获取。</p>
</li>
<li><p>使用JMeter进行压力测试，用100个线程的线程组访问 &#x2F;community&#x2F;index?orderMode&#x3D;1 共60s。优化后吞吐量为153.6&#x2F;sec。优化前吞吐量为18.3&#x2F;sec。效率提高了10倍左右。</p>
</li>
</ol>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><img src="https://img-blog.csdnimg.cn/9812b57c490e4f748271129b79be1c09.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IqZ6JOJ6ZOB6JuL,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/82a8cb9c94e44962bd1ca7c1aaa426d8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IqZ6JOJ6ZOB6JuL,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/61b8603bdc3d4e4f89c750ab460fef71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IqZ6JOJ6ZOB6JuL,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>niuke -&gt; 123<br>xixi -&gt; 123<br>aaa -&gt; aaa<br>管理员<br>    nowcoder11 –&gt; 123456<br>版主<br>     nowcoder21 –&gt; 123456</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/399324798">Elasticsearch面试题及答案（2021年Elasticsearch面试题大全带答案） - 知乎 (zhihu.com)</a></p>
<h1 id="高性能服务器设计"><a href="#高性能服务器设计" class="headerlink" title="高性能服务器设计"></a>高性能服务器设计</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">木木想去北海种花</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mumu-lsl.github.io/posts/a2c247c4/">https://mumu-lsl.github.io/posts/a2c247c4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mumu-lsl.github.io" target="_blank">Lin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/2c3345f0/"><img class="next-cover" src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java技术原理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">木木想去北海种花</div><div class="author-info__description">Lin在此创作, 欢迎各位</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mumu-LSL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/zumumu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-RPC-%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是 RPC ？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BIO%E4%B8%8ENIO"><span class="toc-number">4.</span> <span class="toc-text">BIO与NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO"><span class="toc-number">4.1.</span> <span class="toc-text">BIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO"><span class="toc-number">4.2.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B8%8EBIO%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">4.3.</span> <span class="toc-text">NIO与BIO的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%9E%8B%E5%92%8CProactor%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">Reactor模型和Proactor模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reactor"><span class="toc-number">4.4.1.</span> <span class="toc-text">Reactor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proactor"><span class="toc-number">4.4.2.</span> <span class="toc-text">Proactor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%9A%BE%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">两个项目的难点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC%E9%A1%B9%E7%9B%AE"><span class="toc-number">6.</span> <span class="toc-text">RPC项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%88%9D%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.</span> <span class="toc-text">最初的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rpc-core"><span class="toc-number">6.2.</span> <span class="toc-text">rpc-core</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%B1%BB"><span class="toc-number">6.2.1.</span> <span class="toc-text">注解类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">编解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServer%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">6.2.3.</span> <span class="toc-text">NettyServer的实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyClient-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.4.</span> <span class="toc-text">NettyClient 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServerHandler-%E5%92%8C-NettyClientHandler"><span class="toc-number">6.2.5.</span> <span class="toc-text">NettyServerHandler 和 NettyClientHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kryo%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.6.</span> <span class="toc-text">kryo序列化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="toc-number">6.2.7.</span> <span class="toc-text">几种序列化方式的优劣</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Nacos%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="toc-number">6.2.8.</span> <span class="toc-text">使用Nacos作为服务器注册与发现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">7.</span> <span class="toc-text">几种注册中心的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">7.0.1.</span> <span class="toc-text">自动注销服务和负载均衡策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">自动注销服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">负载均衡策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rpc-client-rpc-server"><span class="toc-number">7.1.</span> <span class="toc-text">rpc-client,rpc-server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">RPC调用过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#netty"><span class="toc-number">7.3.</span> <span class="toc-text">netty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Netty-%E6%80%A7%E8%83%BD%E9%AB%98"><span class="toc-number">7.3.1.</span> <span class="toc-text">为什么 Netty 性能高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B-Netty-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">7.3.2.</span> <span class="toc-text">说下 Netty 零拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty-%E4%B8%AD%E8%B4%A3%E4%BB%BB%E9%93%BE"><span class="toc-number">7.3.3.</span> <span class="toc-text">Netty 中责任链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B-Netty-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="toc-number">7.3.4.</span> <span class="toc-text">简单说下 Netty 中的重要组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netty%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">7.3.5.</span> <span class="toc-text">netty粘包和拆包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E9%95%BF%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.3.5.1.</span> <span class="toc-text">1. 定长协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.3.5.2.</span> <span class="toc-text">2. 特殊字符分割协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%98%E9%95%BF%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.3.5.3.</span> <span class="toc-text">3. 变长协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-TCP-%E7%9A%84%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">7.3.6.</span> <span class="toc-text">如何解决 TCP 的粘包拆包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netty%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.7.</span> <span class="toc-text">netty心跳机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9A%84"><span class="toc-number">7.3.8.</span> <span class="toc-text">Netty 是如何保持长连接的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.</span> <span class="toc-text">一致性哈希算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.1.</span> <span class="toc-text">数据倾斜问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8-HTTP-%E8%80%8C%E7%94%A8-RPC%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">服务之间的调用为啥不直接用 HTTP 而用 RPC？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">7.5.1.</span> <span class="toc-text">服务发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E8%BF%9E%E6%8E%A5%E5%BD%A2%E5%BC%8F"><span class="toc-number">7.5.2.</span> <span class="toc-text">底层连接形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">7.5.3.</span> <span class="toc-text">传输的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Community-%E9%A1%B9%E7%9B%AE"><span class="toc-number">8.</span> <span class="toc-text">Community 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%92%8C%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97"><span class="toc-number">8.1.</span> <span class="toc-text">注册和登录模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C"><span class="toc-number">8.1.1.</span> <span class="toc-text">注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E8%B4%A6%E5%8F%B7"><span class="toc-number">8.1.2.</span> <span class="toc-text">激活账号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95"><span class="toc-number">8.1.3.</span> <span class="toc-text">登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF"><span class="toc-number">8.1.4.</span> <span class="toc-text">显示登录信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%96%E5%AD%90%E6%A8%A1%E5%9D%97%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">帖子模块（核心）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90"><span class="toc-number">8.2.1.</span> <span class="toc-text">发布帖子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%96%E5%AD%90%E8%AF%A6%E6%83%85"><span class="toc-number">8.2.2.</span> <span class="toc-text">帖子详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%AF%84%E8%AE%BA"><span class="toc-number">8.2.3.</span> <span class="toc-text">显示评论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA"><span class="toc-number">8.2.4.</span> <span class="toc-text">添加评论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E4%BF%A1%E5%88%97%E8%A1%A8"><span class="toc-number">8.2.5.</span> <span class="toc-text">私信列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%A7%81%E4%BF%A1"><span class="toc-number">8.2.6.</span> <span class="toc-text">发送私信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E5%92%8C%E6%97%A5%E5%BF%97"><span class="toc-number">8.3.</span> <span class="toc-text">统一处理异常和日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">8.3.1.</span> <span class="toc-text">处理异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%97%A5%E5%BF%97"><span class="toc-number">8.3.2.</span> <span class="toc-text">处理日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%A8%A1%E5%9D%97-%E7%82%B9%E8%B5%9E%E5%85%B3%E6%B3%A8"><span class="toc-number">8.4.</span> <span class="toc-text">性能模块(点赞关注)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E"><span class="toc-number">8.4.1.</span> <span class="toc-text">点赞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E5%88%B0%E7%9A%84%E8%B5%9E"><span class="toc-number">8.4.2.</span> <span class="toc-text">收到的赞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E5%92%8C%E7%B2%89%E4%B8%9D"><span class="toc-number">8.4.3.</span> <span class="toc-text">关注和粉丝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%85%B3%E6%B3%A8%E5%92%8C%E7%B2%89%E4%B8%9D%E6%95%B0%E9%87%8F"><span class="toc-number">8.4.4.</span> <span class="toc-text">显示关注和粉丝数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%85%B3%E6%B3%A8%E5%92%8C%E7%B2%89%E4%B8%9D%E5%88%97%E8%A1%A8"><span class="toc-number">8.4.5.</span> <span class="toc-text">显示关注和粉丝列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%99%BB%E9%99%86"><span class="toc-number">8.4.6.</span> <span class="toc-text">优化登陆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E6%A8%A1%E5%9D%97"><span class="toc-number">8.5.</span> <span class="toc-text">通知模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5"><span class="toc-number">8.5.1.</span> <span class="toc-text">显示系统通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Kafka%E8%80%8C%E4%B8%8D%E6%98%AFRabbitMq%EF%BC%9F"><span class="toc-number">8.5.2.</span> <span class="toc-text">为什么Kafka而不是RabbitMq？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8B%89%EF%BC%88Pull%EF%BC%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.5.2.1.</span> <span class="toc-text">基于拉（Pull）的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A8%EF%BC%88Push%EF%BC%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.5.2.2.</span> <span class="toc-text">基于推（Push）的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD"><span class="toc-number">8.6.</span> <span class="toc-text">搜索功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%A8%A1%E5%9D%97"><span class="toc-number">8.7.</span> <span class="toc-text">权限模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"><span class="toc-number">8.8.</span> <span class="toc-text">其他功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%AE%E9%A1%B6%EF%BC%8C%E5%8A%A0%E7%B2%BE%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">8.8.1.</span> <span class="toc-text">置顶，加精和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1"><span class="toc-number">8.8.2.</span> <span class="toc-text">网站数据统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E5%B8%96%E6%8E%92%E8%A1%8C"><span class="toc-number">8.8.3.</span> <span class="toc-text">热帖排行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E9%95%BF%E5%9B%BE"><span class="toc-number">8.8.4.</span> <span class="toc-text">生成长图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD"><span class="toc-number">8.8.5.</span> <span class="toc-text">优化网站性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">8.9.</span> <span class="toc-text">分布式锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.</span> <span class="toc-text">高性能服务器设计</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a2c247c4/" title="项目"><img src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目"/></a><div class="content"><a class="title" href="/posts/a2c247c4/" title="项目">项目</a><time datetime="2022-09-17T06:29:58.000Z" title="发表于 2022-09-17 14:29:58">2022-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2c3345f0/" title="Java技术原理"><img src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java技术原理"/></a><div class="content"><a class="title" href="/posts/2c3345f0/" title="Java技术原理">Java技术原理</a><time datetime="2022-05-24T15:13:57.000Z" title="发表于 2022-05-24 23:13:57">2022-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bfaf5b1d/" title="RPC框架"><img src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RPC框架"/></a><div class="content"><a class="title" href="/posts/bfaf5b1d/" title="RPC框架">RPC框架</a><time datetime="2022-05-24T15:13:24.000Z" title="发表于 2022-05-24 23:13:24">2022-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7b25d017/" title="redis"><img src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis"/></a><div class="content"><a class="title" href="/posts/7b25d017/" title="redis">redis</a><time datetime="2022-05-24T15:13:05.000Z" title="发表于 2022-05-24 23:13:05">2022-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6096f3d5/" title="LeetCode"><img src="https://s2.loli.net/2022/02/11/YaJySpVl2sNrqxO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode"/></a><div class="content"><a class="title" href="/posts/6096f3d5/" title="LeetCode">LeetCode</a><time datetime="2022-05-24T15:07:50.000Z" title="发表于 2022-05-24 23:07:50">2022-05-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: -rgb(0,0,255)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 木木想去北海种花</div><div class="footer_custom_text">所有你乐于挥霍的时间，都不能算作浪费</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="null" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>